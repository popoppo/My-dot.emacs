<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>EmacsWiki: anything-config.el</title><link rel="alternate" type="application/wiki" title="Edit this page" href="http://www.emacswiki.org/emacs?action=edit;id=anything-config.el" /><link type="text/css" rel="stylesheet" href="/emacs/wiki.css" /><meta name="robots" content="INDEX,FOLLOW" /><link rel="alternate" type="application/rss+xml" title="EmacsWiki" href="http://www.emacswiki.org/emacs?action=rss" /><link rel="alternate" type="application/rss+xml" title="EmacsWiki: anything-config.el" href="http://www.emacswiki.org/emacs?action=rss;rcidonly=anything-config.el" />
<link rel="alternate" type="application/rss+xml"
      title="Emacs Wiki with page content"
      href="http://www.emacswiki.org/emacs/full.rss" />
<link rel="alternate" type="application/rss+xml"
      title="Emacs Wiki with page content and diff"
      href="http://www.emacswiki.org/emacs/full-diff.rss" />
<link rel="alternate" type="application/rss+xml"
      title="Emacs Wiki including minor differences"
      href="http://www.emacswiki.org/emacs/minor-edits.rss" />
<link rel="alternate" type="application/rss+xml"
      title="Changes for anything-config.el only"
      href="http://www.emacswiki.org/emacs?action=rss;rcidonly=anything-config.el" />
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-2101513-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/></head><body class="http://www.emacswiki.org/emacs"><div class="header"><a class="logo" href="http://www.emacswiki.org/emacs/SiteMap"><img class="logo" src="/emacs_logo.png" alt="[Home]" /></a><span class="gotobar bar"><a class="local" href="http://www.emacswiki.org/emacs/SiteMap">SiteMap</a> <a class="local" href="http://www.emacswiki.org/emacs/Search">Search</a> <a class="local" href="http://www.emacswiki.org/emacs/ElispArea">ElispArea</a> <a class="local" href="http://www.emacswiki.org/emacs/HowTo">HowTo</a> <a class="local" href="http://www.emacswiki.org/emacs/RecentChanges">RecentChanges</a> <a class="local" href="http://www.emacswiki.org/emacs/News">News</a> <a class="local" href="http://www.emacswiki.org/emacs/Problems">Problems</a> <a class="local" href="http://www.emacswiki.org/emacs/Suggestions">Suggestions</a> </span>
<!-- Google CSE Search Box Begins  -->
<form class="tiny" action="http://www.google.com/cse" id="searchbox_004774160799092323420:6-ff2s0o6yi"><p>
<input type="hidden" name="cx" value="004774160799092323420:6-ff2s0o6yi" />
<input type="text" name="q" size="25" />
<input type="submit" name="sa" value="Search" />
</p></form>
<script type="text/javascript" src="http://www.google.com/coop/cse/brand?form=searchbox_004774160799092323420%3A6-ff2s0o6yi"></script>
<!-- Google CSE Search Box Ends -->
<h1><a title="Click to search for references to this page" rel="nofollow" href="http://www.google.com/cse?cx=004774160799092323420:6-ff2s0o6yi&amp;q=%22anything-config.el%22">anything-config.el</a></h1></div><div class="wrapper"><div class="content browse"><p class="download"><a href="http://www.emacswiki.org/emacs/download/anything-config.el">Download</a></p><pre class="code"><span class="linecomment">;;; anything-config.el --- Predefined configurations for `anything.el'</span>

<span class="linecomment">;; Filename: anything-config.el</span>

<span class="linecomment">;; Description: Predefined configurations for `anything.el'</span>
<span class="linecomment">;; Author: Tassilo Horn &lt;tassilo@member.fsf.org&gt;</span>
<span class="linecomment">;; Maintainer: Tassilo Horn &lt;tassilo@member.fsf.org&gt;</span>
<span class="linecomment">;;             rubikitch    &lt;rubikitch@ruby-lang.org&gt;</span>
<span class="linecomment">;;             Thierry Volpiatto &lt;thierry.volpiatto@gmail.com&gt;</span>
<span class="linecomment">;; Copyright (C) 2007 ~ 2011, Tassilo Horn, all rights reserved.</span>
<span class="linecomment">;; Copyright (C) 2009, Andy Stewart, all rights reserved.</span>
<span class="linecomment">;; Copyright (C) 2009 ~ 2011, rubikitch, all rights reserved.</span>
<span class="linecomment">;; Copyright (C) 2009 ~ 2011, Thierry Volpiatto, all rights reserved.</span>
<span class="linecomment">;; Created: 2009-02-16 21:38:23</span>
<span class="linecomment">;; Version: 0.4.1</span>
<span class="linecomment">;; URL: http://www.emacswiki.org/emacs/download/anything-config.el</span>
<span class="linecomment">;; Keywords: anything, anything-config</span>
<span class="linecomment">;; Compatibility: GNU Emacs 22 ~ 23</span>
<span class="linecomment">;;</span>
<span class="linecomment">;; Features that might be required by this library:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;; `anything'</span>
<span class="linecomment">;;</span>

<span class="linecomment">;;; This file is NOT part of GNU Emacs</span>

<span class="linecomment">;;; License</span>
<span class="linecomment">;;</span>
<span class="linecomment">;; This program is free software; you can redistribute it and/or modify</span>
<span class="linecomment">;; it under the terms of the GNU General Public License as published by</span>
<span class="linecomment">;; the Free Software Foundation; either version 3, or (at your option)</span>
<span class="linecomment">;; any later version.</span>

<span class="linecomment">;; This program is distributed in the hope that it will be useful,</span>
<span class="linecomment">;; but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="linecomment">;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="linecomment">;; GNU General Public License for more details.</span>

<span class="linecomment">;; You should have received a copy of the GNU General Public License</span>
<span class="linecomment">;; along with this program; see the file COPYING.  If not, write to</span>
<span class="linecomment">;; the Free Software Foundation, Inc., 51 Franklin Street, Fifth</span>
<span class="linecomment">;; Floor, Boston, MA 02110-1301, USA.</span>

<span class="linecomment">;;; !NOTICE!</span>
<span class="linecomment">;;</span>
<span class="linecomment">;; If this file does not work, upgrade anything.el!</span>
<span class="linecomment">;; http://www.emacswiki.org/cgi-bin/wiki/download/anything.el</span>

<span class="linecomment">;;; Commentary:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;; Predefined configurations for `anything.el'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;; For quick start, try `anything-for-files' to open files.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;; To configure anything you should define anything command</span>
<span class="linecomment">;; with your favorite sources, like below:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;; (defun my-anything ()</span>
<span class="linecomment">;;   (interactive)</span>
<span class="linecomment">;;   (anything-other-buffer</span>
<span class="linecomment">;;    '(anything-c-source-buffers</span>
<span class="linecomment">;;      anything-c-source-file-name-history</span>
<span class="linecomment">;;      anything-c-source-info-pages</span>
<span class="linecomment">;;      anything-c-source-info-elisp</span>
<span class="linecomment">;;      anything-c-source-man-pages</span>
<span class="linecomment">;;      anything-c-source-locate</span>
<span class="linecomment">;;      anything-c-source-emacs-commands)</span>
<span class="linecomment">;;    " *my-anything*"))</span>
<span class="linecomment">;;</span>
<span class="linecomment">;; Then type M-x my-anything to use sources.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;; Defining own command is better than setup `anything-sources'</span>
<span class="linecomment">;; directly, because you can define multiple anything commands with</span>
<span class="linecomment">;; different sources. Each anything command should have own anything</span>
<span class="linecomment">;; buffer, because M-x anything-resume revives anything command.</span>

<span class="linecomment">;;; Autodoc documentation:</span>
<span class="linecomment">;;  ---------------------</span>

<span class="linecomment">;;  * Commands defined here are:</span>
<span class="linecomment">;; [EVAL] (autodoc-document-lisp-buffer :type 'command :prefix "anything-" :docstring t)</span>
<span class="linecomment">;; `anything-configuration'</span>
<span class="linecomment">;; Customize `anything'.</span>
<span class="linecomment">;; `anything-c-describe-anything-bindings'</span>
<span class="linecomment">;; [OBSOLETE] Describe `anything' bindings.</span>
<span class="linecomment">;; `anything-mini'</span>
<span class="linecomment">;; Preconfigured `anything' lightweight version		(buffer -&gt; recentf).</span>
<span class="linecomment">;; `anything-for-files'</span>
<span class="linecomment">;; Preconfigured `anything' for opening files.</span>
<span class="linecomment">;; `anything-recentf'</span>
<span class="linecomment">;; Preconfigured `anything' for `recentf'.</span>
<span class="linecomment">;; `anything-info-at-point'</span>
<span class="linecomment">;; Preconfigured `anything' for searching info at point.</span>
<span class="linecomment">;; `anything-info-emacs'</span>
<span class="linecomment">;; Preconfigured anything for Emacs manual index.</span>
<span class="linecomment">;; `anything-show-kill-ring'</span>
<span class="linecomment">;; Preconfigured `anything' for `kill-ring'. It is drop-in replacement of `yank-pop'.</span>
<span class="linecomment">;; `anything-minibuffer-history'</span>
<span class="linecomment">;; Preconfigured `anything' for `minibuffer-history'.</span>
<span class="linecomment">;; `anything-gentoo'</span>
<span class="linecomment">;; Preconfigured `anything' for gentoo linux.</span>
<span class="linecomment">;; `anything-imenu'</span>
<span class="linecomment">;; Preconfigured `anything' for `imenu'.</span>
<span class="linecomment">;; `anything-google-suggest'</span>
<span class="linecomment">;; Preconfigured `anything' for google search with google suggest.</span>
<span class="linecomment">;; `anything-yahoo-suggest'</span>
<span class="linecomment">;; Preconfigured `anything' for Yahoo searching with Yahoo suggest.</span>
<span class="linecomment">;; `anything-for-buffers'</span>
<span class="linecomment">;; Preconfigured `anything' for buffer.</span>
<span class="linecomment">;; `anything-buffers+'</span>
<span class="linecomment">;; Enhanced preconfigured `anything' for buffer.</span>
<span class="linecomment">;; `anything-bbdb'</span>
<span class="linecomment">;; Preconfigured `anything' for BBDB.</span>
<span class="linecomment">;; `anything-locate'</span>
<span class="linecomment">;; Preconfigured `anything' for Locate.</span>
<span class="linecomment">;; `anything-w3m-bookmarks'</span>
<span class="linecomment">;; Preconfigured `anything' for w3m bookmark.</span>
<span class="linecomment">;; `anything-firefox-bookmarks'</span>
<span class="linecomment">;; Preconfigured `anything' for firefox bookmark.</span>
<span class="linecomment">;; `anything-colors'</span>
<span class="linecomment">;; Preconfigured `anything' for color.</span>
<span class="linecomment">;; `anything-bookmarks'</span>
<span class="linecomment">;; Preconfigured `anything' for bookmarks.</span>
<span class="linecomment">;; `anything-c-pp-bookmarks'</span>
<span class="linecomment">;; Preconfigured `anything' for bookmarks		(pretty-printed).</span>
<span class="linecomment">;; `anything-c-insert-latex-math'</span>
<span class="linecomment">;; Preconfigured anything for latex math symbols completion.</span>
<span class="linecomment">;; `anything-register'</span>
<span class="linecomment">;; Preconfigured `anything' for Emacs registers.</span>
<span class="linecomment">;; `anything-man-woman'</span>
<span class="linecomment">;; Preconfigured `anything' for Man and Woman pages.</span>
<span class="linecomment">;; `anything-org-keywords'</span>
<span class="linecomment">;; Preconfigured `anything' for org keywords.</span>
<span class="linecomment">;; `anything-emms'</span>
<span class="linecomment">;; Preconfigured `anything' for emms sources.</span>
<span class="linecomment">;; `anything-eev-anchors'</span>
<span class="linecomment">;; Preconfigured `anything' for eev anchors.</span>
<span class="linecomment">;; `anything-bm-list'</span>
<span class="linecomment">;; Preconfigured `anything' for visible bookmarks.</span>
<span class="linecomment">;; `anything-timers'</span>
<span class="linecomment">;; Preconfigured `anything' for timers.</span>
<span class="linecomment">;; `anything-list-emacs-process'</span>
<span class="linecomment">;; Preconfigured `anything' for emacs process.</span>
<span class="linecomment">;; `anything-occur'</span>
<span class="linecomment">;; Preconfigured Anything for Occur source.</span>
<span class="linecomment">;; `anything-browse-code'</span>
<span class="linecomment">;; Preconfigured anything to browse code.</span>
<span class="linecomment">;; `anything-org-headlines'</span>
<span class="linecomment">;; Preconfigured anything to show org headlines.</span>
<span class="linecomment">;; `anything-kill-buffers'</span>
<span class="linecomment">;; Preconfigured `anything' to kill buffer you selected.</span>
<span class="linecomment">;; `anything-regexp'</span>
<span class="linecomment">;; Preconfigured anything to build regexps and run query-replace-regexp against.</span>
<span class="linecomment">;; `anything-insert-buffer-name'</span>
<span class="linecomment">;; Insert buffer name.</span>
<span class="linecomment">;; `anything-insert-symbol'</span>
<span class="linecomment">;; Insert current symbol.</span>
<span class="linecomment">;; `anything-insert-selection'</span>
<span class="linecomment">;; Insert current selection.</span>
<span class="linecomment">;; `anything-show-buffer-only'</span>
<span class="linecomment">;; [OBSOLETE] Only show sources about buffer.</span>
<span class="linecomment">;; `anything-show-bbdb-only'</span>
<span class="linecomment">;; [OBSOLETE] Only show sources about BBDB.</span>
<span class="linecomment">;; `anything-show-locate-only'</span>
<span class="linecomment">;; [OBSOLETE] Only show sources about Locate.</span>
<span class="linecomment">;; `anything-show-info-only'</span>
<span class="linecomment">;; [OBSOLETE] Only show sources about Info.</span>
<span class="linecomment">;; `anything-show-imenu-only'</span>
<span class="linecomment">;; [OBSOLETE] Only show sources about Imenu.</span>
<span class="linecomment">;; `anything-show-files-only'</span>
<span class="linecomment">;; [OBSOLETE] Only show sources about File.</span>
<span class="linecomment">;; `anything-show-w3m-bookmarks-only'</span>
<span class="linecomment">;; [OBSOLETE] Only show source about w3m bookmark.</span>
<span class="linecomment">;; `anything-show-colors-only'</span>
<span class="linecomment">;; [OBSOLETE] Only show source about color.</span>
<span class="linecomment">;; `anything-show-kill-ring-only'</span>
<span class="linecomment">;; [OBSOLETE] Only show source about kill ring.</span>
<span class="linecomment">;; `anything-show-this-source-only'</span>
<span class="linecomment">;; Only show this source.</span>
<span class="linecomment">;; `anything-test-sources'</span>
<span class="linecomment">;; List all anything sources for test.</span>
<span class="linecomment">;; `anything-select-source'</span>
<span class="linecomment">;; Select source.</span>
<span class="linecomment">;; `anything-mark-all'</span>
<span class="linecomment">;; Mark all visible unmarked candidates in current source.</span>
<span class="linecomment">;; `anything-unmark-all'</span>
<span class="linecomment">;; Unmark all candidates in all sources of current anything session.</span>
<span class="linecomment">;; `anything-toggle-all-marks'</span>
<span class="linecomment">;; Toggle all marks.</span>
<span class="linecomment">;; `anything-c-buffer-help'</span>
<span class="linecomment">;; Not documented.</span>
<span class="linecomment">;; `anything-buffer-diff-persistent'</span>
<span class="linecomment">;; Toggle diff buffer without quitting anything.</span>
<span class="linecomment">;; `anything-buffer-revert-persistent'</span>
<span class="linecomment">;; Revert buffer without quitting anything.</span>
<span class="linecomment">;; `anything-buffer-save-persistent'</span>
<span class="linecomment">;; Save buffer without quitting anything.</span>
<span class="linecomment">;; `anything-buffer-run-kill-buffers'</span>
<span class="linecomment">;; Run kill buffer action from `anything-c-source-buffer+'.</span>
<span class="linecomment">;; `anything-buffer-run-grep'</span>
<span class="linecomment">;; Run Grep action from `anything-c-source-buffer+'.</span>
<span class="linecomment">;; `anything-buffer-run-query-replace-regexp'</span>
<span class="linecomment">;; Run Query replace regexp action from `anything-c-source-buffer+'.</span>
<span class="linecomment">;; `anything-buffer-run-query-replace'</span>
<span class="linecomment">;; Run Query replace action from `anything-c-source-buffer+'.</span>
<span class="linecomment">;; `anything-buffer-switch-other-window'</span>
<span class="linecomment">;; Run switch to other window action from `anything-c-source-buffer+'.</span>
<span class="linecomment">;; `anything-buffer-switch-other-frame'</span>
<span class="linecomment">;; Run switch to other frame action from `anything-c-source-buffer+'.</span>
<span class="linecomment">;; `anything-buffer-switch-to-elscreen'</span>
<span class="linecomment">;; Run switch to elscreen  action from `anything-c-source-buffer+'.</span>
<span class="linecomment">;; `anything-ff-help'</span>
<span class="linecomment">;; Not documented.</span>
<span class="linecomment">;; `anything-ff-run-switch-to-history'</span>
<span class="linecomment">;; Run Switch to history action from `anything-c-source-find-files'.</span>
<span class="linecomment">;; `anything-ff-run-grep'</span>
<span class="linecomment">;; Run Grep action from `anything-c-source-find-files'.</span>
<span class="linecomment">;; `anything-ff-run-pdfgrep'</span>
<span class="linecomment">;; Run Pdfgrep action from `anything-c-source-find-files'.</span>
<span class="linecomment">;; `anything-ff-run-copy-file'</span>
<span class="linecomment">;; Run Copy file action from `anything-c-source-find-files'.</span>
<span class="linecomment">;; `anything-ff-run-rename-file'</span>
<span class="linecomment">;; Run Rename file action from `anything-c-source-find-files'.</span>
<span class="linecomment">;; `anything-ff-run-byte-compile-file'</span>
<span class="linecomment">;; Run Byte compile file action from `anything-c-source-find-files'.</span>
<span class="linecomment">;; `anything-ff-run-load-file'</span>
<span class="linecomment">;; Run Load file action from `anything-c-source-find-files'.</span>
<span class="linecomment">;; `anything-ff-run-eshell-command-on-file'</span>
<span class="linecomment">;; Run eshell command on file action from `anything-c-source-find-files'.</span>
<span class="linecomment">;; `anything-ff-run-ediff-file'</span>
<span class="linecomment">;; Run Ediff file action from `anything-c-source-find-files'.</span>
<span class="linecomment">;; `anything-ff-run-ediff-merge-file'</span>
<span class="linecomment">;; Run Ediff merge file action from `anything-c-source-find-files'.</span>
<span class="linecomment">;; `anything-ff-run-symlink-file'</span>
<span class="linecomment">;; Run Symlink file action from `anything-c-source-find-files'.</span>
<span class="linecomment">;; `anything-ff-run-delete-file'</span>
<span class="linecomment">;; Run Delete file action from `anything-c-source-find-files'.</span>
<span class="linecomment">;; `anything-ff-run-complete-fn-at-point'</span>
<span class="linecomment">;; Run complete file name action from `anything-c-source-find-files'.</span>
<span class="linecomment">;; `anything-ff-run-switch-to-eshell'</span>
<span class="linecomment">;; Run switch to eshell action from `anything-c-source-find-files'.</span>
<span class="linecomment">;; `anything-ff-run-switch-other-window'</span>
<span class="linecomment">;; Run switch to other window action from `anything-c-source-find-files'.</span>
<span class="linecomment">;; `anything-ff-run-switch-other-frame'</span>
<span class="linecomment">;; Run switch to other frame action from `anything-c-source-find-files'.</span>
<span class="linecomment">;; `anything-ff-run-open-file-externally'</span>
<span class="linecomment">;; Run open file externally command action from `anything-c-source-find-files'.</span>
<span class="linecomment">;; `anything-ff-run-gnus-attach-files'</span>
<span class="linecomment">;; Run gnus attach files command action from `anything-c-source-find-files'.</span>
<span class="linecomment">;; `anything-ff-run-print-file'</span>
<span class="linecomment">;; Run Print file action from `anything-c-source-find-files'.</span>
<span class="linecomment">;; `anything-find-files-down-one-level'</span>
<span class="linecomment">;; Go down one level like unix command `cd ..'.</span>
<span class="linecomment">;; `anything-ff-properties-persistent'</span>
<span class="linecomment">;; Show properties without quitting anything.</span>
<span class="linecomment">;; `anything-ff-rotate-left-persistent'</span>
<span class="linecomment">;; Rotate image left without quitting anything.</span>
<span class="linecomment">;; `anything-ff-rotate-right-persistent'</span>
<span class="linecomment">;; Rotate image right without quitting anything.</span>
<span class="linecomment">;; `anything-find-files'</span>
<span class="linecomment">;; Preconfigured `anything' for anything implementation of `find-file'.</span>
<span class="linecomment">;; `anything-write-file'</span>
<span class="linecomment">;; Preconfigured `anything' providing completion for `write-file'.</span>
<span class="linecomment">;; `anything-insert-file'</span>
<span class="linecomment">;; Preconfigured `anything' providing completion for `insert-file'.</span>
<span class="linecomment">;; `anything-dired-rename-file'</span>
<span class="linecomment">;; Preconfigured `anything' to rename files from dired.</span>
<span class="linecomment">;; `anything-dired-copy-file'</span>
<span class="linecomment">;; Preconfigured `anything' to copy files from dired.</span>
<span class="linecomment">;; `anything-dired-symlink-file'</span>
<span class="linecomment">;; Preconfigured `anything' to symlink files from dired.</span>
<span class="linecomment">;; `anything-dired-hardlink-file'</span>
<span class="linecomment">;; Preconfigured `anything' to hardlink files from dired.</span>
<span class="linecomment">;; `anything-dired-bindings'</span>
<span class="linecomment">;; Replace usual dired commands `C' and `R' by anything ones.</span>
<span class="linecomment">;; `anything-generic-file-help'</span>
<span class="linecomment">;; Not documented.</span>
<span class="linecomment">;; `anything-do-grep'</span>
<span class="linecomment">;; Preconfigured anything for grep.</span>
<span class="linecomment">;; `anything-c-goto-precedent-file'</span>
<span class="linecomment">;; Go to precedent file in anything grep/etags buffers.</span>
<span class="linecomment">;; `anything-c-goto-next-file'</span>
<span class="linecomment">;; Go to precedent file in anything grep/etags buffers.</span>
<span class="linecomment">;; `anything-grep-help'</span>
<span class="linecomment">;; Not documented.</span>
<span class="linecomment">;; `anything-c-grep-run-persistent-action'</span>
<span class="linecomment">;; Run grep persistent action from `anything-do-grep1'.</span>
<span class="linecomment">;; `anything-c-grep-run-default-action'</span>
<span class="linecomment">;; Run grep default action from `anything-do-grep1'.</span>
<span class="linecomment">;; `anything-c-grep-run-other-window-action'</span>
<span class="linecomment">;; Run grep goto other window action from `anything-do-grep1'.</span>
<span class="linecomment">;; `anything-c-grep-run-save-buffer'</span>
<span class="linecomment">;; Run grep save results action from `anything-do-grep1'.</span>
<span class="linecomment">;; `anything-pdfgrep-help'</span>
<span class="linecomment">;; Not documented.</span>
<span class="linecomment">;; `anything-do-pdfgrep'</span>
<span class="linecomment">;; Not documented.</span>
<span class="linecomment">;; `anything-yank-text-at-point'</span>
<span class="linecomment">;; Yank text at point in minibuffer.</span>
<span class="linecomment">;; `anything-etags-help'</span>
<span class="linecomment">;; Not documented.</span>
<span class="linecomment">;; `anything-c-etags-select'</span>
<span class="linecomment">;; Preconfigured anything for etags.</span>
<span class="linecomment">;; `anything-filelist'</span>
<span class="linecomment">;; Preconfigured `anything' to open files instantly.</span>
<span class="linecomment">;; `anything-filelist+'</span>
<span class="linecomment">;; Preconfigured `anything' to open files/buffers/bookmarks instantly.</span>
<span class="linecomment">;; `anything-c-describe-attributes'</span>
<span class="linecomment">;; Display the full documentation of ANYTHING-ATTRIBUTE (a symbol).</span>
<span class="linecomment">;; `anything-M-x'</span>
<span class="linecomment">;; Preconfigured `anything' for Emacs commands.</span>
<span class="linecomment">;; `anything-manage-advice'</span>
<span class="linecomment">;; Preconfigured `anything' to disable/enable function advices.</span>
<span class="linecomment">;; `anything-bookmark-ext'</span>
<span class="linecomment">;; Preconfigured `anything' for bookmark-extensions sources.</span>
<span class="linecomment">;; `anything-simple-call-tree'</span>
<span class="linecomment">;; Preconfigured `anything' for simple-call-tree. List function relationships.</span>
<span class="linecomment">;; `anything-mark-ring'</span>
<span class="linecomment">;; Preconfigured `anything' for `anything-c-source-mark-ring'.</span>
<span class="linecomment">;; `anything-global-mark-ring'</span>
<span class="linecomment">;; Preconfigured `anything' for `anything-c-source-global-mark-ring'.</span>
<span class="linecomment">;; `anything-all-mark-rings'</span>
<span class="linecomment">;; Preconfigured `anything' for `anything-c-source-global-mark-ring' and `anything-c-source-mark-ring'.</span>
<span class="linecomment">;; `anything-yaoddmuse-cache-pages'</span>
<span class="linecomment">;; Fetch the list of files on emacswiki and create cache file.</span>
<span class="linecomment">;; `anything-yaoddmuse-emacswiki-edit-or-view'</span>
<span class="linecomment">;; Preconfigured `anything' to edit or view EmacsWiki page.</span>
<span class="linecomment">;; `anything-yaoddmuse-emacswiki-post-library'</span>
<span class="linecomment">;; Preconfigured `anything' to post library to EmacsWiki.</span>
<span class="linecomment">;; `anything-eval-expression'</span>
<span class="linecomment">;; Preconfigured anything for `anything-c-source-evaluation-result'.</span>
<span class="linecomment">;; `anything-eval-expression-with-eldoc'</span>
<span class="linecomment">;; Preconfigured anything for `anything-c-source-evaluation-result' with `eldoc' support. </span>
<span class="linecomment">;; `anything-calcul-expression'</span>
<span class="linecomment">;; Preconfigured anything for `anything-c-source-calculation-result'.</span>
<span class="linecomment">;; `anything-surfraw'</span>
<span class="linecomment">;; Preconfigured `anything' to search PATTERN with search ENGINE.</span>
<span class="linecomment">;; `anything-call-source'</span>
<span class="linecomment">;; Preconfigured `anything' to call anything source.</span>
<span class="linecomment">;; `anything-call-source-from-anything'</span>
<span class="linecomment">;; Call anything source within `anything' session.</span>
<span class="linecomment">;; `anything-execute-anything-command'</span>
<span class="linecomment">;; Preconfigured `anything' to execute preconfigured `anything'.</span>
<span class="linecomment">;; `anything-create-from-anything'</span>
<span class="linecomment">;; Run `anything-create' from `anything' as a fallback.</span>
<span class="linecomment">;; `anything-create'</span>
<span class="linecomment">;; Preconfigured `anything' to do many create actions from STRING.</span>
<span class="linecomment">;; `anything-top'</span>
<span class="linecomment">;; Preconfigured `anything' for top command.</span>
<span class="linecomment">;; `anything-select-xfont'</span>
<span class="linecomment">;; Preconfigured `anything' to select Xfont.</span>
<span class="linecomment">;; `anything-world-time'</span>
<span class="linecomment">;; Preconfigured `anything' to show world time.</span>
<span class="linecomment">;; `anything-apt'</span>
<span class="linecomment">;; Preconfigured `anything' : frontend of APT package manager.</span>
<span class="linecomment">;; `anything-c-shell-command-if-needed'</span>
<span class="linecomment">;; Not documented.</span>
<span class="linecomment">;; `anything-c-run-external-command'</span>
<span class="linecomment">;; Preconfigured `anything' to run External PROGRAM asyncronously from Emacs.</span>
<span class="linecomment">;; `anything-ratpoison-commands'</span>
<span class="linecomment">;; Preconfigured `anything' to execute ratpoison commands.</span>
<span class="linecomment">;; `anything-c-set-variable'</span>
<span class="linecomment">;; Set value to VAR interactively.</span>
<span class="linecomment">;; `anything-c-adaptive-save-history'</span>
<span class="linecomment">;; Save history information to file given by `anything-c-adaptive-history-file'.</span>
<span class="linecomment">;; `anything-c-reset-adaptative-history'</span>
<span class="linecomment">;; Delete all `anything-c-adaptive-history' and his file.</span>
<span class="linecomment">;; `anything-c-toggle-match-plugin'</span>
<span class="linecomment">;; Toggle anything-match-plugin.</span>

<span class="linecomment">;;  * User variables defined here:</span>
<span class="linecomment">;; [EVAL] (autodoc-document-lisp-buffer :type 'user-variable :prefix "anything-" :var-value t)</span>
<span class="linecomment">;; `anything-c-use-standard-keys'</span>
<span class="linecomment">;; Default Value: nil</span>
<span class="linecomment">;; `anything-c-adaptive-history-file'</span>
<span class="linecomment">;; Default Value: "~/.emacs.d/anything-c-adaptive-history"</span>
<span class="linecomment">;; `anything-c-adaptive-history-length'</span>
<span class="linecomment">;; Default Value: 50</span>
<span class="linecomment">;; `anything-c-google-suggest-url'</span>
<span class="linecomment">;; Default Value: "http://google.com/complete/search?output=toolbar&q="</span>
<span class="linecomment">;; `anything-c-google-suggest-search-url'</span>
<span class="linecomment">;; Default Value: "http://www.google.com/search?ie=utf-8&oe=utf-8&q="</span>
<span class="linecomment">;; `anything-google-suggest-use-curl-p'</span>
<span class="linecomment">;; Default Value: nil</span>
<span class="linecomment">;; `anything-c-yahoo-suggest-url'</span>
<span class="linecomment">;; Default Value: "http://search.yahooapis.com/WebSearchService/V1/relatedSuggestion?appid=G [...]</span>
<span class="linecomment">;; `anything-c-yahoo-suggest-search-url'</span>
<span class="linecomment">;; Default Value: "http://search.yahoo.com/search?&ei=UTF-8&fr&h=c&p="</span>
<span class="linecomment">;; `anything-c-boring-buffer-regexp'</span>
<span class="linecomment">;; Default Value: "\\	(\\` \\)\\|\\*anything\\| \\*Echo Area\\| \\*Minibuf"</span>
<span class="linecomment">;; `anything-c-boring-file-regexp'</span>
<span class="linecomment">;; Default Value: "/\\	(?:\\(?:\\.\\(?:git\\|hg\\|svn\\)\\|CVS\\|_darcs\\)\\)\\(?:/\\|$\\)\\| [...]</span>
<span class="linecomment">;; `anything-kill-ring-threshold'</span>
<span class="linecomment">;; Default Value: 10</span>
<span class="linecomment">;; `anything-su-or-sudo'</span>
<span class="linecomment">;; Default Value: "su"</span>
<span class="linecomment">;; `anything-for-files-prefered-list'</span>
<span class="linecomment">;; Default Value:	(anything-c-source-ffap-line anything-c-source-ffap-guesser anything-c-sou [...]</span>
<span class="linecomment">;; `anything-create--actions-private'</span>
<span class="linecomment">;; Default Value: nil</span>
<span class="linecomment">;; `anything-allow-skipping-current-buffer'</span>
<span class="linecomment">;; Default Value: t</span>
<span class="linecomment">;; `anything-c-enable-eval-defun-hack'</span>
<span class="linecomment">;; Default Value: t</span>
<span class="linecomment">;; `anything-tramp-verbose'</span>
<span class="linecomment">;; Default Value: 0</span>
<span class="linecomment">;; `anything-raise-command'</span>
<span class="linecomment">;; Default Value: nil</span>
<span class="linecomment">;; `anything-command-map-prefix-key'</span>
<span class="linecomment">;; Default Value: "&lt;f5&gt; a"</span>
<span class="linecomment">;; `anything-c-find-files-show-icons'</span>
<span class="linecomment">;; Default Value: nil</span>
<span class="linecomment">;; `anything-c-find-files-icons-directory'</span>
<span class="linecomment">;; Default Value: "/usr/local/share/emacs/24.0.50/etc/images/tree-widget/default"</span>
<span class="linecomment">;; `anything-c-browse-code-regexp-lisp'</span>
<span class="linecomment">;; Default Value: "^ *	(def\\(un\\|subst\\|macro\\|face\\|alias\\|advice\\|struct\\|type\\|th [...]</span>
<span class="linecomment">;; `anything-c-browse-code-regexp-python'</span>
<span class="linecomment">;; Default Value: "\\&lt;def\\&gt;\\|\\&lt;class\\&gt;"</span>
<span class="linecomment">;; `anything-c-browse-code-regexp-alist'</span>
<span class="linecomment">;; Default Value:	((lisp-interaction-mode . "^ *(def\\(un\\|subst\\|macro\\|face\\|alias\\|a [...]</span>
<span class="linecomment">;; `anything-c-external-programs-associations'</span>
<span class="linecomment">;; Default Value: nil</span>
<span class="linecomment">;; `anything-ff-lynx-style-map'</span>
<span class="linecomment">;; Default Value: t</span>
<span class="linecomment">;; `anything-ff-history-max-length'</span>
<span class="linecomment">;; Default Value: 100</span>
<span class="linecomment">;; `anything-ff-default-kbsize'</span>
<span class="linecomment">;; Default Value: 1024.0</span>
<span class="linecomment">;; `anything-ff-exif-data-program'</span>
<span class="linecomment">;; Default Value: "exiftran"</span>
<span class="linecomment">;; `anything-ff-exif-data-program-args'</span>
<span class="linecomment">;; Default Value: "-d"</span>
<span class="linecomment">;; `anything-c-grep-use-ioccur-style-keys'</span>
<span class="linecomment">;; Default Value: t</span>
<span class="linecomment">;; `anything-c-pdfgrep-default-read-command'</span>
<span class="linecomment">;; Default Value: "xpdf '%f' %p"</span>
<span class="linecomment">;; `anything-c-etags-tag-file-name'</span>
<span class="linecomment">;; Default Value: "TAGS"</span>
<span class="linecomment">;; `anything-c-etags-tag-file-search-limit'</span>
<span class="linecomment">;; Default Value: 10</span>
<span class="linecomment">;; `anything-c-filelist-file-name'</span>
<span class="linecomment">;; Default Value: nil</span>
<span class="linecomment">;; `anything-c-eldoc-in-minibuffer-show-fn'</span>
<span class="linecomment">;; Default Value: anything-c-eldoc-show-in-mode-line</span>
<span class="linecomment">;; `anything-c-default-external-file-browser'</span>
<span class="linecomment">;; Default Value: "nautilus"</span>
<span class="linecomment">;; `anything-c-use-adaptative-sorting'</span>
<span class="linecomment">;; Default Value: nil</span>

<span class="linecomment">;;  * Anything sources defined here:</span>
<span class="linecomment">;; [EVAL] (autodoc-document-lisp-buffer :type 'anything-source :prefix "anything-" :any-sname t)</span>
<span class="linecomment">;; `anything-c-source-regexp'					(Regexp Builder)</span>
<span class="linecomment">;; `anything-c-source-buffers'					(Buffers)</span>
<span class="linecomment">;; `anything-c-source-buffer-not-found'				(Create buffer)</span>
<span class="linecomment">;; `anything-c-source-buffers+'					(Buffers)</span>
<span class="linecomment">;; `anything-c-source-file-name-history'			(File Name History)</span>
<span class="linecomment">;; `anything-c-source-files-in-current-dir'			(Files from Current Directory)</span>
<span class="linecomment">;; `anything-c-source-files-in-current-dir+'			(Files from Current Directory)</span>
<span class="linecomment">;; `anything-c-source-find-files'				(Find Files (`C-.':Go to precedent level))</span>
<span class="linecomment">;; `anything-c-source-write-file'				(Write File (`C-.':Go to precedent level))</span>
<span class="linecomment">;; `anything-c-source-insert-file'				(Insert File (`C-.':Go to precedent level))</span>
<span class="linecomment">;; `anything-c-source-copy-files'				(Copy Files (`C-.':Go to precedent level))</span>
<span class="linecomment">;; `anything-c-source-symlink-files'				(Symlink Files (`C-.':Go to precedent level))</span>
<span class="linecomment">;; `anything-c-source-hardlink-files'				(Hardlink Files (`C-.':Go to precedent level))</span>
<span class="linecomment">;; `anything-c-source-file-cache-initialized'			()</span>
<span class="linecomment">;; `anything-c-source-file-cache'				(File Cache)</span>
<span class="linecomment">;; `anything-c-source-locate'					(Locate)</span>
<span class="linecomment">;; `anything-c-source-etags-select'				(Etags)</span>
<span class="linecomment">;; `anything-c-source-recentf'					(Recentf)</span>
<span class="linecomment">;; `anything-c-source-ffap-guesser'				(File at point)</span>
<span class="linecomment">;; `anything-c-source-ffap-line'				(File/Lineno at point)</span>
<span class="linecomment">;; `anything-c-source-files-in-all-dired'			(Files in all dired buffer.)</span>
<span class="linecomment">;; `anything-c-source-filelist'					(FileList)</span>
<span class="linecomment">;; `anything-c-source-info-pages'				(Info Pages)</span>
<span class="linecomment">;; `anything-c-source-info-elisp'				(Info index: elisp)</span>
<span class="linecomment">;; `anything-c-source-info-cl'					(Info index: cl)</span>
<span class="linecomment">;; `anything-c-source-info-org'					(Info index: org)</span>
<span class="linecomment">;; `anything-c-source-info-ratpoison'				(Info index: ratpoison)</span>
<span class="linecomment">;; `anything-c-source-info-zsh'					(Info index: zsh)</span>
<span class="linecomment">;; `anything-c-source-info-bash'				(Info index: bash)</span>
<span class="linecomment">;; `anything-c-source-info-coreutils'				(Info index: coreutils)</span>
<span class="linecomment">;; `anything-c-source-info-fileutils'				(Info index: fileutils)</span>
<span class="linecomment">;; `anything-c-source-info-find'				(Info index: find)</span>
<span class="linecomment">;; `anything-c-source-info-sh-utils'				(Info index: sh-utils)</span>
<span class="linecomment">;; `anything-c-source-info-textutils'				(Info index: textutils)</span>
<span class="linecomment">;; `anything-c-source-info-libc'				(Info index: libc)</span>
<span class="linecomment">;; `anything-c-source-info-make'				(Info index: make)</span>
<span class="linecomment">;; `anything-c-source-info-automake'				(Info index: automake)</span>
<span class="linecomment">;; `anything-c-source-info-autoconf'				(Info index: autoconf)</span>
<span class="linecomment">;; `anything-c-source-info-emacs-lisp-intro'			(Info index: emacs-lisp-intro)</span>
<span class="linecomment">;; `anything-c-source-info-emacs'				(Info index: emacs)</span>
<span class="linecomment">;; `anything-c-source-info-elib'				(Info index: elib)</span>
<span class="linecomment">;; `anything-c-source-info-eieio'				(Info index: eieio)</span>
<span class="linecomment">;; `anything-c-source-info-gauche-refe'				(Info index: gauche)</span>
<span class="linecomment">;; `anything-c-source-info-guile'				(Info index: guile)</span>
<span class="linecomment">;; `anything-c-source-info-guile-tut'				(Info index: guile-tut)</span>
<span class="linecomment">;; `anything-c-source-info-goops'				(Info index: goops)</span>
<span class="linecomment">;; `anything-c-source-info-screen'				(Info index: screen)</span>
<span class="linecomment">;; `anything-c-source-info-latex'				(Info index: latex)</span>
<span class="linecomment">;; `anything-c-source-info-gawk'				(Info index: gawk)</span>
<span class="linecomment">;; `anything-c-source-info-sed'					(Info index: sed)</span>
<span class="linecomment">;; `anything-c-source-info-m4'					(Info index: m4)</span>
<span class="linecomment">;; `anything-c-source-info-wget'				(Info index: wget)</span>
<span class="linecomment">;; `anything-c-source-info-binutils'				(Info index: binutils)</span>
<span class="linecomment">;; `anything-c-source-info-as'					(Info index: as)</span>
<span class="linecomment">;; `anything-c-source-info-bfd'					(Info index: bfd)</span>
<span class="linecomment">;; `anything-c-source-info-gprof'				(Info index: gprof)</span>
<span class="linecomment">;; `anything-c-source-info-ld'					(Info index: ld)</span>
<span class="linecomment">;; `anything-c-source-info-diff'				(Info index: diff)</span>
<span class="linecomment">;; `anything-c-source-info-flex'				(Info index: flex)</span>
<span class="linecomment">;; `anything-c-source-info-grep'				(Info index: grep)</span>
<span class="linecomment">;; `anything-c-source-info-gzip'				(Info index: gzip)</span>
<span class="linecomment">;; `anything-c-source-info-libtool'				(Info index: libtool)</span>
<span class="linecomment">;; `anything-c-source-info-texinfo'				(Info index: texinfo)</span>
<span class="linecomment">;; `anything-c-source-info-info'				(Info index: info)</span>
<span class="linecomment">;; `anything-c-source-info-gdb'					(Info index: gdb)</span>
<span class="linecomment">;; `anything-c-source-info-stabs'				(Info index: stabs)</span>
<span class="linecomment">;; `anything-c-source-info-cvsbook'				(Info index: cvsbook)</span>
<span class="linecomment">;; `anything-c-source-info-cvs'					(Info index: cvs)</span>
<span class="linecomment">;; `anything-c-source-info-bison'				(Info index: bison)</span>
<span class="linecomment">;; `anything-c-source-info-id-utils'				(Info index: id-utils)</span>
<span class="linecomment">;; `anything-c-source-info-global'				(Info index: global)</span>
<span class="linecomment">;; `anything-c-source-man-pages'				(Manual Pages)</span>
<span class="linecomment">;; `anything-c-source-complex-command-history'			(Complex Command History)</span>
<span class="linecomment">;; `anything-c-source-extended-command-history'			(Emacs Commands History)</span>
<span class="linecomment">;; `anything-c-source-emacs-commands'				(Emacs Commands)</span>
<span class="linecomment">;; `anything-c-source-lacarte'					(Lacarte)</span>
<span class="linecomment">;; `anything-c-source-emacs-functions'				(Emacs Functions)</span>
<span class="linecomment">;; `anything-c-source-emacs-functions-with-abbrevs'		(Emacs Functions)</span>
<span class="linecomment">;; `anything-c-source-advice'					(Function Advice)</span>
<span class="linecomment">;; `anything-c-source-emacs-variables'				(Emacs Variables)</span>
<span class="linecomment">;; `anything-c-source-bookmarks'				(Bookmarks)</span>
<span class="linecomment">;; `anything-c-source-bookmark-set'				(Set Bookmark)</span>
<span class="linecomment">;; `anything-c-source-bm'					(Visible Bookmarks)</span>
<span class="linecomment">;; `anything-c-source-bookmarks-ssh'				(Bookmarks-ssh)</span>
<span class="linecomment">;; `anything-c-source-bookmarks-su'				(Bookmarks-root)</span>
<span class="linecomment">;; `anything-c-source-bookmarks-local'				(Bookmarks-Local)</span>
<span class="linecomment">;; `anything-c-source-bmkext-addressbook'			(Bookmark Addressbook)</span>
<span class="linecomment">;; `anything-c-source-bookmark-w3m'				(Bookmark W3m)</span>
<span class="linecomment">;; `anything-c-source-bookmark-images'				(Bookmark Images)</span>
<span class="linecomment">;; `anything-c-source-bookmark-man'				(Bookmark Woman&Man)</span>
<span class="linecomment">;; `anything-c-source-bookmark-gnus'				(Bookmark Gnus)</span>
<span class="linecomment">;; `anything-c-source-bookmark-info'				(Bookmark Info)</span>
<span class="linecomment">;; `anything-c-source-bookmark-files&dirs'			(Bookmark Files&Directories)</span>
<span class="linecomment">;; `anything-c-source-bookmark-su-files&dirs'			(Bookmark Root-Files&Directories)</span>
<span class="linecomment">;; `anything-c-source-bookmark-ssh-files&dirs'			(Bookmark Ssh-Files&Directories)</span>
<span class="linecomment">;; `anything-c-source-firefox-bookmarks'			(Firefox Bookmarks)</span>
<span class="linecomment">;; `anything-c-source-w3m-bookmarks'				(W3m Bookmarks)</span>
<span class="linecomment">;; `anything-c-source-elisp-library-scan'			(Elisp libraries (Scan))</span>
<span class="linecomment">;; `anything-c-source-imenu'					(Imenu)</span>
<span class="linecomment">;; `anything-c-source-ctags'					(Exuberant ctags)</span>
<span class="linecomment">;; `anything-c-source-semantic'					(Semantic Tags)</span>
<span class="linecomment">;; `anything-c-source-simple-call-tree-functions-callers'	(Function is called by)</span>
<span class="linecomment">;; `anything-c-source-simple-call-tree-callers-functions'	(Function calls)</span>
<span class="linecomment">;; `anything-c-source-commands-and-options-in-file'		(Commands/Options in file)</span>
<span class="linecomment">;; `anything-c-source-customize-face'				(Customize Face)</span>
<span class="linecomment">;; `anything-c-source-colors'					(Colors)</span>
<span class="linecomment">;; `anything-c-source-tracker-search'				(Tracker Search)</span>
<span class="linecomment">;; `anything-c-source-mac-spotlight'				(mdfind)</span>
<span class="linecomment">;; `anything-c-source-kill-ring'				(Kill Ring)</span>
<span class="linecomment">;; `anything-c-source-mark-ring'				(mark-ring)</span>
<span class="linecomment">;; `anything-c-source-global-mark-ring'				(global-mark-ring)</span>
<span class="linecomment">;; `anything-c-source-register'					(Registers)</span>
<span class="linecomment">;; `anything-c-source-latex-math'				(Latex Math Menu)</span>
<span class="linecomment">;; `anything-c-source-fixme'					(TODO/FIXME/DRY comments)</span>
<span class="linecomment">;; `anything-c-source-rd-headline'				(RD HeadLine)</span>
<span class="linecomment">;; `anything-c-source-oddmuse-headline'				(Oddmuse HeadLine)</span>
<span class="linecomment">;; `anything-c-source-emacs-source-defun'			(Emacs Source DEFUN)</span>
<span class="linecomment">;; `anything-c-source-emacs-lisp-expectations'			(Emacs Lisp Expectations)</span>
<span class="linecomment">;; `anything-c-source-emacs-lisp-toplevels'			(Emacs Lisp Toplevel / Level 4 Comment / Linkd Star)</span>
<span class="linecomment">;; `anything-c-source-org-headline'				(Org HeadLine)</span>
<span class="linecomment">;; `anything-c-source-yaoddmuse-emacswiki-edit-or-view'		(Yaoddmuse Edit or View (EmacsWiki))</span>
<span class="linecomment">;; `anything-c-source-yaoddmuse-emacswiki-post-library'		(Yaoddmuse Post library (EmacsWiki))</span>
<span class="linecomment">;; `anything-c-source-eev-anchor'				(Anchors)</span>
<span class="linecomment">;; `anything-c-source-org-keywords'				(Org Keywords)</span>
<span class="linecomment">;; `anything-c-source-picklist'					(Picklist)</span>
<span class="linecomment">;; `anything-c-source-bbdb'					(BBDB)</span>
<span class="linecomment">;; `anything-c-source-evaluation-result'			(Evaluation Result)</span>
<span class="linecomment">;; `anything-c-source-calculation-result'			(Calculation Result)</span>
<span class="linecomment">;; `anything-c-source-google-suggest'				(Google Suggest)</span>
<span class="linecomment">;; `anything-c-source-yahoo-suggest'				(Yahoo Suggest)</span>
<span class="linecomment">;; `anything-c-source-emms-streams'				(Emms Streams)</span>
<span class="linecomment">;; `anything-c-source-emms-dired'				(Music Directory)</span>
<span class="linecomment">;; `anything-c-source-emms-files'				(Emms files)</span>
<span class="linecomment">;; `anything-c-source-jabber-contacts'				(Jabber Contacts)</span>
<span class="linecomment">;; `anything-c-source-call-source'				(Call anything source)</span>
<span class="linecomment">;; `anything-c-source-anything-commands'			(Preconfigured Anything)</span>
<span class="linecomment">;; `anything-c-source-occur'					(Occur)</span>
<span class="linecomment">;; `anything-c-source-browse-code'				(Browse code)</span>
<span class="linecomment">;; `anything-c-source-create'					(Create)</span>
<span class="linecomment">;; `anything-c-source-minibuffer-history'			(Minibuffer History)</span>
<span class="linecomment">;; `anything-c-source-elscreen'					(Elscreen)</span>
<span class="linecomment">;; `anything-c-source-top'					(Top (Press C-c C-u to refresh))</span>
<span class="linecomment">;; `anything-c-source-absolute-time-timers'			(Absolute Time Timers)</span>
<span class="linecomment">;; `anything-c-source-idle-time-timers'				(Idle Time Timers)</span>
<span class="linecomment">;; `anything-c-source-xrandr-change-resolution'			(Change Resolution)</span>
<span class="linecomment">;; `anything-c-source-xfonts'					(X Fonts)</span>
<span class="linecomment">;; `anything-c-source-time-world'				(Time World List)</span>
<span class="linecomment">;; `anything-c-source-apt'					(APT)</span>
<span class="linecomment">;; `anything-c-source-gentoo'					(Portage sources)</span>
<span class="linecomment">;; `anything-c-source-use-flags'				(Use Flags)</span>
<span class="linecomment">;; `anything-c-source-emacs-process'				(Emacs Process)</span>
<span class="linecomment">;; `anything-c-source-ratpoison-commands'			(Ratpoison Commands)</span>

<span class="linecomment">;;  *** END auto-documentation</span>


<span class="linecomment">;;; Change log:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Change log of this file is found at</span>
<span class="linecomment">;;  http://repo.or.cz/w/anything-config.git/history/master:/anything-config.el</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Change log of this project is found at</span>
<span class="linecomment">;;  http://repo.or.cz/w/anything-config.git?a=shortlog</span>

<span class="linecomment">;;; Contributors:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;     Tamas Patrovics</span>
<span class="linecomment">;;     Tassilo Horn &lt;tassilo@member.fsf.org&gt;</span>
<span class="linecomment">;;     Vagn Johansen &lt;gonz808@hotmail.com&gt;</span>
<span class="linecomment">;;     Mathias Dahl &lt;mathias.dahl@gmail.com&gt;</span>
<span class="linecomment">;;     Bill Clementson &lt;billclem@gmail.com&gt;</span>
<span class="linecomment">;;     Stefan Kamphausen (see http://www.skamphausen.de for more informations)</span>
<span class="linecomment">;;     Drew Adams &lt;drew.adams@oracle.com&gt;</span>
<span class="linecomment">;;     Jason McBrayer &lt;jmcbray@carcosa.net&gt;</span>
<span class="linecomment">;;     Andy Stewart &lt;lazycat.manatee@gmail.com&gt;</span>
<span class="linecomment">;;     Thierry Volpiatto &lt;thierry.volpiatto@gmail.com&gt;</span>
<span class="linecomment">;;     rubikitch &lt;rubikitch@ruby-lang.org&gt;</span>
<span class="linecomment">;;     Scott Vokes &lt;vokes.s@gmail.com&gt;</span>
<span class="linecomment">;;     Kenichirou Oyama &lt;k1lowxb@gmail.com&gt;</span>

<span class="linecomment">;;; For Maintainers:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;; Evaluate (autodoc-update-all) before commit. This function</span>
<span class="linecomment">;; generates anything-c-source-* / functions / options list.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;; Install also developer-tools/autodoc.el</span>
<span class="linecomment">;; And eval it or run interactively.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;; [EVAL IT] (autodoc-update-all)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;; Please write details documentation about function, then others will</span>
<span class="linecomment">;; read code more easier.   -- Andy Stewart</span>
<span class="linecomment">;;</span>


<span class="linecomment">;;; TODO</span>
<span class="linecomment">;;</span>
<span class="linecomment">;; - Fix documentation, now many functions haven't documentations.</span>
<span class="linecomment">;;</span>

<span class="linecomment">;;; Require</span>
(require 'anything)
(require 'thingatpt)
(require 'ffap)
(require 'cl)
(require 'dired-aux)
(require 'tramp)
(require 'grep)

<span class="linecomment">;;; Code:</span>

<span class="linecomment">;; version check</span>
(let ((version "<span class="quote">1.263</span>"))
  (when (and (string= "<span class="quote">1.</span>" (substring version 0 2))
             (string-match "<span class="quote">1\.\\([0-9]+\\)</span>" anything-version)
             (&lt; (string-to-number (match-string 1 anything-version))
                (string-to-number (substring version 2))))
    (error "<span class="quote">Please update anything.el!!

http://www.emacswiki.org/cgi-bin/wiki/download/anything.el

or  M-x install-elisp-from-emacswiki anything.el</span>")))

<span class="linecomment">;; compatibility</span>
(unless (fboundp 'window-system)
  (defun window-system (&optional arg)
    window-system))

<span class="linecomment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Customize ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
(defgroup anything-config nil
  "<span class="quote">Predefined configurations for `anything.el'.</span>"
  :group 'anything)

(defcustom anything-c-use-standard-keys nil
  "<span class="quote">Whether use standard keybindings. (no effect)

Key definitions in anything-config.el are removed because
anything.el uses Emacs-standard keys by default. e.g. M-p/M-n for
minibuffer history, C-s for isearch, etc.

If you use `iswitchb' with `anything',
evaluate (anything-iswitchb-setup) .  Then some bindings that
conflict with `iswitchb', e.g. C-p/C-n for the minibuffer
history, are removed from `anything-map'. </span>"
  :type 'boolean
  :group 'anything-config)

(defcustom anything-c-adaptive-history-file "<span class="quote">~/.emacs.d/anything-c-adaptive-history</span>"
  "<span class="quote">Path of file where history information is stored.</span>"
  :type 'string
  :group 'anything-config)

(defcustom anything-c-adaptive-history-length 50
  "<span class="quote">Maximum number of candidates stored for a source.</span>"
  :type 'number
  :group 'anything-config)

(defcustom anything-c-google-suggest-url
  "<span class="quote">http://google.com/complete/search?output=toolbar&q=</span>"
  "<span class="quote">URL used for looking up Google suggestions.</span>"
  :type 'string
  :group 'anything-config)

(defcustom anything-c-google-suggest-search-url
  "<span class="quote">http://www.google.com/search?ie=utf-8&oe=utf-8&q=</span>"
  "<span class="quote">URL used for Google searching.</span>"
  :type 'string
  :group 'anything-config)

(defcustom anything-google-suggest-use-curl-p nil
  "<span class="quote">*When non--nil use CURL to get info from `anything-c-google-suggest-url'.
Otherwise `url-retrieve-synchronously' is used.</span>"
  :type 'boolean
  :group 'anything-config)

(defcustom anything-c-yahoo-suggest-url
  "<span class="quote">http://search.yahooapis.com/WebSearchService/V1/relatedSuggestion?appid=Generic&query=</span>"
  "<span class="quote">Url used for looking up Yahoo suggestions.</span>"
  :type 'string
  :group 'anything-config)

(defcustom anything-c-yahoo-suggest-search-url
  "<span class="quote">http://search.yahoo.com/search?&ei=UTF-8&fr&h=c&p=</span>"
  "<span class="quote">Url used for Yahoo searching.</span>"
  :type 'string
  :group 'anything-config)

(defcustom anything-c-boring-buffer-regexp
  (rx (or
       (group bos  "<span class="quote"> </span>")
       <span class="linecomment">;; anything-buffer</span>
       "<span class="quote">*anything</span>"
       <span class="linecomment">;; echo area</span>
       "<span class="quote"> *Echo Area</span>" "<span class="quote"> *Minibuf</span>"))
  "<span class="quote">The regexp that match boring buffers.
Buffer candidates matching this regular expression will be
filtered from the list of candidates if the
`anything-c-skip-boring-buffers' candidate transformer is used, or
they will be displayed with face `file-name-shadow' if
`anything-c-shadow-boring-buffers' is used.</span>"
  :type 'string
  :group 'anything-config)
<span class="linecomment">;; (string-match anything-c-boring-buffer-regexp "buf")</span>
<span class="linecomment">;; (string-match anything-c-boring-buffer-regexp " hidden")</span>
<span class="linecomment">;; (string-match anything-c-boring-buffer-regexp " *Minibuf-1*")</span>

(defcustom anything-c-boring-file-regexp
  (rx (or
       <span class="linecomment">;; Boring directories</span>
       (and "<span class="quote">/</span>" (or "<span class="quote">.svn</span>" "<span class="quote">CVS</span>" "<span class="quote">_darcs</span>" "<span class="quote">.git</span>" "<span class="quote">.hg</span>") (or "<span class="quote">/</span>" eol))
       <span class="linecomment">;; Boring files</span>
       (and line-start  "<span class="quote">.#</span>")
       (and (or "<span class="quote">.class</span>" "<span class="quote">.la</span>" "<span class="quote">.o</span>" "<span class="quote">~</span>") eol)))
  "<span class="quote">The regexp that match boring files.
File candidates matching this regular expression will be
filtered from the list of candidates if the
`anything-c-skip-boring-files' candidate transformer is used, or
they will be displayed with face `file-name-shadow' if
`anything-c-shadow-boring-files' is used.</span>"
  :type 'string
  :group 'anything-config)

(defcustom anything-kill-ring-threshold 10
  "<span class="quote">*Minimum length to be listed by `anything-c-source-kill-ring'.</span>"
  :type 'integer
  :group 'anything-config)

(defcustom anything-su-or-sudo "<span class="quote">su</span>"
  "<span class="quote">What command to use for root access.</span>"
  :type 'string
  :group 'anything-config)

(defcustom anything-for-files-prefered-list
  '(anything-c-source-ffap-line
    anything-c-source-ffap-guesser
    anything-c-source-buffers+
    anything-c-source-recentf
    anything-c-source-bookmarks
    anything-c-source-file-cache
    anything-c-source-files-in-current-dir+
    anything-c-source-locate)
  "<span class="quote">Your prefered sources to find files.</span>"
  :type 'list
  :group 'anything-config)

(defcustom anything-create--actions-private nil
  "<span class="quote">User defined actions for `anything-create' / `anything-c-source-create'.
It is a list of (DISPLAY . FUNCTION) pairs like `action'
attribute of `anything-sources'.

It is prepended to predefined pairs.</span>"
  :type 'list
  :group 'anything-config)

(defcustom anything-allow-skipping-current-buffer t
  "<span class="quote">Show current buffer or not in anything buffer</span>"
  :type 'boolean
  :group 'anything-config)

(defcustom anything-c-enable-eval-defun-hack t
  "<span class="quote">*If non-nil, execute `anything' using the source at point when C-M-x is pressed.
This hack is invoked when pressing C-M-x in the form \
 (defvar anything-c-source-XXX ...) or (setq anything-c-source-XXX ...).</span>"
  :type 'boolean
  :group 'anything-config)

(defcustom anything-tramp-verbose 0
  "<span class="quote">*Just like `tramp-verbose' but specific to anything.
When set to 0 don't show tramp messages in anything.
If you want to have the default tramp messages set it to 3.</span>"
  :type 'integer
  :group 'anything-config)

(defcustom anything-raise-command nil
  "<span class="quote">*A shell command to jump to a window running specific program.
Need external program wmctrl.
This will be use with `format', so use something like \"wmctrl -xa %s\".</span>"
  :type 'string
  :group 'anything-config)

(defun anything-set-anything-command-map-prefix-key (var key)
  (when (boundp 'anything-command-map-prefix-key)
    (global-unset-key (read-kbd-macro anything-command-map-prefix-key)))
  (setq anything-command-map-prefix-key key)
  (global-set-key (read-kbd-macro anything-command-map-prefix-key)
                  'anything-command-map))

(defcustom anything-command-map-prefix-key "<span class="quote">&lt;f5&gt; a</span>"
  "<span class="quote">*The prefix key for all `anything-command-map' commands.

!!WARNING!!
This default value is very likely to be changed,
because it is under discussion.</span>"
  :type 'string
  :set 'anything-set-anything-command-map-prefix-key
  :group 'anything-config)

(defcustom anything-c-find-files-show-icons nil
  "<span class="quote">*Whether show or hide icons in `anything-find-files'.</span>"
  :type 'boolean
  :group 'anything-config)

(defcustom anything-c-find-files-icons-directory
  (and (window-system)
       (dolist (i image-load-path)
         (if (file-directory-p (expand-file-name "<span class="quote">tree-widget/default</span>" (eval i)))
             (return (expand-file-name "<span class="quote">tree-widget/default</span>" (eval i))))))
  "<span class="quote">*Default path where to find files and directory icons.</span>"
  :type 'string
  :group 'anything-config)

(defcustom anything-c-browse-code-regexp-lisp
  "<span class="quote">^ *\(def\\(un\\|subst\\|macro\\|face\\|alias\\|advice\\|struct\\|\
type\\|theme\\|var\\|group\\|custom\\|const\\|method\\|class\\)</span>"
  "<span class="quote">*Regexp used to parse lisp buffer when browsing code.</span>"
  :type 'string
  :group 'anything-config)

(defcustom anything-c-browse-code-regexp-python
  "<span class="quote">\\&lt;def\\&gt;\\|\\&lt;class\\&gt;</span>"
  "<span class="quote">*Regexp used to parse python buffer when browsing code.</span>"
  :type 'string
  :group 'anything-config)

(defcustom anything-c-browse-code-regexp-alist
  `((lisp-interaction-mode . ,anything-c-browse-code-regexp-lisp)
    (emacs-lisp-mode . ,anything-c-browse-code-regexp-lisp)
    (lisp-mode . ,anything-c-browse-code-regexp-lisp)
    (python-mode . ,anything-c-browse-code-regexp-python))
  "<span class="quote">*Alist to store regexps for browsing code corresponding \
to a specific `major-mode'.</span>"
  :type 'list
  :group 'anything-config)

(defcustom anything-c-external-programs-associations nil
  "<span class="quote">*Alist to store externals programs associated with file extension.
This variable overhide setting in .mailcap file.
e.g : '\(\(\"jpg\" . \"gqview\"\) (\"pdf\" . \"xpdf\"\)\) </span>"
  :type 'list
  :group 'anything-config)

<span class="linecomment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Prefix argument in action ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="linecomment">;; TODO: This should be integrated in anything.el instead of having</span>
<span class="linecomment">;; a defadvice here.</span>

(defvar anything-current-prefix-arg nil
  "<span class="quote">Record `current-prefix-arg' when exiting minibuffer.
It will be cleared at start of next `anything' call when \
`anything-before-initialize-hook' is called.</span>")

(defadvice anything-exit-minibuffer (before anything-current-prefix-arg activate)
  (unless anything-current-prefix-arg
    (setq anything-current-prefix-arg current-prefix-arg)))

<span class="linecomment">;; using this hook instead of `anything-after-action-hook'</span>
<span class="linecomment">;; allow to record the prefix args and keep their values</span>
<span class="linecomment">;; when using `anything-comp-read'.</span>
<span class="linecomment">;; i.e when quitting `anything-comp-read' prefix args are preserved</span>
<span class="linecomment">;; for the following action.</span>
(add-hook 'anything-before-initialize-hook
          (lambda () (setq anything-current-prefix-arg nil)))

<span class="linecomment">;;;###autoload</span>
(defun anything-configuration ()
  "<span class="quote">Customize `anything'.</span>"
  (interactive)
  (customize-group "<span class="quote">anything-config</span>"))

<span class="linecomment">;;; Anything-command-map</span>
<span class="linecomment">;;;###autoload</span>
(defvar anything-command-map)
(define-prefix-command 'anything-command-map)

<span class="linecomment">;; rubikitch: Please change it freely because it is in discussion. I'll track from git.</span>
(define-key anything-command-map (kbd "<span class="quote">&lt;SPC&gt;</span>") 'anything-execute-anything-command)
(define-key anything-command-map (kbd "<span class="quote">e</span>") 'anything-c-etags-select)
(define-key anything-command-map (kbd "<span class="quote">l</span>") 'anything-locate)
(define-key anything-command-map (kbd "<span class="quote">s</span>") 'anything-surfraw)
(define-key anything-command-map (kbd "<span class="quote">r</span>") 'anything-regexp)
(define-key anything-command-map (kbd "<span class="quote">w</span>") 'anything-w3m-bookmarks)
(define-key anything-command-map (kbd "<span class="quote">x</span>") 'anything-firefox-bookmarks)
(define-key anything-command-map (kbd "<span class="quote">#</span>") 'anything-emms)
(define-key anything-command-map (kbd "<span class="quote">m</span>") 'anything-man-woman)
(define-key anything-command-map (kbd "<span class="quote">t</span>") 'anything-top)
(define-key anything-command-map (kbd "<span class="quote">i</span>") 'anything-imenu)
(define-key anything-command-map (kbd "<span class="quote">p</span>") 'anything-list-emacs-process)
(define-key anything-command-map (kbd "<span class="quote">C-x r b</span>") 'anything-c-pp-bookmarks)
(define-key anything-command-map (kbd "<span class="quote">M-y</span>") 'anything-show-kill-ring)
(define-key anything-command-map (kbd "<span class="quote">C-c &lt;SPC&gt;</span>") 'anything-all-mark-rings)
(define-key anything-command-map (kbd "<span class="quote">C-x C-f</span>") 'anything-find-files)
(define-key anything-command-map (kbd "<span class="quote">f</span>") 'anything-for-files)
(define-key anything-command-map (kbd "<span class="quote">C-:</span>") 'anything-eval-expression-with-eldoc)
(define-key anything-command-map (kbd "<span class="quote">C-,</span>") 'anything-calcul-expression)
(define-key anything-command-map (kbd "<span class="quote">M-x</span>") 'anything-M-x)
(define-key anything-command-map (kbd "<span class="quote">C-x C-w</span>") 'anything-write-file)
(define-key anything-command-map (kbd "<span class="quote">C-x i</span>") 'anything-insert-file)
(define-key anything-command-map (kbd "<span class="quote">M-s o</span>") 'anything-occur)
(define-key anything-command-map (kbd "<span class="quote">M-g s</span>") 'anything-do-grep)
(define-key anything-command-map (kbd "<span class="quote">c</span>") 'anything-colors)
(define-key anything-command-map (kbd "<span class="quote">F</span>") 'anything-select-xfont)
(define-key anything-command-map (kbd "<span class="quote">C-c f</span>") 'anything-recentf)
(define-key anything-command-map (kbd "<span class="quote">C-c g</span>") 'anything-google-suggest)
(define-key anything-command-map (kbd "<span class="quote">h i</span>") 'anything-info-at-point)
(define-key anything-command-map (kbd "<span class="quote">h r</span>") 'anything-info-emacs)
(define-key anything-command-map (kbd "<span class="quote">C-x C-b</span>") 'anything-buffers+)
(define-key anything-command-map (kbd "<span class="quote">C-c C-b</span>") 'anything-browse-code)
(define-key anything-command-map (kbd "<span class="quote">C-x r i</span>") 'anything-register)
(define-key anything-command-map (kbd "<span class="quote">C-c C-x</span>") 'anything-c-run-external-command)

<span class="linecomment">;; In Emacs 23.1.50, minibuffer-local-must-match-filename-map was renamed to</span>
<span class="linecomment">;; minibuffer-local-filename-must-match-map.</span>
(defvar minibuffer-local-filename-must-match-map (make-sparse-keymap)) <span class="linecomment">;; Emacs 23.1.+</span>
(defvar minibuffer-local-must-match-filename-map (make-sparse-keymap)) <span class="linecomment">;; Older Emacsen</span>
(dolist (map (list minibuffer-local-filename-completion-map
                   minibuffer-local-completion-map
                   minibuffer-local-must-match-filename-map
                   minibuffer-local-filename-must-match-map
                   minibuffer-local-map
                   minibuffer-local-isearch-map
                   minibuffer-local-must-match-map
                   minibuffer-local-ns-map))
  (define-key map "<span class="quote">\C-r</span>" 'anything-minibuffer-history))

<span class="linecomment">;;; Menu</span>
(easy-menu-define nil global-map
  "<span class="quote">`anything' menu</span>"
  '("<span class="quote">Anything</span>"
    ["<span class="quote">All anything commands</span>" anything-execute-anything-command t]
    ["<span class="quote">Find any Files/Buffers</span>" anything-for-files t]
    "<span class="quote">----</span>"
    ("<span class="quote">Files:</span>"
     ["<span class="quote">Find files</span>" anything-find-files t]
     ["<span class="quote">Recent Files</span>" anything-recentf t]
     ["<span class="quote">Locate</span>" anything-locate t]
     ["<span class="quote">Bookmarks</span>" anything-c-pp-bookmarks t])
    ("<span class="quote">Buffers:</span>"
     ["<span class="quote">Find buffers</span>" anything-buffers+ t])
    ("<span class="quote">Commands:</span>"
     ["<span class="quote">Emacs Commands</span>" anything-M-x t]
     ["<span class="quote">Externals Commands</span>" anything-c-run-external-command t])
    ("<span class="quote">Info:</span>"
     ["<span class="quote">Info at point</span>" anything-info-at-point t]
     ["<span class="quote">Emacs Manual index</span>" anything-info-emacs t])
    ("<span class="quote">Org:</span>"
     ["<span class="quote">Org keywords</span>" anything-org-keywords t]
     ["<span class="quote">Org headlines</span>" anything-org-headlines t])
    ("<span class="quote">Tools:</span>"
     ["<span class="quote">Occur</span>" anything-occur t]
     ["<span class="quote">Grep</span>" anything-do-grep t]
     ["<span class="quote">Etags</span>" anything-c-etags-select t]
     ["<span class="quote">Browse Kill ring</span>" anything-show-kill-ring t]
     ["<span class="quote">Browse register</span>" anything-register t]
     ["<span class="quote">Browse code</span>" anything-browse-code t]
     ["<span class="quote">Mark Ring</span>" anything-all-mark-rings t]
     ["<span class="quote">Regexp handler</span>" anything-regexp t]
     ["<span class="quote">Colors & Faces</span>" anything-colors t]
     ["<span class="quote">Show xfonts</span>" anything-select-xfont t]
     ["<span class="quote">Imenu</span>" anything-imenu t]
     ["<span class="quote">Google Suggest</span>" anything-google-suggest t]
     ["<span class="quote">Eval expression</span>" anything-eval-expression-with-eldoc t]
     ["<span class="quote">Calcul expression</span>" anything-calcul-expression t]
     ["<span class="quote">Man pages</span>" anything-man-woman t]
     ["<span class="quote">Top externals process</span>" anything-top t]
     ["<span class="quote">Emacs internals process</span>" anything-list-emacs-process t])
    "<span class="quote">----</span>"
    ["<span class="quote">Prefered Options</span>" anything-configuration t]))


<span class="linecomment">;;; Documentation</span>
<span class="linecomment">;; It is replaced by `anything-help'</span>
(defun anything-c-describe-anything-bindings ()
  "<span class="quote">[OBSOLETE] Describe `anything' bindings.</span>"
  (interactive)
  (anything-run-after-quit
   #'(lambda ()
       (with-current-buffer (get-buffer-create "<span class="quote">*Anything Help*</span>")
         (erase-buffer)
         (insert
          (substitute-command-keys
           "<span class="quote">The keys that are defined for `anything' are:
       \\{anything-map}</span>")))
       (pop-to-buffer "<span class="quote">*Anything Help*</span>")
       (goto-char (point-min)))))

<span class="linecomment">;; Use `describe-mode' key in `global-map'</span>
<span class="linecomment">;; (dolist (k (where-is-internal 'describe-mode global-map))</span>
<span class="linecomment">;;   (define-key anything-map k 'anything-c-describe-anything-bindings))</span>

<span class="linecomment">;;; Help message</span>
(defun anything-c-list-preconfigured-anything ()
  (loop with doc
        with sym
        for entry in (cdr (assoc
                           (file-truename (locate-library "<span class="quote">anything-config</span>"))
                           load-history))
        if (and (consp entry)
                (eq (car entry) 'defun)
                (string-match "<span class="quote">^Preconfigured.+$</span>"
                              (setq doc (or (documentation (setq sym (cdr entry)))
                                            "<span class="quote"></span>"))))
        collect (cons sym (match-string 0 doc))))

(defun anything-c-format-preconfigured-anything ()
  (mapcar (lambda (x) (format "<span class="quote">\\[%s] : %s\n</span>" (car x) (cdr x)))
          (anything-c-list-preconfigured-anything)))

(setq anything-help-message
      (lambda ()
        (concat
         "<span class="quote">\\&lt;anything-map&gt;</span>"
         "<span class="quote">`anything' is QuickSilver-like candidate-selection framework.

Narrow the list by typing some pattern,
Multiple patterns are allowed by splitting by space.
Select with natural Emacs operations, choose with RET.

If you have any problems, press C-c C-x C-b!!
Feel free to send bug reports. I'll fix them.
The steps are described in the beginning of anything.el file.

== Basic Operations ==
C-p, Up: Previous Line
C-n, Down : Next Line
M-v, PageUp : Previous Page
C-v, PageDown : Next Page
Enter : Execute first (default) action / Select
M-&lt; : First Line
M-&gt; : Last Line
M-PageUp, C-M-S-v, C-M-y : Previous Page (other-window)
M-PageDown, C-M-v : Next Page (other-window)

Tab, C-i : Show action list
Left : Previous Source
Right, C-o : Next Source
C-k : Delete pattern
C-z : Persistent Action (Execute action with anything session kept)
C-c C-x C-b: Send a bug report

== Shortcuts For 2nd/3rd Action ==
\\[anything-select-2nd-action-or-end-of-line] : Execute 2nd Action (if the minibuffer cursor is at end of line)
\\[anything-select-3rd-action] : Execute 3rd Action

== Visible Marks ==
Visible marks store candidate. Some actions uses marked candidates.

\\[anything-toggle-visible-mark] : Toggle Visible Mark
\\[anything-prev-visible-mark] : Previous Mark
\\[anything-next-visible-mark] : Next Mark

== Miscellaneous Commands ==
\\[anything-toggle-resplit-window] : Toggle vertical/horizontal split anything window
\\[anything-quit-and-find-file] : Drop into `find-file'
\\[anything-delete-current-selection] : Delete Selected Item (visually)
\\[anything-kill-selection-and-quit] : Set Item Into the kill-ring And Quit
\\[anything-yank-selection] : Yank Selected Item Into Pattern
\\[anything-follow-mode] : Toggle Automatical Execution Of Persistent Action
\\[anything-force-update] : Recalculate And Redisplay Candidates

== Global Commands ==
\\&lt;global-map&gt;\\[anything-resume] revives last `anything' session.
It is very useful, so you should bind any key.

Single source is executed by \\[anything-call-source].

== Preconfigured `anything' ==
Preconfigured `anything' is commands that uses `anything' interface.
You can use them without configuration.

</span>"
         (apply 'concat (anything-c-format-preconfigured-anything))
         "<span class="quote">
Enjoy!</span>")))

<span class="linecomment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Preconfigured Anything ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="linecomment">;;;###autoload</span>
(defun anything-mini ()
  "<span class="quote">Preconfigured `anything' lightweight version (buffer -&gt; recentf).</span>"
  (interactive)
  (anything-other-buffer '(anything-c-source-buffers+ anything-c-source-recentf)
                         "<span class="quote">*anything mini*</span>"))
<span class="linecomment">;;;###autoload</span>
(defun anything-for-files ()
  "<span class="quote">Preconfigured `anything' for opening files.
ffap -&gt; recentf -&gt; buffer -&gt; bookmark -&gt; file-cache -&gt; files-in-current-dir -&gt; locate</span>"
  (interactive)
  (anything-other-buffer anything-for-files-prefered-list "<span class="quote">*anything for files*</span>"))

<span class="linecomment">;;;###autoload</span>
(defun anything-recentf ()
  "<span class="quote">Preconfigured `anything' for `recentf'.</span>"
  (interactive)
  (anything-other-buffer 'anything-c-source-recentf "<span class="quote">*anything recentf*</span>"))

<span class="linecomment">;;;###autoload</span>
(defun anything-info-at-point (arg)
  "<span class="quote">Preconfigured `anything' for searching info at point.
With a prefix-arg insert symbol at point.</span>"
  (interactive "<span class="quote">P</span>")
  (anything :sources'(anything-c-source-info-elisp
                      anything-c-source-info-cl
                      anything-c-source-info-pages)
            :input (and arg (thing-at-point 'symbol))
            :buffer "<span class="quote">*anything info*</span>"))

<span class="linecomment">;;;###autoload</span>
(defun anything-info-emacs ()
  "<span class="quote">Preconfigured anything for Emacs manual index.</span>"
  (interactive)
  (anything-other-buffer 'anything-c-source-info-emacs "<span class="quote">*info emacs*</span>"))

<span class="linecomment">;;;###autoload</span>
(defun anything-show-kill-ring ()
  "<span class="quote">Preconfigured `anything' for `kill-ring'. It is drop-in replacement of `yank-pop'.
You may bind this command to M-y.</span>"
  (interactive)
  (anything-other-buffer 'anything-c-source-kill-ring "<span class="quote">*anything kill-ring*</span>"))

<span class="linecomment">;;;###autoload</span>
(defun anything-minibuffer-history ()
  "<span class="quote">Preconfigured `anything' for `minibuffer-history'.</span>"
  (interactive)
  (let ((enable-recursive-minibuffers t))
    (anything-other-buffer 'anything-c-source-minibuffer-history
                           "<span class="quote">*anything minibuffer-history*</span>")))

<span class="linecomment">;;;###autoload</span>
(defun anything-gentoo ()
  "<span class="quote">Preconfigured `anything' for gentoo linux.</span>"
  (interactive)
  (anything-other-buffer '(anything-c-source-gentoo
                           anything-c-source-use-flags)
                         "<span class="quote">*anything gentoo*</span>"))

<span class="linecomment">;;;###autoload</span>
(defun anything-imenu ()
  "<span class="quote">Preconfigured `anything' for `imenu'.</span>"
  (interactive)
  (anything 'anything-c-source-imenu nil nil nil nil "<span class="quote">*anything imenu*</span>"))

<span class="linecomment">;;;###autoload</span>
(defun anything-google-suggest ()
  "<span class="quote">Preconfigured `anything' for google search with google suggest.</span>"
  (interactive)
  (anything-other-buffer 'anything-c-source-google-suggest "<span class="quote">*anything google*</span>"))

<span class="linecomment">;;;###autoload</span>
(defun anything-yahoo-suggest ()
  "<span class="quote">Preconfigured `anything' for Yahoo searching with Yahoo suggest.</span>"
  (interactive)
  (anything-other-buffer 'anything-c-source-yahoo-suggest "<span class="quote">*anything yahoo*</span>"))

<span class="linecomment">;;; Converted from anything-show-*-only</span>
<span class="linecomment">;;;###autoload</span>
(defun anything-for-buffers ()
  "<span class="quote">Preconfigured `anything' for buffer.</span>"
  (interactive)
  (anything-other-buffer 'anything-c-source-buffers "<span class="quote">*anything for buffers*</span>"))

<span class="linecomment">;;;###autoload</span>
(defun anything-buffers+ ()
  "<span class="quote">Enhanced preconfigured `anything' for buffer.</span>"
  (interactive)
  (anything :sources 'anything-c-source-buffers+
            :buffer "<span class="quote">*anything buffers*</span>" :keymap anything-c-buffer-map))

<span class="linecomment">;;;###autoload</span>
(defun anything-bbdb ()
  "<span class="quote">Preconfigured `anything' for BBDB.

Needs BBDB.

http://bbdb.sourceforge.net/</span>"
  (interactive)
  (anything-other-buffer 'anything-c-source-bbdb "<span class="quote">*anything bbdb*</span>"))

<span class="linecomment">;;;###autoload</span>
(defun anything-locate (arg)
  "<span class="quote">Preconfigured `anything' for Locate.
Note: you can add locate options after entering pattern.
See 'man locate' for valid options.

You can specify a specific database with prefix argument ARG \(C-u\).
Many databases can be used: navigate and mark them.
See also `anything-locate-with-db'.

To create a user specific db, use
\"updatedb -l 0 -o db_path -U directory\".
Where db_path is a filename matched by
`anything-locate-db-file-regexp'.</span>"
  (interactive "<span class="quote">P</span>")
  (let* ((db (and arg
                  (anything-c-read-file-name
                   "<span class="quote">LocateDBFiles: </span>"
                   :marked-candidates t
                   :preselect anything-locate-db-file-regexp
                   :test #'(lambda (x)
                             (if anything-locate-db-file-regexp
                                 <span class="linecomment">;; Select only locate db files and directories</span>
                                 <span class="linecomment">;; to allow navigation.</span>
                                 (or (string-match
                                      anything-locate-db-file-regexp x)
                                     (file-directory-p x))
                                 x))))))
    (anything-locate-with-db db)))

(defun anything-locate-with-db (&optional db)
  "<span class="quote">Run locate -d DB.
If DB is not given or nil use locate without -d option.
DB can be given as a string or list of db files.
See also `anything-locate'.</span>"
  (when (and db (stringp db)) (setq db (list db)))
  (let ((anything-c-locate-command
          (if db
              (replace-regexp-in-string
               "<span class="quote">locate</span>"
               (format "<span class="quote">locate -d %s</span>"
                       (mapconcat 'identity
                                  <span class="linecomment">;; Remove eventually marked directories by error.</span>
                                  (loop for i in db unless
                                       (file-directory-p i) collect i) "<span class="quote">:</span>"))
               anything-c-locate-command)
              anything-c-locate-command)))
    (anything :sources 'anything-c-source-locate
              :buffer "<span class="quote">*anything locate*</span>"
              :keymap anything-generic-files-map)))
<span class="linecomment">;; (anything-locate-with-db "~/locate.db")</span>

<span class="linecomment">;;;###autoload</span>
(defun anything-w3m-bookmarks ()
  "<span class="quote">Preconfigured `anything' for w3m bookmark.

Needs w3m and emacs-w3m.

http://w3m.sourceforge.net/
http://emacs-w3m.namazu.org/</span>"
  (interactive)
  (anything-other-buffer 'anything-c-source-w3m-bookmarks
                         "<span class="quote">*anything w3m bookmarks*</span>"))

<span class="linecomment">;;;###autoload</span>
(defun anything-firefox-bookmarks ()
  "<span class="quote">Preconfigured `anything' for firefox bookmark.
You will have to enable html bookmarks in firefox:
open about:config in firefox and double click on this line to enable value \
to true:

user_pref(\"browser.bookmarks.autoExportHTML\", false);

You should have now:

user_pref(\"browser.bookmarks.autoExportHTML\", true);

After closing firefox, you will be able to browse you bookmarks.
</span>"
  (interactive)
  (anything-other-buffer 'anything-c-source-firefox-bookmarks
                         "<span class="quote">*Anything Firefox*</span>"))

<span class="linecomment">;;;###autoload</span>
(defun anything-colors ()
  "<span class="quote">Preconfigured `anything' for color.</span>"
  (interactive)
  (anything-other-buffer
   '(anything-c-source-colors anything-c-source-customize-face)
   "<span class="quote">*anything colors*</span>"))

<span class="linecomment">;;;###autoload</span>
(defun anything-bookmarks ()
  "<span class="quote">Preconfigured `anything' for bookmarks.</span>"
  (interactive)
  (anything-other-buffer 'anything-c-source-bookmarks "<span class="quote">*anything bookmarks*</span>"))

<span class="linecomment">;;;###autoload</span>
(defun anything-c-pp-bookmarks ()
  "<span class="quote">Preconfigured `anything' for bookmarks (pretty-printed).</span>"
  (interactive)
  (anything-other-buffer '(anything-c-source-bookmarks-local
                           anything-c-source-bookmarks-su
                           anything-c-source-bookmarks-ssh)
                         "<span class="quote">*anything pp bookmarks*</span>"))

<span class="linecomment">;;;###autoload</span>
(defun anything-c-insert-latex-math ()
  "<span class="quote">Preconfigured anything for latex math symbols completion.</span>"
  (interactive)
  (anything-other-buffer 'anything-c-source-latex-math "<span class="quote">*anything latex*</span>"))

<span class="linecomment">;;;###autoload</span>
(defun anything-register ()
  "<span class="quote">Preconfigured `anything' for Emacs registers.</span>"
  (interactive)
  (anything-other-buffer 'anything-c-source-register "<span class="quote">*anything register*</span>"))

<span class="linecomment">;;;###autoload</span>
(defun anything-man-woman ()
  "<span class="quote">Preconfigured `anything' for Man and Woman pages.</span>"
  (interactive)
  (anything-other-buffer 'anything-c-source-man-pages "<span class="quote">*Anything man woman*</span>"))

<span class="linecomment">;;;###autoload</span>
(defun anything-org-keywords ()
  "<span class="quote">Preconfigured `anything' for org keywords.</span>"
  (interactive)
  (anything-other-buffer 'anything-c-source-org-keywords "<span class="quote">*org keywords*</span>"))

<span class="linecomment">;;;###autoload</span>
(defun anything-emms ()
  "<span class="quote">Preconfigured `anything' for emms sources.</span>"
  (interactive)
  (anything '(anything-c-source-emms-streams
              anything-c-source-emms-files
              anything-c-source-emms-dired)
            nil nil nil nil
            "<span class="quote">*Anything Emms*</span>"))

<span class="linecomment">;;;###autoload</span>
(defun anything-eev-anchors ()
  "<span class="quote">Preconfigured `anything' for eev anchors.</span>"
  (interactive)
  (anything-other-buffer 'anything-c-source-eev-anchor "<span class="quote">*Anything eev anchors*</span>"))

<span class="linecomment">;;;###autoload</span>
(defun anything-bm-list ()
  "<span class="quote">Preconfigured `anything' for visible bookmarks.

Needs bm.el

http://cvs.savannah.gnu.org/viewvc/*checkout*/bm/bm/bm.el</span>"
  (interactive)
  (let ((anything-outline-using t))
    (anything-other-buffer 'anything-c-source-bm "<span class="quote">*anything bm list*</span>")))

<span class="linecomment">;;;###autoload</span>
(defun anything-timers ()
  "<span class="quote">Preconfigured `anything' for timers.</span>"
  (interactive)
  (anything-other-buffer '(anything-c-source-absolute-time-timers
                           anything-c-source-idle-time-timers)
                         "<span class="quote">*anything timers*</span>"))

<span class="linecomment">;;;###autoload</span>
(defun anything-list-emacs-process ()
  "<span class="quote">Preconfigured `anything' for emacs process.</span>"
  (interactive)
  (anything-other-buffer 'anything-c-source-emacs-process "<span class="quote">*anything process*</span>"))

<span class="linecomment">;;;###autoload</span>
(defun anything-occur ()
  "<span class="quote">Preconfigured Anything for Occur source.</span>"
  (interactive)
  (let ((anything-compile-source-functions
         <span class="linecomment">;; rule out anything-match-plugin because the input is one regexp.</span>
         (delq 'anything-compile-source--match-plugin
               (copy-sequence anything-compile-source-functions))))
    (anything-other-buffer 'anything-c-source-occur "<span class="quote">*Anything Occur*</span>")))

<span class="linecomment">;;;###autoload</span>
(defun anything-browse-code ()
  "<span class="quote">Preconfigured anything to browse code.</span>"
  (interactive)
  (anything-other-buffer 'anything-c-source-browse-code "<span class="quote">*Browse code*</span>"))

<span class="linecomment">;;;###autoload</span>
(defun anything-org-headlines ()
  "<span class="quote">Preconfigured anything to show org headlines.</span>"
  (interactive)
  (anything-other-buffer 'anything-c-source-org-headline "<span class="quote">*org headlines*</span>"))

<span class="linecomment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Anything Applications ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="linecomment">;;; kill buffers</span>
<span class="linecomment">;;;###autoload</span>
(defun anything-kill-buffers ()
  "<span class="quote">Preconfigured `anything' to kill buffer you selected.</span>"
  (interactive)
  (anything
   '(((name . "<span class="quote">Kill Buffers</span>")
      (candidates . anything-c-buffer-list)
      (action
       ("<span class="quote">Kill Buffer</span>" . (lambda (candidate)
                          (kill-buffer candidate)
                          (anything-kill-buffers)
                          )))))
   nil nil))

<span class="linecomment">;;; Regexp</span>
(defun anything-c-query-replace-regexp (candidate)
  (let ((regexp (funcall (anything-attr 'regexp))))
    (apply 'query-replace-regexp
           (anything-c-query-replace-args regexp))))

(defun anything-c-kill-regexp-as-sexp (candidate)
  (anything-c-regexp-kill-new
   (prin1-to-string (funcall (anything-attr 'regexp)))))

(defun anything-c-kill-regexp (candidate)
  (anything-c-regexp-kill-new (funcall (anything-attr 'regexp))))

(defun anything-c-query-replace-args (regexp)
  "<span class="quote">create arguments of `query-replace-regexp' action in `anything-regexp'.</span>"
  (let ((region-only (anything-region-active-p)))
    (list
     regexp
     (query-replace-read-to regexp
                            (format "<span class="quote">Query replace %s regexp %s</span>"
                                    (if anything-current-prefix-arg "<span class="quote">word </span>" "<span class="quote"></span>")
                                    (if region-only "<span class="quote">in region </span>" "<span class="quote"></span>"))
                            t)
     anything-current-prefix-arg
     (when region-only (region-beginning))
     (when region-only (region-end)))))

(defvar anything-c-source-regexp
  '((name . "<span class="quote">Regexp Builder</span>")
    (init . (lambda ()
              (anything-candidate-buffer anything-current-buffer)))
    (candidates-in-buffer)
    (get-line . anything-c-regexp-get-line)
    (persistent-action . anything-c-regexp-persistent-action)
    (persistent-help . "<span class="quote">Show this line</span>")
    (multiline)
    (delayed)
    (requires-pattern . 2)
    (mode-line . "<span class="quote">Press TAB to select action.</span>")
    <span class="linecomment">;; RUBIKITCH:</span>
    <span class="linecomment">;; I use here `anything-input' because `anything-pattern' is lost when</span>
    <span class="linecomment">;; using actions from action buffer (otherwise no e.g from RET, C-e or C-j).</span>
    <span class="linecomment">;; It seem `anything-select-action' reset `anything-pattern' to empty too early.</span>
    <span class="linecomment">;; Though the regexp attribute stay defined (tested with *-attr-defined).</span>
    <span class="linecomment">;; Can you fix it?</span>
    (regexp . (lambda () anything-input))
    (action . (("<span class="quote">Kill Regexp as sexp</span>" . anything-c-kill-regexp-as-sexp)
               ("<span class="quote">Query Replace Regexp</span>" . anything-c-query-replace-regexp)
               ("<span class="quote">Kill Regexp</span>" . anything-c-kill-regexp)))))

(defun anything-c-regexp-get-line (s e)
  (propertize
   (apply 'concat
          <span class="linecomment">;; Line contents</span>
          (format "<span class="quote">%5d: %s</span>" (line-number-at-pos (1- s)) (buffer-substring s e))
          <span class="linecomment">;; subexps</span>
          (loop for i from 0 to (1- (/ (length (match-data)) 2))
             collect (format "<span class="quote">\n         %s'%s'</span>"
                             (if (zerop i) "<span class="quote">Group 0: </span>" (format "<span class="quote">Group %d: </span>" i))
                             (match-string i))))
   <span class="linecomment">;; match beginning</span>
   <span class="linecomment">;; KLUDGE: point of anything-candidate-buffer is +1 than that of anything-current-buffer.</span>
   <span class="linecomment">;; It is implementation problem of candidates-in-buffer.</span>
   'anything-realvalue
   (1- s)))

(defun anything-goto-line (lineno)
  "<span class="quote">Goto LINENO opening only outline headline if needed.</span>"
  (goto-char (point-min)) (forward-line (1- lineno))
  (when (or (eq major-mode 'org-mode) outline-minor-mode)
    (org-reveal))
  (anything-match-line-color-current-line) (sit-for 0.3)
  (anything-match-line-cleanup))

(defun anything-c-regexp-persistent-action (pt)
  (goto-char pt)
  (anything-persistent-highlight-point))

(defun anything-c-regexp-kill-new (input)
  (kill-new input)
  (message "<span class="quote">Killed: %s</span>" input))

(defun anything-region-active-p ()
  (and transient-mark-mode mark-active (/= (mark) (point))))

(defun* anything-current-buffer-narrowed-p (&optional
                                            (buffer anything-current-buffer))
  "<span class="quote">Check if BUFFER is narrowed.
Default is `anything-current-buffer'.</span>"
  (with-current-buffer buffer
    (let ((beg (point-min))
          (end (point-max))
          (total (buffer-size)))
      (or (/= beg 1) (/= end (1+ total))))))

<span class="linecomment">;;;###autoload</span>
(defun anything-regexp ()
  "<span class="quote">Preconfigured anything to build regexps and run query-replace-regexp \
against.</span>"
  (interactive)
  (save-restriction
    (let ((anything-compile-source-functions
           <span class="linecomment">;; rule out anything-match-plugin because the input is one regexp.</span>
           (delq 'anything-compile-source--match-plugin
                 (copy-sequence anything-compile-source-functions))))
      (when (and (anything-region-active-p)
                 <span class="linecomment">;; Don't narrow to region if buffer is already narrowed.</span>
                 (not (anything-current-buffer-narrowed-p)))
        (narrow-to-region (region-beginning) (region-end)))
      (anything :sources
                anything-c-source-regexp
                :buffer "<span class="quote">*anything regexp*</span>"
                :prompt "<span class="quote">Regexp: </span>"))))


<span class="linecomment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Interactive Functions ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

(defun anything-insert-buffer-name ()
  "<span class="quote">Insert buffer name.</span>"
  (interactive)
  (anything-insert-string
   (with-current-buffer anything-current-buffer
     (if buffer-file-name (file-name-nondirectory buffer-file-name)
       (buffer-name)))))

(defun anything-insert-symbol ()
  "<span class="quote">Insert current symbol.</span>"
  (interactive)
  (anything-insert-string
   (with-current-buffer anything-current-buffer
     (save-excursion
       (buffer-substring (beginning-of-thing 'symbol)
                         (end-of-thing 'symbol))))))

(defun anything-insert-selection ()
  "<span class="quote">Insert current selection.</span>"
  (interactive)
  (anything-insert-string
   (with-current-buffer anything-current-buffer
     (anything-get-selection))))

(defun anything-show-buffer-only ()
  "<span class="quote">[OBSOLETE] Only show sources about buffer.
Use `anything-for-buffers' instead.</span>"
  (interactive)
  (anything-set-source-filter '("<span class="quote">Buffers</span>")))

(defun anything-show-bbdb-only ()
  "<span class="quote">[OBSOLETE] Only show sources about BBDB.
Use `anything-bbdb' instead.</span>"
  (interactive)
  (anything-set-source-filter '("<span class="quote">BBDB</span>")))

(defun anything-show-locate-only ()
  "<span class="quote">[OBSOLETE] Only show sources about Locate.
Use `anything-locate' instead.</span>"
  (interactive)
  (anything-set-source-filter '("<span class="quote">Locate</span>")))

(defun anything-show-info-only ()
  "<span class="quote">[OBSOLETE] Only show sources about Info.
Use `anything-info-at-point' instead.</span>"
  (interactive)
  (anything-set-source-filter '("<span class="quote">Info Pages</span>"
                                "<span class="quote">Info Elisp</span>"
                                "<span class="quote">Info Common-Lisp</span>")))

(defun anything-show-imenu-only ()
  "<span class="quote">[OBSOLETE] Only show sources about Imenu.
Use `anything-imenu' instead.</span>"
  (interactive)
  (anything-set-source-filter '("<span class="quote">Imenu</span>")))

(defun anything-show-files-only ()
  "<span class="quote">[OBSOLETE] Only show sources about File.
Use `anything-for-files' instead.</span>"
  (interactive)
  (anything-set-source-filter '("<span class="quote">File Name History</span>"
                                "<span class="quote">Files from Current Directory</span>"
                                "<span class="quote">Recentf</span>")))

(defun anything-show-w3m-bookmarks-only ()
  "<span class="quote">[OBSOLETE] Only show source about w3m bookmark.
Use `anything-w3m-bookmarks' instead.</span>"
  (interactive)
  (anything-set-source-filter '("<span class="quote">W3m Bookmarks</span>")))

(defun anything-show-colors-only ()
  "<span class="quote">[OBSOLETE] Only show source about color.
Use `anything-colors' instead.</span>"
  (interactive)
  (anything-set-source-filter '("<span class="quote">Colors</span>"
                                "<span class="quote">Customize Faces</span>")))

(defun anything-show-kill-ring-only ()
  "<span class="quote">[OBSOLETE] Only show source about kill ring.
Use `anything-show-kill-ring' instead.</span>"
  (interactive)
  (anything-set-source-filter '("<span class="quote">Kill Ring</span>")))

(defun anything-show-this-source-only ()
  "<span class="quote">Only show this source.</span>"
  (interactive)
  (setq anything-candidate-number-limit 9999)
  (anything-set-source-filter
   (list (assoc-default 'name (anything-get-current-source)))))

(defun anything-test-sources ()
  "<span class="quote">List all anything sources for test.
The output is sexps which are evaluated by \\[eval-last-sexp].</span>"
  (interactive)
  (with-output-to-temp-buffer "<span class="quote">*Anything Test Sources*</span>"
    (mapc (lambda (s) (princ (format "<span class="quote">;; (anything '%s)\n</span>" s)))
          (apropos-internal "<span class="quote">^anything-c-source</span>" #'boundp))
    (pop-to-buffer standard-output)))

<span class="linecomment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Utilities Functions ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="linecomment">;;; For compatibility</span>
(unless (fboundp 'region-active-p)
  (defun region-active-p ()
    "<span class="quote">Return t if Transient Mark mode is enabled and the mark is active.

Most commands that act on the region if it is active and
Transient Mark mode is enabled, and on the text near point
otherwise, should use `use-region-p' instead.  That function
checks the value of `use-empty-active-region' as well.</span>"
    (and transient-mark-mode mark-active)))

(defun anything-nest (&rest same-as-anything)
  "<span class="quote">Nested `anything'. If you use `anything' within `anything', use it.</span>"
  (with-selected-window (anything-window)
    (let (anything-current-position
          anything-current-buffer
          (orig-anything-buffer anything-buffer)
          anything-pattern
          anything-buffer
          anything-sources
          anything-compiled-sources
          anything-buffer-chars-modified-tick
          (anything-samewindow t)
          (enable-recursive-minibuffers t))
      (unwind-protect
          (apply #'anything same-as-anything)
        (anything-initialize-overlays orig-anything-buffer)
        (add-hook 'post-command-hook 'anything-check-minibuffer-input)))))

(defun anything-displaying-source-names ()
  "<span class="quote">Display sources name.</span>"
  (with-current-buffer anything-buffer
    (goto-char (point-min))
    (loop with pos
          while (setq pos (next-single-property-change (point) 'anything-header))
          do (goto-char pos)
          collect (buffer-substring-no-properties (point-at-bol)(point-at-eol))
          do (forward-line 1))))

(defun anything-select-source ()
  "<span class="quote">Select source.</span>"
  (interactive)
  (let ((default (assoc-default 'name (anything-get-current-source)))
        (source-names (anything-displaying-source-names))
        (all-source-names (mapcar (lambda (s) (assoc-default 'name s))
                                  (anything-get-sources))))
    (setq anything-candidate-number-limit 9999)
    (anything-aif
        (let (anything-source-filter)
          (anything-nest '(((name . "<span class="quote">Anything Source</span>")
                            (candidates . source-names)
                            (action . identity))
                           ((name . "<span class="quote">Anything Source (ALL)</span>")
                            (candidates . all-source-names)
                            (action . identity)))
                         nil "<span class="quote">Source: </span>" nil
                         default "<span class="quote">*anything select source*</span>"))
        (anything-set-source-filter (list it))
      (anything-set-source-filter nil))))

(defun anything-insert-string (str)
  "<span class="quote">Insert STR.</span>"
  (delete-minibuffer-contents)
  (insert str))

(defun anything-c-match-on-file-name (candidate)
  "<span class="quote">Return non-nil if `anything-pattern' match the filename (without directory part) of CANDIDATE.</span>"
  (string-match anything-pattern (file-name-nondirectory candidate)))

(defun anything-c-match-on-directory-name (candidate)
  "<span class="quote">Return non-nil if `anything-pattern' match the directory part of CANDIDATE (a file).</span>"
  (anything-aif (file-name-directory candidate)
      (string-match anything-pattern it)))

(defun anything-c-string-match (candidate)
  "<span class="quote">Return non-nil if `anything-pattern' match CANDIDATE.
The match is done with `string-match'.</span>"
  (string-match anything-pattern candidate))

<span class="linecomment">;; `anything-c-compose' is no more needed, it is for compatibility.</span>
(defalias 'anything-c-compose 'anything-compose)

(defun anything-c-skip-entries (list regexp)
  "<span class="quote">Remove entries which matches REGEXP from LIST.</span>"
  (remove-if (lambda (x) (and (stringp x) (string-match regexp x)))
             list))

(defun anything-c-shadow-entries (list regexp)
  "<span class="quote">Elements of LIST matching REGEXP will be displayed with the `file-name-shadow' face if available.</span>"
  (mapcar (lambda (file)
            <span class="linecomment">;; Add shadow face property to boring files.</span>
            (let ((face (if (facep 'file-name-shadow)
                            'file-name-shadow
                          <span class="linecomment">;; fall back to default on XEmacs</span>
                          'default)))
              (if (string-match regexp file)
                  (setq file (propertize file 'face face))))
            file)
          list))

(defsubst anything-c-stringify (str-or-sym)
  "<span class="quote">Get string of STR-OR-SYM.</span>"
  (if (stringp str-or-sym)
      str-or-sym
    (symbol-name str-or-sym)))

(defsubst anything-c-symbolify (str-or-sym)
  "<span class="quote">Get symbol of STR-OR-SYM.</span>"
  (if (symbolp str-or-sym)
      str-or-sym
    (intern str-or-sym)))

(defun anything-c-describe-function (func)
  "<span class="quote">FUNC is symbol or string.</span>"
  (describe-function (anything-c-symbolify func)))

(defun anything-c-describe-variable (var)
  "<span class="quote">VAR is symbol or string.</span>"
  (describe-variable (anything-c-symbolify var)))

(defun anything-c-find-function (func)
  "<span class="quote">FUNC is symbol or string.</span>"
  (find-function (anything-c-symbolify func)))

(defun anything-c-find-variable (var)
  "<span class="quote">VAR is symbol or string.</span>"
  (find-variable (anything-c-symbolify var)))

(defun anything-c-kill-new (string &optional replace yank-handler)
  "<span class="quote">STRING is symbol or string.</span>"
  (kill-new (anything-c-stringify string) replace yank-handler))

<span class="linecomment">;;; Toggle all marks.</span>

<span class="linecomment">;;;###autoload</span>
(defun anything-mark-all ()
  "<span class="quote">Mark all visible unmarked candidates in current source.</span>"
  (interactive)
  (with-anything-window
    (save-excursion
      (goto-char (anything-get-previous-header-pos))
      (anything-next-line)
      (let* ((next-head (anything-get-next-header-pos))
             (end       (and next-head
                             (save-excursion
                               (goto-char next-head)
                               (forward-line -2)
                               (point))))
             (maxpoint  (or end (point-max))))
        (while (&lt; (point) maxpoint)
          (anything-mark-current-line)
          (let ((prefix (get-text-property (point-at-bol) 'display))
                (bn     (anything-c-basename (anything-get-selection)))
                (src    (assoc-default 'name (anything-get-current-source))))
            (when (and (not (anything-this-visible-mark))
                       (not (or (string= prefix "<span class="quote">[?]</span>")
                                (string= prefix "<span class="quote">[@]</span>"))))
              <span class="linecomment">;; Don't mark possibles directories ending with . or ..</span>
              <span class="linecomment">;; and also autosave files/links.</span>
              (unless
                  (and (or (anything-file-completion-source-p)
                           (equal src "<span class="quote">Files from Current Directory</span>"))
                       (string-match "<span class="quote">^\\.#.*\\|^#.*#$\\|\\.$</span>" bn))
                (anything-make-visible-mark))))
          (forward-line 1) (end-of-line))))
    (anything-mark-current-line)
    (message "<span class="quote">%s candidates marked</span>" (length anything-marked-candidates))))

<span class="linecomment">;;;###autoload</span>
(defun anything-unmark-all ()
  "<span class="quote">Unmark all candidates in all sources of current anything session.</span>"
  (interactive)
  (with-anything-window
    (let ((len (length anything-marked-candidates)))
      (save-excursion
        (anything-clear-visible-mark))
      (setq anything-marked-candidates nil)
      (anything-mark-current-line)
      (message "<span class="quote">%s candidates unmarked</span>" len))))

<span class="linecomment">;;;###autoload</span>
(defun anything-toggle-all-marks ()
  "<span class="quote">Toggle all marks.
Mark all visible candidates of current source or unmark all candidates
visible or invisible in all sources of current anything session</span>"
  (interactive)
  (let ((marked (anything-marked-candidates)))
    (if (and (&gt;= (length marked) 1)
             (with-anything-window anything-visible-mark-overlays))
        (anything-unmark-all)
        (anything-mark-all))))

(define-key anything-map (kbd "<span class="quote">M-m</span>") 'anything-toggle-all-marks)

<span class="linecomment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Hacks ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
(defadvice eval-defun (after anything-source-hack activate)
  "<span class="quote">See `anything-c-enable-eval-defun-hack'.</span>"
  (when anything-c-enable-eval-defun-hack
    (let ((varsym (save-excursion
                    (beginning-of-defun)
                    (forward-char 1)
                    (when (memq (read (current-buffer)) '(defvar setq))
                      (read (current-buffer))))))
      (when (string-match "<span class="quote">^anything-c-source-</span>" (symbol-name varsym))
        (anything varsym)))))
<span class="linecomment">;; (progn (ad-disable-advice 'eval-defun 'after 'anything-source-hack) (ad-update 'eval-defun))</span>

<span class="linecomment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Document Generator ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
(defconst anything-c-create-summary-index-regexp
  "<span class="quote">^;;;; &lt;\\(.+?\\)&gt;$\\|^;; (anything '\\(.+?\\))$\\|^ *;; (anything '\\(.+?\\))$</span>")
(defun anything-c-create-summary ()
  "<span class="quote">Create `anything' summary.</span>"
  (save-excursion
    (goto-char (point-min))
    (loop with it
          while (re-search-forward anything-c-create-summary-index-regexp nil t)
          collect
          (cond ((setq it (match-string-no-properties 1))
                 (cons 'section it))
                ((setq it (match-string-no-properties 2))
                 `(source ,it .
                          ,(assoc-default 'name (symbol-value (intern it)))))
                ((setq it (match-string-no-properties 3))
                 `(source ,it .
                          ,(assoc-default 'name (symbol-value (intern it)))))))))

<span class="linecomment">;; (find-epp (anything-c-create-summary))</span>

(defun anything-c-insert-summary ()
  "<span class="quote">Insert `anything' summary.</span>"
  (save-excursion
    (goto-char (point-min))
    (search-forward "<span class="quote">;; Below are complete source list you can setup in</span>")
    (forward-line 1)
    (delete-region (point)
                   (progn (search-forward "<span class="quote">;;; Change log:</span>" nil t)
                          (forward-line -1) (point)))
    (insert "<span class="quote">;;\n</span>")
    (loop with beg
          for (kind . value) in (anything-c-create-summary)
          for i from 0
          do (cond ((eq kind 'section)
                    (unless (zerop i)
                      (align-regexp beg (point) "<span class="quote">\\(\\s-*\\)(</span>" 1 1 nil))
                    (insert "<span class="quote">;;  </span>" value "<span class="quote">:\n</span>")
                    (setq beg (point)))
                   (t
                    (insert "<span class="quote">;;     `</span>" (car value) "<span class="quote">'    (</span>" (cdr value) "<span class="quote">)\n</span>")))
          finally (align-regexp beg (point) "<span class="quote">\\(\\s-*\\)(</span>" 1 1 nil))))
<span class="linecomment">;; (anything-c-insert-summary)</span>

<span class="linecomment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Anything Sources ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="linecomment">;;;; &lt;Buffer&gt;</span>
(defun anything-c-buffer-list ()
  "<span class="quote">Return the list of names of buffers with boring buffers filtered out.
Boring buffers is specified by `anything-c-boring-buffer-regexp'.
The first buffer in the list will be the last recently used
buffer that is not the current buffer.</span>"
  (let ((buffers (mapcar 'buffer-name (buffer-list))))
    (append (cdr buffers) (list (car buffers)))))

(defvar anything-c-source-buffers
  '((name . "<span class="quote">Buffers</span>")
    (candidates . anything-c-buffer-list)
    (type . buffer)))
<span class="linecomment">;; (anything 'anything-c-source-buffers)</span>

(defvar anything-c-source-buffer-not-found
  '((name . "<span class="quote">Create buffer</span>")
    (dummy)
    (type . buffer)))
<span class="linecomment">;; (anything 'anything-c-source-buffer-not-found)</span>

<span class="linecomment">;;; Buffers+</span>

(defface anything-buffer-saved-out
    '((t (:foreground "<span class="quote">red</span>")))
  "<span class="quote">*Face used for buffer files modified outside of emacs.</span>"
  :group 'anything-config)

(defface anything-buffer-not-saved
    '((t (:foreground "<span class="quote">Indianred2</span>")))
  "<span class="quote">*Face used for buffer files not already saved on disk.</span>"
  :group 'anything-config)

(eval-when-compile (require 'dired))

(defun anything-c-highlight-buffers (buffers)
  (loop for i in buffers
     for buf = (get-buffer i)
     for bfname = (buffer-file-name buf)
     collect
     (cond (<span class="linecomment">;; A dired buffer.</span>
            (rassoc buf dired-buffers)
            (propertize i 'face 'anything-ff-directory
                        'help-echo (car (rassoc buf dired-buffers))))
           <span class="linecomment">;; A buffer file modified somewhere outside of emacs.</span>
           ((and bfname (not (file-remote-p bfname))
                 (file-exists-p bfname)
                 (not (verify-visited-file-modtime buf)))
            (propertize i 'face 'anything-buffer-saved-out
                        'help-echo bfname))
           <span class="linecomment">;; A new buffer file not already saved on disk.</span>
           ((and bfname (not (file-remote-p bfname))
                 (not (verify-visited-file-modtime buf)))
            (propertize i 'face 'anything-buffer-not-saved
                        'help-echo bfname))
           <span class="linecomment">;; A Remote buffer file modified and not saved on disk.</span>
           ((and bfname (file-remote-p bfname) (buffer-modified-p buf))
            (let ((prefix (propertize
                           "<span class="quote"> </span>" 'display
                           (propertize "<span class="quote">@ </span>" 'face 'anything-ff-prefix))))
              (cons (concat prefix (propertize i 'face 'anything-ff-symlink
                                             'help-echo bfname)) i)))
           <span class="linecomment">;; A buffer file modified and not saved on disk.</span>
           ((and bfname (buffer-modified-p buf))
            (propertize i 'face 'anything-ff-symlink
                        'help-echo bfname))
           <span class="linecomment">;; A remote buffer file not modified and saved on disk.</span>
           ((and bfname (file-remote-p bfname))
            (let ((prefix (propertize
                           "<span class="quote"> </span>" 'display
                           (propertize "<span class="quote">@ </span>" 'face 'anything-ff-prefix))))
              (cons (concat prefix (propertize i 'face 'font-lock-type-face
                                               'help-echo bfname)) i)))
           <span class="linecomment">;; A buffer file not modified and saved on disk.</span>
           (bfname
            (propertize i 'face 'font-lock-type-face
                        'help-echo bfname))
           <span class="linecomment">;; Any non--file buffer.</span>
           (t (propertize i 'face 'italic)))))

(defvar anything-buffer-mode-line-string
  "<span class="quote">\\&lt;anything-c-buffer-map&gt;\
\\[anything-c-buffer-help]:Help, \
\\&lt;anything-map&gt;\
\\[anything-select-action]:Acts,\
\\[anything-exit-minibuffer]/\\[anything-select-2nd-action-or-end-of-line]/\
\\[anything-select-3rd-action]:NthAct,\
\\[anything-send-bug-report-from-anything]:BugReport.</span>"
  "<span class="quote">String displayed in mode-line in `anything-c-source-buffers+'</span>")

(defvar anything-c-buffers-cache nil)
(defvar anything-c-source-buffers+
  '((name . "<span class="quote">Buffers</span>")
    (init . (lambda ()
              (setq anything-c-buffers-cache (anything-c-buffer-list))))
    (candidates . anything-c-buffers-cache)
    (type . buffer)
    (match anything-c-buffer-match-major-mode)
    (diff-action . anything-buffer-toggle-diff)
    (revert-action . anything-buffer-revert-and-update)
    (save-action . anything-buffer-save-and-update)
    (candidate-transformer anything-c-skip-current-buffer
                           anything-c-skip-boring-buffers
                           anything-c-highlight-buffers)
    (persistent-action . anything-c-buffers+-persistent-action)
    (mode-line . anything-buffer-mode-line-string)
    (persistent-help . "<span class="quote">Show this buffer / C-u \\[anything-execute-persistent-action]: Kill this buffer</span>")))

(defun anything-c-buffer-match-major-mode (candidate)
  "<span class="quote">Match maybe buffer by major-mode.
If you give a major-mode or partial major-mode,
it will list all buffers of this major-mode and/or buffers with name
matching this major-mode.
If you add a space after major-mode and then a space,
it will match all buffers of the major-mode
before space matching pattern after space.
If you give a pattern which doesn't match a major-mode, it will search buffer
with name matching pattern.</span>"
  (let* ((cand (replace-regexp-in-string "<span class="quote">^\\s-\\{1\\}</span>" "<span class="quote"></span>" candidate))
         (buf  (get-buffer cand)))
    (when buf
      (with-current-buffer buf
        (let ((mjm   (symbol-name major-mode))
              (split (split-string anything-pattern)))
          (if (string-match "<span class="quote"> </span>" anything-pattern)
              (and (string-match (car split) mjm)
                   (string-match (cadr split) cand))
              (or (string-match anything-pattern mjm)
                  (string-match anything-pattern cand))))))))

(defun anything-c-buffer-query-replace-1 (&optional regexp-flag)
  "<span class="quote">Query replace in marked buffers.
If REGEXP-FLAG is given use `query-replace-regexp'.</span>"
  (let ((fn     (if regexp-flag 'query-replace-regexp 'query-replace))
        (prompt (if regexp-flag "<span class="quote">Query replace regexp</span>" "<span class="quote">Query replace</span>"))
        (bufs   (anything-marked-candidates)))
    (loop 
       with replace = (query-replace-read-from prompt regexp-flag)
       with tostring = (unless (consp replace)
                         (query-replace-read-to
                          replace prompt regexp-flag))
       for buf in bufs
       do
       (save-window-excursion
         (switch-to-buffer buf)
         (save-excursion
           (let ((case-fold-search t))
             (goto-char (point-min))
             (if (consp replace)
                 (apply fn (list (car replace) (cdr replace)))
                 (apply fn (list replace tostring)))))))))

(defun anything-c-buffer-query-replace-regexp (candidate)
  (anything-c-buffer-query-replace-1 'regexp))

(defun anything-c-buffer-query-replace (candidate)
  (anything-c-buffer-query-replace-1))

(defun anything-c-buffer-help ()
  (interactive)
  (let ((anything-help-message "<span class="quote">== Anything Buffer ==\
\nSpecific commands for `anything-buffer+':
\\&lt;anything-c-buffer-map&gt;
\\[anything-buffer-run-grep]\t\t-&gt;Grep Buffer(s) (C-u grep all buffers linked to a file).
\\[anything-buffer-run-zgrep]\t\t-&gt;Zgrep Buffer(s) (C-u grep all buffers linked to a file).
\\[anything-buffer-switch-other-window]\t\t-&gt;Switch other window.
\\[anything-buffer-switch-other-frame]\t\t-&gt;Switch other frame.
\\[anything-buffer-run-query-replace-regexp]\t\t-&gt;Query replace regexp in marked buffers.
\\[anything-buffer-run-query-replace]\t\t-&gt;Query replace in marked buffers.
\\[anything-buffer-switch-to-elscreen]\t\t-&gt;Find buffer in Elscreen.
\\[anything-buffer-diff-persistent]\t\t-&gt;Toggle Diff buffer without quitting.
\\[anything-buffer-revert-persistent]\t\t-&gt;Revert buffer without quitting.
\\[anything-buffer-save-persistent]\t\t-&gt;Save buffer without quitting.
\\[anything-buffer-run-kill-buffers]\t\t-&gt;Delete marked buffers and quit.
\\[anything-c-buffer-help]\t\t-&gt;Display this help.
\n== Anything Map ==
\\{anything-map}
</span>"))
    (anything-help)))

(defvar anything-c-buffer-map
  (let ((map (copy-keymap anything-map)))
    (define-key map (kbd "<span class="quote">C-c ?</span>")     'anything-c-buffer-help)
    (define-key map (kbd "<span class="quote">M-g s</span>")     'anything-buffer-run-grep)
    (define-key map (kbd "<span class="quote">M-g z</span>")     'anything-buffer-run-zgrep)
    (define-key map (kbd "<span class="quote">C-o</span>")       'anything-buffer-switch-other-window)
    (define-key map (kbd "<span class="quote">C-c C-o</span>")   'anything-buffer-switch-other-frame)
    (define-key map (kbd "<span class="quote">C-=</span>")       'anything-buffer-diff-persistent)
    (define-key map (kbd "<span class="quote">M-U</span>")       'anything-buffer-revert-persistent)
    (define-key map (kbd "<span class="quote">M-D</span>")       'anything-buffer-run-kill-buffers)
    (define-key map (kbd "<span class="quote">C-x C-s</span>")   'anything-buffer-save-persistent)
    (define-key map (kbd "<span class="quote">C-M-%</span>")     'anything-buffer-run-query-replace-regexp)
    (define-key map (kbd "<span class="quote">M-%</span>")       'anything-buffer-run-query-replace)
    (when (locate-library "<span class="quote">elscreen</span>")
      (define-key map (kbd "<span class="quote">&lt;C-tab&gt;</span>") 'anything-buffer-switch-to-elscreen))
    (delq nil map))
  "<span class="quote">Keymap for buffer sources in anything.</span>")

(defun anything-buffer-toggle-diff (candidate)
  "<span class="quote">Toggle diff buffer CANDIDATE with it's file.</span>"
  (if (get-buffer-window "<span class="quote">*Diff*</span>")
      (kill-buffer "<span class="quote">*Diff*</span>")
      (diff-buffer-with-file (get-buffer candidate))))

<span class="linecomment">;;;###autoload</span>
(defun anything-buffer-diff-persistent ()
  "<span class="quote">Toggle diff buffer without quitting anything.</span>"
  (interactive)
  (anything-execute-persistent-action 'diff-action))

(defun anything-buffer-revert-and-update (candidate)
  (let ((marked (anything-marked-candidates)))
    (loop for buf in marked do (anything-revert-buffer buf))
    (anything-force-update)
    (anything-c-recenter-window)))

<span class="linecomment">;;;###autoload</span>
(defun anything-buffer-revert-persistent ()
  "<span class="quote">Revert buffer without quitting anything.</span>"
  (interactive)
  (anything-execute-persistent-action 'revert-action))

(defun anything-buffer-save-and-update (candidate)
  (let ((marked (anything-marked-candidates)))
    (loop for buf in marked do
         (with-current-buffer (get-buffer buf)
           (save-buffer)))
    (anything-force-update)
    (anything-c-recenter-window)))

<span class="linecomment">;;;###autoload</span>
(defun anything-buffer-save-persistent ()
  "<span class="quote">Save buffer without quitting anything.</span>"
  (interactive)
  (anything-execute-persistent-action 'save-action))

<span class="linecomment">;;;###autoload</span>
(defun anything-buffer-run-kill-buffers ()
  "<span class="quote">Run kill buffer action from `anything-c-source-buffer+'.</span>"
  (interactive)
  (anything-c-quit-and-execute-action 'anything-kill-marked-buffers))

<span class="linecomment">;;;###autoload</span>
(defun anything-buffer-run-grep ()
  "<span class="quote">Run Grep action from `anything-c-source-buffer+'.</span>"
  (interactive)
  (anything-c-quit-and-execute-action 'anything-c-grep-buffers))

<span class="linecomment">;;;###autoload</span>
(defun anything-buffer-run-zgrep ()
  "<span class="quote">Run Grep action from `anything-c-source-buffer+'.</span>"
  (interactive)
  (anything-c-quit-and-execute-action 'anything-c-zgrep-buffers))

<span class="linecomment">;;;###autoload</span>
(defun anything-buffer-run-query-replace-regexp ()
  "<span class="quote">Run Query replace regexp action from `anything-c-source-buffer+'.</span>"
  (interactive)
  (anything-c-quit-and-execute-action 'anything-c-buffer-query-replace-regexp))

<span class="linecomment">;;;###autoload</span>
(defun anything-buffer-run-query-replace ()
  "<span class="quote">Run Query replace action from `anything-c-source-buffer+'.</span>"
  (interactive)
  (anything-c-quit-and-execute-action 'anything-c-buffer-query-replace))

<span class="linecomment">;;;###autoload</span>
(defun anything-buffer-switch-other-window ()
  "<span class="quote">Run switch to other window action from `anything-c-source-buffer+'.</span>"
  (interactive)
  (anything-c-quit-and-execute-action 'switch-to-buffer-other-window))

<span class="linecomment">;;;###autoload</span>
(defun anything-buffer-switch-other-frame ()
  "<span class="quote">Run switch to other frame action from `anything-c-source-buffer+'.</span>"
  (interactive)
  (anything-c-quit-and-execute-action 'switch-to-buffer-other-frame))

<span class="linecomment">;;;###autoload</span>
(defun anything-buffer-switch-to-elscreen ()
  "<span class="quote">Run switch to elscreen  action from `anything-c-source-buffer+'.</span>"
  (interactive)
  (anything-c-quit-and-execute-action 'anything-find-buffer-on-elscreen))

(defun anything-c-buffers-persistent-kill (buffer)
  (with-current-buffer (get-buffer buffer)
    (if (and (buffer-modified-p)
             (buffer-file-name (current-buffer)))
        (progn
          (save-buffer)
          (kill-buffer buffer))
        (kill-buffer buffer)))
  (anything-delete-current-selection)
  (anything-force-update)
  (anything-c-recenter-window))

(defun anything-c-recenter-window ()
  "<span class="quote">Make visible current selection by recentering anything window.</span>"
  (with-anything-window (recenter)))

(defun anything-c-buffers+-persistent-action (candidate)
    (if current-prefix-arg
        (anything-c-buffers-persistent-kill candidate)
        (switch-to-buffer candidate)))

<span class="linecomment">;; (anything 'anything-c-source-buffers+)</span>

(defadvice anything-quit-and-find-file (around use-anything-find-files activate)
  "<span class="quote">Let `anything-quit-and-find-file' take advantage of `anything-find-files'.</span>"
  (interactive)
  (anything-run-after-quit
   (lambda (f)
     (anything-find-files1 f))
   (anything-aif (get-buffer (anything-get-selection))
       (or (buffer-file-name it)
           (car (rassoc it dired-buffers))
           (and (with-current-buffer it
                  (eq major-mode 'org-agenda-mode))
                org-directory
                (expand-file-name org-directory))
           default-directory)
     (let ((sel (anything-get-selection)))
       (if (file-exists-p sel)
           (expand-file-name sel)
           default-directory)))))

<span class="linecomment">;;;; &lt;File&gt;</span>
<span class="linecomment">;;; File name history</span>
(defvar anything-c-source-file-name-history
  '((name . "<span class="quote">File Name History</span>")
    (candidates . file-name-history)
    (match anything-c-match-on-file-name
           anything-c-match-on-directory-name)
    (type . file)))
<span class="linecomment">;; (anything 'anything-c-source-file-name-history)</span>

<span class="linecomment">;;; Files in current dir</span>
(defvar anything-c-source-files-in-current-dir
  '((name . "<span class="quote">Files from Current Directory</span>")
    (candidates . (lambda ()
                    (with-current-buffer anything-current-buffer
                      (directory-files (anything-c-current-directory)))))
    <span class="linecomment">;; volatile is not needed, I think.</span>
    (type . file)))
<span class="linecomment">;; (anything 'anything-c-source-files-in-current-dir)</span>

(defun anything-c-highlight-files (files)
  (loop for i in files
        if (file-directory-p i)
        collect (propertize (file-name-nondirectory i)
                            'face 'anything-ff-directory
                            'help-echo (expand-file-name i))
        else
        collect (propertize (file-name-nondirectory i)
                            'face 'anything-ff-file
                            'help-echo (expand-file-name i))))

(defvar anything-c-source-files-in-current-dir+
  '((name . "<span class="quote">Files from Current Directory</span>")
    (candidates . (lambda ()
                    (with-current-buffer anything-current-buffer
                      (directory-files (anything-c-current-directory) t))))
    (candidate-transformer anything-c-highlight-files)
    <span class="linecomment">;; volatile is not needed, I think.</span>
    (type . file)))

<span class="linecomment">;; (anything 'anything-c-source-files-in-current-dir+)</span>

<span class="linecomment">;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="linecomment">;;; Anything-find-files</span>
<span class="linecomment">;;;</span>
<span class="linecomment">;;; Anything replacement of file name completion for `find-file' and friends.</span>

(defface anything-ff-prefix
  '((t (:background "<span class="quote">yellow</span>" :foreground "<span class="quote">black</span>")))
  "<span class="quote">*Face used to prefix new file or url paths in `anything-find-files'.</span>"
  :group 'anything-config)

(defface anything-ff-executable
  '((t (:foreground "<span class="quote">green</span>")))
  "<span class="quote">*Face used for executable files in `anything-find-files'.</span>"
  :group 'anything-config)

(defface anything-ff-directory
  '((t (:foreground "<span class="quote">DarkRed</span>" :background "<span class="quote">LightGray</span>")))
  "<span class="quote">*Face used for directories in `anything-find-files'.</span>"
  :group 'anything-config)

(defface anything-ff-symlink
  '((t (:foreground "<span class="quote">DarkOrange</span>")))
  "<span class="quote">*Face used for symlinks in `anything-find-files'.</span>"
  :group 'anything-config)


(defface anything-ff-invalid-symlink
  '((t (:foreground "<span class="quote">black</span>" :background "<span class="quote">red</span>")))
  "<span class="quote">*Face used for invalid symlinks in `anything-find-files'.</span>"
  :group 'anything-config)

(defface anything-ff-file
  '((t (:foreground "<span class="quote">CadetBlue</span>" :underline t)))
  "<span class="quote">*Face used for file names in `anything-find-files'.</span>"
  :group 'anything-config)

(defvar anything-c-find-files-doc-header (format "<span class="quote"> (`%s':Go to precedent level)</span>"
                                                 (if window-system "<span class="quote">C-.</span>" "<span class="quote">C-l</span>"))
  "<span class="quote">*The doc that is inserted in the Name header of a find-files or dired source.</span>")

(defvar anything-ff-mode-line-string
  "<span class="quote">\\&lt;anything-find-files-map&gt;\
\\[anything-ff-help]:Help, \
\\[anything-send-bug-report-from-anything]:BugReport, \
\\&lt;anything-map&gt;\
\\[anything-select-action]:Acts, \
\\[anything-exit-minibuffer]/\\[anything-select-2nd-action-or-end-of-line]/\
\\[anything-select-3rd-action]:NthAct</span>"

  "<span class="quote">String displayed in mode-line in `anything-c-source-find-files'</span>")

(defvar anything-c-source-find-files
  `((name . ,(concat "<span class="quote">Find Files</span>" anything-c-find-files-doc-header))
    <span class="linecomment">;; It is needed for filenames with capital letters</span>
    (disable-shortcuts)
    (init . (lambda ()
              (setq ffap-newfile-prompt t)))
    (candidates . anything-find-files-get-candidates)
    (filtered-candidate-transformer anything-c-find-files-transformer)
    (image-action1 . anything-ff-rotate-image-left)
    (image-action2 . anything-ff-rotate-image-right)
    (properties-action . anything-ff-properties)
    (persistent-action . anything-find-files-persistent-action)
    (persistent-help . "<span class="quote">Hit1 Expand Candidate, Hit2 or (C-u) Find file</span>")
    (mode-line . anything-ff-mode-line-string)
    (volatile)
    (candidate-number-limit . 9999)
    (action-transformer . anything-find-files-action-transformer)
    (action
     . ,(delq
         nil
         `(("<span class="quote">Find File</span>" . anything-c-find-file-or-marked)
           ("<span class="quote">Find file in Dired</span>" . anything-c-point-file-in-dired)
           ,(and (locate-library "<span class="quote">elscreen</span>")
                 '("<span class="quote">Find file in Elscreen</span>"  . anything-elscreen-find-file))
           ,(and (locate-library "<span class="quote">popwin</span>")
                 '("<span class="quote">Find file in popup window</span>" . popwin:find-file))
           ("<span class="quote">Complete at point `M-tab'</span>"
            . anything-c-insert-file-name-completion-at-point)
           ("<span class="quote">Open file externally `C-c C-x, C-u to choose'</span>"
            . anything-c-open-file-externally)
           ("<span class="quote">Grep File(s) `M-g s, C-u Recurse'</span>" . anything-find-files-grep)
           ("<span class="quote">Zgrep File(s) `M-g z, C-u Recurse'</span>" . anything-ff-zgrep)
           ("<span class="quote">Switch to Eshell `M-e'</span>" . anything-ff-switch-to-eshell)
           ("<span class="quote">Eshell command on file(s) `M-!, C-u run on all marked at once.'</span>"
            . anything-find-files-eshell-command-on-file)
           ("<span class="quote">Find file as root</span>" . anything-find-file-as-root)
           ("<span class="quote">Find file in hex dump</span>" . hexl-find-file)
           ("<span class="quote">Ediff File `C-='</span>" . anything-find-files-ediff-files)
           ("<span class="quote">Ediff Merge File `C-c ='</span>" . anything-find-files-ediff-merge-files)
           ("<span class="quote">Delete File(s) `M-D'</span>" . anything-delete-marked-files)
           ("<span class="quote">Copy file(s) `M-C, C-u to follow'</span>" . anything-find-files-copy)
           ("<span class="quote">Copy file(s) Async</span>" . anything-ff-copy-async)
           ("<span class="quote">Rename file(s) `M-R, C-u to follow'</span>" . anything-find-files-rename)
           ("<span class="quote">Serial rename files</span>" . anything-ff-serial-rename)
           ("<span class="quote">Serial rename by symlinking files</span>" . anything-ff-serial-rename-by-symlink)
           ("<span class="quote">Serial rename by copying files</span>" . anything-ff-serial-rename-by-copying)
           ("<span class="quote">Symlink files(s) `M-S, C-u to follow'</span>" . anything-find-files-symlink)
           ("<span class="quote">Relsymlink file(s) `C-u to follow'</span>" . anything-find-files-relsymlink)
           ("<span class="quote">Hardlink file(s) `C-u to follow'</span>" . anything-find-files-hardlink)
           ("<span class="quote">Find file other window `C-o'</span>" . find-file-other-window)
           ("<span class="quote">Switch to history `M-p'</span>" . anything-find-files-switch-to-hist)
           ("<span class="quote">Find file other frame `C-c C-o'</span>" . find-file-other-frame)
           ("<span class="quote">Print File `C-c p'</span>" . anything-ff-print))))))
<span class="linecomment">;; (anything 'anything-c-source-find-files)</span>

(defun anything-find-files-set-prompt-for-action (prompt files)
  "<span class="quote">Set prompt for action in `anything-find-files'.</span>"
  (let ((len (length files)))
    (if (&gt; len 1)
        (format "<span class="quote">%s * %d Files to: </span>" prompt len)
        (format "<span class="quote">%s %s to: </span>" prompt (car files)))))

(defun anything-find-files-do-action (action)
  "<span class="quote">Generic function for creating action from `anything-c-source-find-files'.
ACTION must be an action supported by `anything-dired-action'.</span>"
  (let* ((ifiles   (anything-marked-candidates))
         (cand     (anything-get-selection))
         (buf      anything-current-buffer)
         (prompt   (anything-find-files-set-prompt-for-action
                    (capitalize (symbol-name action)) ifiles))
         (parg     anything-current-prefix-arg)
         (dest     (anything-c-read-file-name
                    prompt
                    :preselect cand
                    :initial-input (car anything-ff-history)
                    :history (anything-find-files-history :comp-read nil)))
         (win-conf (current-window-configuration)))
    (unwind-protect
         <span class="linecomment">;; Create temporarily a dired buffer to call dired functions.</span>
         (with-current-buffer (dired anything-ff-default-directory)
           (let ((dir-buf (current-buffer)))
             (anything-dired-action
              dest :files ifiles :action action :follow parg)
             <span class="linecomment">;; If we have started in a dired buffer, don't kill it.</span>
             (unless (eq dir-buf (get-buffer buf))
               (kill-buffer dir-buf))))
      (unless parg (set-window-configuration win-conf)))))

(defun anything-find-files-copy (candidate)
  "<span class="quote">Copy files from `anything-find-files'.</span>"
  (anything-find-files-do-action 'copy))

(defun anything-find-files-rename (candidate)
  "<span class="quote">Rename files from `anything-find-files'.</span>"
  (anything-find-files-do-action 'rename))

(defun anything-find-files-symlink (candidate)
  "<span class="quote">Symlink files from `anything-find-files'.</span>"
  (anything-find-files-do-action 'symlink))

(defun anything-find-files-relsymlink (candidate)
  "<span class="quote">Relsymlink files from `anything-find-files'.</span>"
  (anything-find-files-do-action 'relsymlink))

(defun anything-find-files-hardlink (candidate)
  "<span class="quote">Hardlink files from `anything-find-files'.</span>"
  (anything-find-files-do-action 'hardlink))

(defun anything-find-files-byte-compile (candidate)
  "<span class="quote">Byte compile elisp files from `anything-find-files'.</span>"
  (let ((files    (anything-marked-candidates))
        (parg     anything-current-prefix-arg))
    (loop for fname in files
       do (byte-compile-file fname parg))))

(defun anything-find-files-load-files (candidate)
  "<span class="quote">Load elisp files from `anything-find-files'.</span>"
  (let ((files    (anything-marked-candidates)))
    (loop for fname in files
       do (load fname))))

(defun anything-find-files-ediff-files (candidate)
  "<span class="quote">Default action to ediff files in `anything-find-files'.</span>"
  (ediff-files
   candidate
   (anything-c-read-file-name
    (format "<span class="quote">Ediff `%s' With File: </span>" (file-name-nondirectory candidate)))))

(defun anything-find-files-ediff-merge-files (candidate)
  "<span class="quote">Default action to ediff merge files in `anything-find-files'.</span>"
  (ediff-merge-files
   candidate
   (anything-c-read-file-name
    (format "<span class="quote">Ediff Merge `%s' With File: </span>"
            (file-name-nondirectory candidate)))))

(defun anything-find-files-grep (candidate)
  "<span class="quote">Default action to grep files from `anything-find-files'.</span>"
  (anything-do-grep1 (anything-marked-candidates)
                     anything-current-prefix-arg))

(defun anything-ff-zgrep (candidate)
  "<span class="quote">Default action to zgrep files from `anything-find-files'.</span>"
  (let ((prefarg anything-current-prefix-arg)
        (ls      (anything-marked-candidates)))
    (anything-ff-zgrep-1 ls prefarg)))

(defun anything-ff-pdfgrep (candidate)
  "<span class="quote">Default action to pdfgrep files from `anything-find-files'.</span>"
  (let ((cands (loop for file in (anything-marked-candidates)
                  if (or (string= (file-name-extension file) "<span class="quote">pdf</span>")
                         (string= (file-name-extension file) "<span class="quote">PDF</span>"))
                  collect file))
        (anything-c-pdfgrep-default-function 'anything-c-pdfgrep-init))
    (when cands
      (anything-do-pdfgrep-1 cands))))

(defun anything-find-files-switch-to-hist (candidate)
  "<span class="quote">Switch to anything-find-files history.</span>"
  (anything-find-files t))

<span class="linecomment">;;; Asynchronous copy of files.</span>
<span class="linecomment">;;</span>
(defcustom anything-c-copy-async-prefered-emacs "<span class="quote">emacs</span>"
  "<span class="quote">Path to the emacs you want to use for copying async.
Emacs versions &lt; 24 fail to copy directory due to a bug not fixed
in `copy-directory'.</span>"
  :group 'anything-config
  :type 'string)
(defvar anything-c-copy-files-async-log-file "<span class="quote">/tmp/dired.log</span>")
(defun anything-c-copy-files-async-1 (flist dest)
  "<span class="quote">Copy a list of Files FLIST to DEST asynchronously.
It use another emacs process to do the job.
Communication with background emacs is done with temp file
`anything-c-copy-files-async-log-file'.</span>"
  (start-file-process "<span class="quote">emacs-batch</span>" nil anything-c-copy-async-prefered-emacs
                      "<span class="quote">-Q</span>" "<span class="quote">--batch</span>" "<span class="quote">--eval</span>"
                      (format "<span class="quote">(progn
  (require 'dired) (require 'cl)
  (let ((dired-recursive-copies 'always)
        failures success
        (ovw-count 0)
        (cpf-count 0))
    (dolist (f '%S)
       (condition-case err
             (let ((file-exists (file-exists-p
                                 (expand-file-name
                                  (file-name-nondirectory (directory-file-name f))
                                   (file-name-directory
                                     (file-name-as-directory \"%s\"))))))
                (dired-copy-file f \"%s\" t)
                (if file-exists
                    (progn (push (cons \"Overwriting\" f) success)
                           (incf ovw-count))
                    (push (cons \"Copying\" f) success)
                    (incf cpf-count)))
          (file-error
           (push (dired-make-relative
                   (expand-file-name
                     (file-name-nondirectory (directory-file-name f))
                     (file-name-directory \"%s\")))
                 failures))))
    (with-current-buffer (find-file-noselect \"%s\")
       (erase-buffer)
       (when failures
         (dolist (fail (reverse failures))
           (insert (concat \"Failed to copy \" fail \"\n\"))))
       (when success
         (loop for (a . s) in (reverse success) do
           (insert (concat a \" \" s  \" to %s done\n\"))))
       (and (/= cpf-count 0) (insert (concat (int-to-string cpf-count) \" File(s) Copied\n\")))
       (and (/= ovw-count 0) (insert (concat (int-to-string ovw-count) \" File(s) Overwrited\n\")))
       (and failures (insert (concat (int-to-string (length failures)) \" File(s) Failed to copy\n\")))
       (save-buffer))))</span>"
                              flist dest dest dest anything-c-copy-files-async-log-file dest)))

(defun anything-c-copy-async-with-log (flist dest)
  "<span class="quote">Copy file list FLIST to DEST showing log.
Log is send to `anything-c-copy-files-async-log-file'.
Copying is done asynchronously with `anything-c-copy-files-async-1'.</span>"
  (pop-to-buffer (find-file-noselect anything-c-copy-files-async-log-file))
  (set (make-local-variable 'auto-revert-interval) 1)
  (erase-buffer)
  (insert "<span class="quote">Wait copying files...\n</span>")
  (sit-for 0.5) (save-buffer)
  (goto-char (point-max))
  (auto-revert-mode 1)
  (anything-c-copy-files-async-1 flist dest))

(defun anything-ff-copy-async (candidate)
  "<span class="quote">Anything find files action to copy files async.
Copying is done asynchronously with `anything-c-copy-files-async-1'.</span>"
  (let ((flist (anything-marked-candidates))
        (dest  (anything-c-read-file-name
                "<span class="quote">Copy File(s) async To: </span>"
                :preselect candidate
                :initial-input (car anything-ff-history)
                :history (anything-find-files-history :comp-read nil))))
    (anything-c-copy-async-with-log flist dest)))

(defun anything-c-copy-files-async (flist dest)
  "<span class="quote">Preconfigured anything to copy file list FLIST to DEST asynchronously.</span>"
  (interactive
   (list (anything-c-read-file-name
          "<span class="quote">Copy File async: </span>"
          :marked-candidates t)
         (anything-c-read-file-name
          "<span class="quote">Copy File async To: </span>"
          :preselect candidate
          :initial-input (car anything-ff-history)
          :history (anything-find-files-history :comp-read nil))))
  (anything-c-copy-async-with-log flist dest))

(defvar eshell-command-aliases-list nil)
(declare-function eshell-read-aliases-list "<span class="quote">em-alias</span>")
(defun anything-find-files-eshell-command-on-file-1 (candidate &optional map)
  "<span class="quote">Run `eshell-command' on CANDIDATE or marked candidates possibly with an eshell alias.

Basename of CANDIDATE can be a wild-card.
If MAP is given run `eshell-command' on all marked files at once,
Otherwise, run `eshell-command' on each marked files.

If `eshell' or `eshell-command' have not been run once, or if you have no eshell aliases
`eshell-command-aliases-list' will not be loaded first time you use this.</span>"
  (when (or eshell-command-aliases-list
            (y-or-n-p "<span class="quote">Eshell is not loaded, run eshell-command without alias anyway? </span>"))
    (and eshell-command-aliases-list (eshell-read-aliases-list))
    (let ((cand-list         (anything-marked-candidates))
          (default-directory (or anything-ff-default-directory
                                 <span class="linecomment">;; If candidate is an url *-ff-default-directory is nil</span>
                                 <span class="linecomment">;; so keep value of default-directory.</span>
                                 default-directory))
          (command           (anything-comp-read
                              "<span class="quote">Command: </span>"
                              (loop for (a . c) in eshell-command-aliases-list
                                 when (string-match "<span class="quote">\\$1$</span>" (car c))
                                 collect (propertize a 'help-echo (car c)))
                              :sort 'string&lt;)))
      (if (and map (&gt; (length cand-list) 1))
          <span class="linecomment">;; Run eshell-command with ALL marked files as arguments.</span>
          (let ((mapfiles (mapconcat 'shell-quote-argument cand-list "<span class="quote"> </span>")))
            (eshell-command (format "<span class="quote">%s %s</span>" command mapfiles)))
          <span class="linecomment">;; Run eshell-command on EACH marked files.</span>
          (loop
             for i in cand-list
             for files = (if (string-match "<span class="quote">\*</span>" i)
                             <span class="linecomment">;; Assume if fname is a wildcard</span>
                             <span class="linecomment">;; cand-list have a length of 1.</span>
                             (mapconcat
                              'shell-quote-argument
                              (file-expand-wildcards i t) "<span class="quote"> </span>")
                             (format "<span class="quote">'%s'</span>" i))
             for com = (if (string-match "<span class="quote">'%s'\\|\"%s\"\\|%s</span>" command)
                           <span class="linecomment">;; This allow to enter other args AFTER filename</span>
                           <span class="linecomment">;; i.e &lt;command %s some_more_args&gt;</span>
                           (format command files)
                           (format "<span class="quote">%s %s</span>" command files))
             do (eshell-command com))))))

(defun anything-find-files-eshell-command-on-file (candidate)
  "<span class="quote">Run `eshell-command' on CANDIDATE or marked candidates.
See `anything-find-files-eshell-command-on-file-1' for more info.</span>"
  (anything-find-files-eshell-command-on-file-1
   candidate anything-current-prefix-arg))

(declare-function eshell-send-input "<span class="quote">esh-mode</span>" (&optional use-region queue-p no-newline))
(defun anything-ff-switch-to-eshell (candidate)
  "<span class="quote">Switch to eshell and cd to `anything-ff-default-directory'.</span>"
  (flet ((cd-eshell ()
           (goto-char (point-max))
           (insert
            (format "<span class="quote">cd '%s'</span>" anything-ff-default-directory))
           (eshell-send-input)))
    (if (get-buffer "<span class="quote">*eshell*</span>")
        (progn
          (switch-to-buffer "<span class="quote">*eshell*</span>")
          (cd-eshell))
        (call-interactively 'eshell)
        (cd-eshell))))

(defun anything-ff-serial-rename-action (method)
  "<span class="quote">Rename all marked files to `anything-ff-default-directory' with METHOD.
See `anything-ff-serial-rename-1'.</span>"
  (let ((cands (anything-marked-candidates))
        (name  (read-string "<span class="quote">NewName: </span>"))
        (start (read-number "<span class="quote">StartAtNumber: </span>"))
        (dir   (expand-file-name
                (anything-c-read-file-name
                 "<span class="quote">Serial Rename to directory: </span>" :initial-input
                 (expand-file-name anything-ff-default-directory)))))
    (when (y-or-n-p (format "<span class="quote">Serial Rename %s *files to `%s' with prefix `%s'? </span>"
                            (length cands) dir name))
      (anything-ff-serial-rename-1 dir cands name start :method method)
      (anything-find-files1 dir))))

(defun anything-ff-member-directory-p (file directory)
  (let ((dir-file (expand-file-name (file-name-as-directory (file-name-directory file))))
        (cur-dir  (expand-file-name (file-name-as-directory directory))))
    (string= dir-file cur-dir)))

(defun* anything-ff-serial-rename-1
    (directory collection new-name start-at-num &key (method 'rename))
  "<span class="quote">rename files in COLLECTION to DIRECTORY with the prefix name NEW-NAME.
Rename start at number START-AT-NUM - ex: prefixname-01.jpg.
METHOD can be one of rename, copy or symlink.
Files will be renamed if they are files of current directory, otherwise they
will be treated with METHOD.
Default METHOD is rename.</span>"
  <span class="linecomment">;; Maybe remove directories selected by error in collection.</span>
  (setq collection (remove-if 'file-directory-p collection))
  (flet ((symlink-file (file dest)
           (let ((flist (list file)))
             (anything-dired-action
              dest :action 'symlink :files flist))))

    (let* ((tmp-dir  (file-name-as-directory
                      (concat (file-name-as-directory directory)
                              (symbol-name (gensym "<span class="quote">tmp</span>")))))
           (fn       (case method
                       (copy    'copy-file)
                       (symlink 'symlink-file)
                       (rename  'rename-file)
                       (t (error "<span class="quote">Error: Unknow method %s</span>" method)))))
      (make-directory tmp-dir)
      (loop for i in collection
         for count from start-at-num
         for fnum = (if (&lt; count 10) "<span class="quote">0%s</span>" "<span class="quote">%s</span>")
         for nname = (concat tmp-dir new-name (format fnum count)
                             (file-name-extension i 'dot))
         do (if (anything-ff-member-directory-p i directory)
                (rename-file i nname)
                (funcall fn i nname)))
      (loop with dirlist = (directory-files
                            tmp-dir t directory-files-no-dot-files-regexp)
         for f in dirlist do
         (if (file-symlink-p f)
             (symlink-file (file-truename f)
                           (concat (file-name-as-directory directory)
                                   (anything-c-basename f)))
             (rename-file f directory)))
      (delete-directory tmp-dir t))))

(defun anything-ff-serial-rename (candidate)
  "<span class="quote">Serial rename all marked files to `anything-ff-default-directory'.
Rename only file of current directory, and symlink files coming from
other directories.
See `anything-ff-serial-rename-1'.</span>"
  (anything-ff-serial-rename-action 'rename))

(defun anything-ff-serial-rename-by-symlink (candidate)
  "<span class="quote">Serial rename all marked files to `anything-ff-default-directory'.
Rename only file of current directory, and symlink files coming from
other directories.
See `anything-ff-serial-rename-1'.</span>"
  (anything-ff-serial-rename-action 'symlink))

(defun anything-ff-serial-rename-by-copying (candidate)
  "<span class="quote">Serial rename all marked files to `anything-ff-default-directory'.
Rename only file of current directory, and copy files coming from
other directories.
See `anything-ff-serial-rename-1'.</span>"
  (anything-ff-serial-rename-action 'copy))

(defun anything-ff-help ()
  (interactive)
  (let ((anything-help-message "<span class="quote">== Anything Find Files ==\
\nSpecific commands for `anything-find-files':
\\&lt;anything-find-files-map&gt;
\\[anything-ff-run-grep]\t\t-&gt;Run Grep (C-u Recursive).
\\[anything-ff-run-pdfgrep]\t\t-&gt;Run Pdfgrep on marked files.
\\[anything-ff-run-zgrep]\t\t-&gt;Run zgrep (C-u Recursive).
\\[anything-ff-run-rename-file]\t\t-&gt;Rename File (C-u Follow).
\\[anything-ff-run-copy-file]\t\t-&gt;Copy File (C-u Follow).
\\[anything-ff-run-byte-compile-file]\t\t-&gt;Byte Compile File (C-u Load).
\\[anything-ff-run-load-file]\t\t-&gt;Load File.
\\[anything-ff-run-symlink-file]\t\t-&gt;Symlink File.
\\[anything-ff-run-delete-file]\t\t-&gt;Delete File.
\\[anything-ff-run-switch-to-eshell]\t\t-&gt;Switch to Eshell.
\\[anything-ff-run-eshell-command-on-file]\t\t-&gt;Eshell command on file (C-u Run on all marked files at once).
\\[anything-ff-run-ediff-file]\t\t-&gt;Ediff file.
\\[anything-ff-run-ediff-merge-file]\t\t-&gt;Ediff merge file.
\\[anything-ff-run-complete-fn-at-point]\t\t-&gt;Complete file name at point.
\\[anything-ff-run-switch-other-window]\t\t-&gt;Switch other window.
\\[anything-ff-run-switch-other-frame]\t\t-&gt;Switch other frame.
\\[anything-ff-run-open-file-externally]\t\t-&gt;Open file with external program (C-u to choose).
\\[anything-ff-rotate-left-persistent]\t\t-&gt;Rotate Image Left.
\\[anything-ff-rotate-right-persistent]\t\t-&gt;Rotate Image Right.
\\[anything-find-files-down-one-level]\t\t-&gt;Go down precedent directory.
\\[anything-ff-run-switch-to-history]\t\t-&gt;Switch to anything find-files history.
\\[anything-ff-properties-persistent]\t\t-&gt;Show file properties in a tooltip.
\\[anything-mark-all]\t\t-&gt;Mark all visibles candidates.
\\[anything-unmark-all]\t\t-&gt;Unmark all candidates, visibles and invisibles.
\\[anything-ff-run-gnus-attach-files]\t\t-&gt;Gnus attach files to message buffer.
\\[anything-ff-run-print-file]\t\t-&gt;Print file with default printer.
\\[anything-send-bug-report-from-anything]\t\t-&gt;Send Bug report.
\\[anything-ff-help]\t\t-&gt;Display this help info.
\n== Anything Map ==
\\{anything-map}
</span>"))
    (anything-help)))

(defcustom anything-ff-lynx-style-map t
  "<span class="quote">Use arrow keys to navigate with `anything-find-files'.</span>"
  :group 'anything-config
  :type 'boolean)

(defvar anything-find-files-map
  (let ((map (copy-keymap anything-map)))
    (define-key map (kbd "<span class="quote">M-g s</span>")   'anything-ff-run-grep)
    (define-key map (kbd "<span class="quote">M-g p</span>")   'anything-ff-run-pdfgrep)
    (define-key map (kbd "<span class="quote">M-g z</span>")   'anything-ff-run-zgrep)
    (define-key map (kbd "<span class="quote">M-R</span>")     'anything-ff-run-rename-file)
    (define-key map (kbd "<span class="quote">M-C</span>")     'anything-ff-run-copy-file)
    (define-key map (kbd "<span class="quote">M-B</span>")     'anything-ff-run-byte-compile-file)
    (define-key map (kbd "<span class="quote">M-L</span>")     'anything-ff-run-load-file)
    (define-key map (kbd "<span class="quote">M-S</span>")     'anything-ff-run-symlink-file)
    (define-key map (kbd "<span class="quote">M-D</span>")     'anything-ff-run-delete-file)
    (define-key map (kbd "<span class="quote">M-e</span>")     'anything-ff-run-switch-to-eshell)
    (define-key map (kbd "<span class="quote">&lt;M-tab&gt;</span>") 'anything-ff-run-complete-fn-at-point)
    (define-key map (kbd "<span class="quote">C-o</span>")     'anything-ff-run-switch-other-window)
    (define-key map (kbd "<span class="quote">C-c C-o</span>") 'anything-ff-run-switch-other-frame)
    (define-key map (kbd "<span class="quote">C-c C-x</span>") 'anything-ff-run-open-file-externally)
    (define-key map (kbd "<span class="quote">M-!</span>")     'anything-ff-run-eshell-command-on-file)
    (define-key map (kbd "<span class="quote">C-=</span>")     'anything-ff-run-ediff-file)
    (define-key map (kbd "<span class="quote">C-c =</span>")   'anything-ff-run-ediff-merge-file)
    (define-key map (kbd "<span class="quote">M-p</span>")     'anything-ff-run-switch-to-history)
    (define-key map (kbd "<span class="quote">M-i</span>")     'anything-ff-properties-persistent)
    (define-key map (kbd "<span class="quote">C-c ?</span>")   'anything-ff-help)
    (define-key map (kbd "<span class="quote">M-a</span>")     'anything-mark-all)
    (define-key map (kbd "<span class="quote">M-u</span>")     'anything-unmark-all)
    (define-key map (kbd "<span class="quote">C-c C-a</span>") 'anything-ff-run-gnus-attach-files)
    (define-key map (kbd "<span class="quote">C-c p</span>")   'anything-ff-run-print-file)
    <span class="linecomment">;; Next 2 have no effect if candidate is not an image file.</span>
    (define-key map (kbd "<span class="quote">M-l</span>")     'anything-ff-rotate-left-persistent)
    (define-key map (kbd "<span class="quote">M-r</span>")     'anything-ff-rotate-right-persistent)
    (define-key map (kbd "<span class="quote">C-.</span>")     'anything-find-files-down-one-level)
    (define-key map (kbd "<span class="quote">C-l</span>")     'anything-find-files-down-one-level)
    (define-key map (kbd "<span class="quote">C-h C-b</span>") 'anything-send-bug-report-from-anything)
    (when anything-ff-lynx-style-map
      (define-key map (kbd "<span class="quote">&lt;left&gt;</span>")  'anything-find-files-down-one-level)
      (define-key map (kbd "<span class="quote">&lt;right&gt;</span>") 'anything-execute-persistent-action))
    (delq nil map))
  "<span class="quote">Keymap for `anything-find-files'.</span>")

(defun anything-c-quit-and-execute-action (action)
  "<span class="quote">Quit current anything session and execute ACTION.
ACTION must be one of the actions of current source.</span>"
  (setq anything-saved-action action)
  (anything-exit-minibuffer))

<span class="linecomment">;;;###autoload</span>
(defun anything-ff-run-switch-to-history ()
  "<span class="quote">Run Switch to history action from `anything-c-source-find-files'.</span>"
  (interactive)
  (anything-c-quit-and-execute-action 'anything-find-files-switch-to-hist))

<span class="linecomment">;;;###autoload</span>
(defun anything-ff-run-grep ()
  "<span class="quote">Run Grep action from `anything-c-source-find-files'.</span>"
  (interactive)
  (anything-c-quit-and-execute-action 'anything-find-files-grep))

<span class="linecomment">;;;###autoload</span>
(defun anything-ff-run-pdfgrep ()
  "<span class="quote">Run Pdfgrep action from `anything-c-source-find-files'.</span>"
  (interactive)
  (anything-c-quit-and-execute-action 'anything-ff-pdfgrep))

<span class="linecomment">;;;###autoload</span>
(defun anything-ff-run-zgrep ()
  "<span class="quote">Run Grep action from `anything-c-source-find-files'.</span>"
  (interactive)
  (anything-c-quit-and-execute-action 'anything-ff-zgrep))

<span class="linecomment">;;;###autoload</span>
(defun anything-ff-run-copy-file ()
  "<span class="quote">Run Copy file action from `anything-c-source-find-files'.</span>"
  (interactive)
  (anything-c-quit-and-execute-action 'anything-find-files-copy))

<span class="linecomment">;;;###autoload</span>
(defun anything-ff-run-rename-file ()
  "<span class="quote">Run Rename file action from `anything-c-source-find-files'.</span>"
  (interactive)
  (anything-c-quit-and-execute-action 'anything-find-files-rename))

<span class="linecomment">;;;###autoload</span>
(defun anything-ff-run-byte-compile-file ()
  "<span class="quote">Run Byte compile file action from `anything-c-source-find-files'.</span>"
  (interactive)
  (anything-c-quit-and-execute-action 'anything-find-files-byte-compile))

<span class="linecomment">;;;###autoload</span>
(defun anything-ff-run-load-file ()
  "<span class="quote">Run Load file action from `anything-c-source-find-files'.</span>"
  (interactive)
  (anything-c-quit-and-execute-action 'anything-find-files-load-files))

<span class="linecomment">;;;###autoload</span>
(defun anything-ff-run-eshell-command-on-file ()
  "<span class="quote">Run eshell command on file action from `anything-c-source-find-files'.</span>"
  (interactive)
  (anything-c-quit-and-execute-action 'anything-find-files-eshell-command-on-file))

<span class="linecomment">;;;###autoload</span>
(defun anything-ff-run-ediff-file ()
  "<span class="quote">Run Ediff file action from `anything-c-source-find-files'.</span>"
  (interactive)
  (anything-c-quit-and-execute-action 'anything-find-files-ediff-files))

<span class="linecomment">;;;###autoload</span>
(defun anything-ff-run-ediff-merge-file ()
  "<span class="quote">Run Ediff merge file action from `anything-c-source-find-files'.</span>"
  (interactive)
  (anything-c-quit-and-execute-action 'anything-find-files-ediff-merge-files))

<span class="linecomment">;;;###autoload</span>
(defun anything-ff-run-symlink-file ()
  "<span class="quote">Run Symlink file action from `anything-c-source-find-files'.</span>"
  (interactive)
  (anything-c-quit-and-execute-action 'anything-find-files-symlink))

<span class="linecomment">;;;###autoload</span>
(defun anything-ff-run-delete-file ()
  "<span class="quote">Run Delete file action from `anything-c-source-find-files'.</span>"
  (interactive)
  (anything-c-quit-and-execute-action 'anything-delete-marked-files))

<span class="linecomment">;;;###autoload</span>
(defun anything-ff-run-complete-fn-at-point ()
  "<span class="quote">Run complete file name action from `anything-c-source-find-files'.</span>"
  (interactive)
  (anything-c-quit-and-execute-action
   'anything-c-insert-file-name-completion-at-point))

<span class="linecomment">;;;###autoload</span>
(defun anything-ff-run-switch-to-eshell ()
  "<span class="quote">Run switch to eshell action from `anything-c-source-find-files'.</span>"
  (interactive)
  (anything-c-quit-and-execute-action 'anything-ff-switch-to-eshell))

<span class="linecomment">;;;###autoload</span>
(defun anything-ff-run-switch-other-window ()
  "<span class="quote">Run switch to other window action from `anything-c-source-find-files'.</span>"
  (interactive)
  (anything-c-quit-and-execute-action 'find-file-other-window))

<span class="linecomment">;;;###autoload</span>
(defun anything-ff-run-switch-other-frame ()
  "<span class="quote">Run switch to other frame action from `anything-c-source-find-files'.</span>"
  (interactive)
  (anything-c-quit-and-execute-action 'find-file-other-frame))

<span class="linecomment">;;;###autoload</span>
(defun anything-ff-run-open-file-externally ()
  "<span class="quote">Run open file externally command action from `anything-c-source-find-files'.</span>"
  (interactive)
  (anything-c-quit-and-execute-action 'anything-c-open-file-externally))

<span class="linecomment">;;;###autoload</span>
(defun anything-ff-run-gnus-attach-files ()
  "<span class="quote">Run gnus attach files command action from `anything-c-source-find-files'.</span>"
  (interactive)
  (anything-c-quit-and-execute-action 'anything-ff-gnus-attach-files))

(defun anything-ff-print (candidate)
  "<span class="quote">Print marked files.
Uses the shell command coming from variables `lpr-command' and
`lpr-switches' as default.
Same as `dired-do-print' but for anything.</span>"
  (let* ((file-list (anything-marked-candidates))
	 (command (read-string
		   "<span class="quote">Print %s with: </span>"
 		   (mapconcat 'identity
			      (cons lpr-command
				    (if (stringp lpr-switches)
					(list lpr-switches)
                                        lpr-switches))
			      "<span class="quote"> </span>")))
         (file-args (mapconcat #'(lambda (x)
                                   (format "<span class="quote">'%s'</span>" x))
                               file-list "<span class="quote"> </span>"))
         (cmd-line (concat command "<span class="quote"> </span>" file-args)))
    (start-process-shell-command "<span class="quote">anything-print</span>" nil cmd-line)))

<span class="linecomment">;;;###autoload</span>
(defun anything-ff-run-print-file ()
  "<span class="quote">Run Print file action from `anything-c-source-find-files'.</span>"
  (interactive)
  (anything-c-quit-and-execute-action 'anything-ff-print))

(defun* anything-reduce-file-name (fname level &key unix-close expand)
    "<span class="quote">Reduce FNAME by LEVEL from end or beginning depending LEVEL value.
If LEVEL is positive reduce from end else from beginning.
If UNIX-CLOSE is non--nil close filename with /.
If EXPAND is non--nil expand-file-name.</span>"
  (let* ((exp-fname  (expand-file-name fname))
         (fname-list (split-string (if (or (string= fname "<span class="quote">~/</span>") expand)
                                       exp-fname fname) "<span class="quote">/</span>" t))
         (len        (length fname-list))
         (pop-list   (if (&lt; level 0)
                         (subseq fname-list (* level -1))
                         (subseq fname-list 0 (- len level))))
         (result     (mapconcat 'identity pop-list "<span class="quote">/</span>"))
         (empty      (string= result "<span class="quote"></span>")))
    (when unix-close (setq result (concat result "<span class="quote">/</span>")))
    (if (string-match "<span class="quote">^~</span>" result)
        (if (string= result "<span class="quote">~/</span>") "<span class="quote">~/</span>" result)
        (if (&lt; level 0)
            (if empty "<span class="quote">../</span>" (concat "<span class="quote">../</span>" result))
            (cond ((eq system-type 'windows-nt)
                   (if empty "<span class="quote">c:/</span>" result))
                  (empty "<span class="quote">/</span>")
                  (t
                   (concat "<span class="quote">/</span>" result)))))))

(defun anything-file-completion-source-p ()
  "<span class="quote">Test if current source is a dired or find-files source.</span>"
  (let ((ff-sources '("<span class="quote">Find Files</span>" "<span class="quote">Copy Files</span>"
                      "<span class="quote">Read File Name History</span>"
                      "<span class="quote">Rename Files</span>" "<span class="quote">Symlink Files</span>"
                      "<span class="quote">Hardlink Files</span>" "<span class="quote">Write File</span>"
                      "<span class="quote">Insert File</span>" "<span class="quote">Read file name</span>"))
        (cur-source (cdr (assoc 'name (anything-get-current-source)))))
    (loop for i in ff-sources
       thereis (string= cur-source (concat i anything-c-find-files-doc-header)))))

<span class="linecomment">;; Internal.</span>
(defvar anything-ff-last-expanded nil
  "<span class="quote">Store last expanded directory or file in `anything-find-files'.</span>")

(defun anything-find-files-down-one-level (arg)
  "<span class="quote">Go down one level like unix command `cd ..'.
If prefix numeric arg is given go ARG level down.</span>"
  (interactive "<span class="quote">p</span>")
  (with-anything-window
    (setq anything-follow-mode nil))
  <span class="linecomment">;; When going to precedent level we want to be at the line</span>
  <span class="linecomment">;; corresponding to actual directory, so store this info</span>
  <span class="linecomment">;; in `anything-ff-last-expanded'.</span>
  (if (and (not (file-directory-p anything-pattern))
           (file-exists-p anything-pattern))
      (setq anything-ff-last-expanded anything-pattern)
      (setq anything-ff-last-expanded anything-ff-default-directory))
  (when (anything-file-completion-source-p)
    (let ((new-pattern (anything-reduce-file-name anything-pattern arg
                                                  :unix-close t :expand t)))
      (with-selected-window (minibuffer-window)
        (delete-minibuffer-contents)
        (insert new-pattern)))))

(defun anything-ff-retrieve-last-expanded ()
  "<span class="quote">Move overlay to last visited directory `anything-ff-last-expanded'.
This happen after using `anything-find-files-down-one-level',
or hitting C-z on \"..\".</span>"
  (when (and anything-ff-last-expanded
             (anything-file-completion-source-p))
    (let ((dirname (directory-file-name anything-ff-last-expanded)))
      (with-anything-window
        (when (or (re-search-forward (concat dirname "<span class="quote">$</span>") nil t)
                  (re-search-forward
                   (concat anything-ff-last-expanded "<span class="quote">$</span>") nil t))
          (forward-line 0)
          (anything-mark-current-line)))
      (setq anything-ff-last-expanded nil))))
(add-hook 'anything-after-update-hook 'anything-ff-retrieve-last-expanded)

(defun anything-c-point-file-in-dired (file)
  "<span class="quote">Put point on filename FILE in dired buffer.</span>"
  (dired (file-name-directory file))
  (dired-goto-file file))

(defun anything-create-tramp-name (fname)
  "<span class="quote">Build filename for `anything-pattern' like /su:: or /sudo::.</span>"
  (apply #'tramp-make-tramp-file-name
         (loop with v = (tramp-dissect-file-name fname)
            for i across v collect i)))

(defun anything-ff-set-pattern (pattern)
  (let ((methods (mapcar 'car tramp-methods))
        (reg "<span class="quote">\\`/\\([^[/:]+\\|[^/]+]\\):.*:</span>")
        cur-method tramp-name)
    (cond ((string= pattern "<span class="quote"></span>") "<span class="quote"></span>")
          ((string-match "<span class="quote">^~</span>" pattern)
           (replace-match (getenv "<span class="quote">HOME</span>") nil t pattern))
          <span class="linecomment">;; Match "/method:maybe_hostname:"</span>
          ((and (string-match reg pattern)
               (setq cur-method (match-string 1 pattern))
               (member cur-method methods))
          (setq tramp-name (anything-create-tramp-name
                            (match-string 0 pattern)))
          (replace-match tramp-name nil t pattern))
          <span class="linecomment">;; Match "/hostname:"</span>
          ((and (string-match  tramp-file-name-regexp pattern)
                (setq cur-method (match-string 1 pattern))
                (and cur-method (not (member cur-method methods))))
           (setq tramp-name (anything-create-tramp-name
                             (match-string 0 pattern)))
           (replace-match tramp-name nil t pattern))
          <span class="linecomment">;; Match "/method:" in this case don't try to connect.</span>
          ((and (not (string-match reg pattern))
                (string-match  tramp-file-name-regexp pattern)
                (member (match-string 1 pattern) methods))
           "<span class="quote">Invalid tramp file name</span>") <span class="linecomment">; Write in anything-buffer.</span>
          <span class="linecomment">;; PATTERN is a directory, end it with "/".</span>
          <span class="linecomment">;; This will make PATTERN not ending yet with "/"</span>
          <span class="linecomment">;; candidate for `anything-ff-default-directory',</span>
          <span class="linecomment">;; allowing `anything-ff-retrieve-last-expanded' to retrieve it</span>
          <span class="linecomment">;; when descending level.</span>
          ((file-directory-p pattern)
           (file-name-as-directory pattern))
          <span class="linecomment">;; Return PATTERN unchanged.</span>
          (t pattern))))

<span class="linecomment">;; Internal.</span>
(defvar anything-ff-default-directory nil)
(defvar anything-ff-history nil)

(defcustom anything-ff-history-max-length 100
  "<span class="quote">*Number of elements shown in `anything-find-files' history.</span>"
  :group 'anything-config
  :type 'integer)

(defun anything-find-files-get-candidates ()
  "<span class="quote">Create candidate list for `anything-c-source-find-files'.</span>"
  (let* ((path          (anything-ff-set-pattern anything-pattern))
         (path-name-dir (file-name-directory path))
         (tramp-verbose anything-tramp-verbose)) <span class="linecomment">; No tramp message when 0.</span>
    (set-text-properties 0 (length path) nil path)
    (if (member 'anything-compile-source--match-plugin
                anything-compile-source-functions)
        (setq anything-pattern path)
        (setq anything-pattern (replace-regexp-in-string "<span class="quote"> </span>" "<span class="quote">.*</span>" path)))
    (setq anything-ff-default-directory
          (if (string= anything-pattern "<span class="quote"></span>")
              (if (eq system-type 'windows-nt) "<span class="quote">c:/</span>" "<span class="quote">/</span>")
              (unless (string-match ffap-url-regexp path)
                path-name-dir)))
    (cond ((or (string= path "<span class="quote">Invalid tramp file name</span>")
               (file-regular-p path)
               (and (not (file-exists-p path)) (string-match "<span class="quote">/$</span>" path))
               (and ffap-url-regexp (string-match ffap-url-regexp path)))
           (list path))
          ((string= path "<span class="quote"></span>") (directory-files "<span class="quote">/</span>" t))
          ((and (file-directory-p path) (not (file-readable-p path)))
           (list (format "<span class="quote">Opening directory: access denied, `%s'</span>" path)))
          ((file-directory-p path) (directory-files path t))
          (t
           (append
            (list path)
            (directory-files (file-name-directory path) t))))))

(defun anything-ff-save-history ()
  "<span class="quote">Store the last value of `anything-ff-default-directory' \
in `anything-ff-history'.</span>"
  (when anything-ff-default-directory
    (push anything-ff-default-directory anything-ff-history)))
(add-hook 'anything-cleanup-hook 'anything-ff-save-history)

(defun anything-ff-valid-symlink-p (file)
  (file-exists-p (file-truename file)))

(defun anything-ff-properties (candidate)
  "<span class="quote">Show file properties of CANDIDATE in a tooltip or message.</span>"
  (let ((type       (anything-ff-attributes candidate :type t))
        (dired-line (anything-ff-attributes candidate :dired t :human-size t)))
    (if (window-system)
        (tooltip-show
         (concat
          (anything-c-basename candidate) "<span class="quote">: \n</span>"
          "<span class="quote">Type: </span>" type "<span class="quote">\n</span>"
          (when (string= type "<span class="quote">symlink</span>")
            (format "<span class="quote">True name: '%s'\n</span>"
                    (cond ((string-match "<span class="quote">^\.#</span>" (anything-c-basename candidate))
                           "<span class="quote">Autosave symlink</span>")
                          ((anything-ff-valid-symlink-p candidate)
                           (file-truename candidate))
                          (t "<span class="quote">Invalid Symlink</span>"))))
          dired-line))
        (message dired-line) (sit-for 5))))

(defun anything-ff-properties-persistent ()
  "<span class="quote">Show properties without quitting anything.</span>"
  (interactive)
  (anything-execute-persistent-action 'properties-action))

(defcustom anything-ff-default-kbsize 1024.0
  "<span class="quote">Default Kbsize to use for showing files size.
It is a float, usually 1024.0 but could be 1000.0 on some systems.</span>"
  :group 'anything-config
  :type 'float)

(defun anything-ff-human-size (size)
  "<span class="quote">Return a string showing SIZE of a file in human readable form.
SIZE can be an integer or a float depending it's value.
`file-attributes' will take care of that to avoid overflow error.
KBSIZE if a floating point number, default value is 1024.0.</span>"
  (let ((M (cons "<span class="quote">M</span>" (/ size (expt anything-ff-default-kbsize 2))))
        (G (cons "<span class="quote">G</span>" (/ size (expt anything-ff-default-kbsize 3))))
        (K (cons "<span class="quote">K</span>" (/ size anything-ff-default-kbsize)))
        (B (cons "<span class="quote">B</span>" size)))
    (loop with result = B
       for (a . b) in
       (loop for (x . y) in (list M G K B)
          unless (&lt; y 1) collect (cons x y))
       when (&lt; b (cdr result)) do (setq result (cons a b))
       finally return (if (string= (car result) "<span class="quote">B</span>")
                          (format "<span class="quote">%s</span>" size)
                          (format "<span class="quote">%.1f%s</span>" (cdr result) (car result))))))

(defun* anything-ff-attributes
    (file &key type links uid gid access-time modif-time
          status size mode gid-change inode device-num dired human-size)
  "<span class="quote">Easy interface for `file-attributes'.</span>"
  (let ((all (destructuring-bind
                   (type links uid gid access-time modif-time
                         status size mode gid-change inode device-num)
                 (file-attributes file 'string)
               (list :type        type
                     :links       links
                     :uid         uid
                     :gid         gid
                     :access-time access-time
                     :modif-time  modif-time
                     :status      status
                     :size        size
                     :mode        mode
                     :gid-change  gid-change
                     :inode       inode
                     :device-num  device-num))))
    (cond (type
           (let ((result (getf all :type)))
             (cond ((stringp result)
                    "<span class="quote">symlink</span>")
                   (result "<span class="quote">directory</span>")
                   (t "<span class="quote">file</span>"))))
          (links (getf all :links))
          (uid   (getf all :uid))
          (gid   (getf all :gid))
          (access-time
           (format-time-string "<span class="quote">%Y-%m-%d %R</span>" (getf all :access-time)))
          (modif-time
           (format-time-string "<span class="quote">%Y-%m-%d %R</span>" (getf all :modif-time)))
          (status
           (format-time-string "<span class="quote">%Y-%m-%d %R</span>" (getf all :status)))
          (size (if human-size (anything-ff-human-size (getf all :size))
                    (getf all :size)))
          (mode (getf all :mode))
          (gid-change (getf all :gid-change))
          (inode (getf all :inode))
          (device-num (getf all :device-num))
          (dired
           (concat
            (getf all :mode) "<span class="quote"> </span>"
            (number-to-string (getf all :links)) "<span class="quote"> </span>"
            (getf all :uid) "<span class="quote">:</span>"
            (getf all :gid) "<span class="quote"> </span>"
            (if human-size (anything-ff-human-size (getf all :size))
                (int-to-string (getf all :size))) "<span class="quote"> </span>"
            (format-time-string "<span class="quote">%Y-%m-%d %R</span>" (getf all :modif-time))))
          (t all))))

(defun anything-c-prefix-filename (fname &optional image)
  "<span class="quote">Return fname FNAME prefixed with icon IMAGE.</span>"
  (let* ((img-name   (and image (expand-file-name
                                 image anything-c-find-files-icons-directory)))
         (img        (and image (create-image img-name)))
         (prefix-img (and image (propertize "<span class="quote"> </span>" 'display img)))
         (prefix-new (propertize
                      "<span class="quote"> </span>" 'display
                      (propertize "<span class="quote">[?]</span>" 'face 'anything-ff-prefix)))
         (prefix-url (propertize
                      "<span class="quote"> </span>" 'display
                      (propertize "<span class="quote">[@]</span>" 'face 'anything-ff-prefix))))
    (cond ((or (file-exists-p fname)
               (file-symlink-p fname))
           (if image (concat prefix-img fname) fname))
          ((string-match ffap-url-regexp fname) (concat prefix-url "<span class="quote"> </span>" fname))
          (t (concat prefix-new "<span class="quote"> </span>" fname)))))

(defun anything-c-find-files-transformer (files sources)
  "<span class="quote">Selector of transformer to use for `anything-c-source-find-files'.</span>"
  (if (and (window-system) anything-c-find-files-show-icons)
      (anything-c-highlight-ffiles1 files sources)
      (anything-c-highlight-ffiles files sources)))

(defun anything-c-highlight-ffiles (files sources)
  "<span class="quote">Candidate transformer for `anything-c-source-find-files' without icons.</span>"
  (loop for i in files collect
       (cond ((and (file-symlink-p i) (not (anything-ff-valid-symlink-p i))
                   (not (string-match "<span class="quote">^\.#</span>" (anything-c-basename i))))
              (cons (anything-c-prefix-filename
                     (propertize i 'face 'anything-ff-invalid-symlink))
                    i))
             ((file-symlink-p i)
              (cons (anything-c-prefix-filename
                     (propertize i 'face 'anything-ff-symlink))
                    i))
             ((file-directory-p i)
              (cons (anything-c-prefix-filename
                     (propertize i 'face 'anything-ff-directory))
                    i))
             ((file-executable-p i)
              (cons (anything-c-prefix-filename
                     (propertize i 'face 'anything-ff-executable))
                    i))
             (t (cons (anything-c-prefix-filename
                       (propertize i 'face 'anything-ff-file))
                      i)))))

(defun anything-c-highlight-ffiles1 (files sources)
  "<span class="quote">Candidate transformer for `anything-c-source-find-files' that show icons.</span>"
  (loop for i in files
     for af = (file-name-nondirectory i)
     collect (cond ( <span class="linecomment">;; Files.</span>
                    (eq nil (car (file-attributes i)))
                    (let ((face (if (file-executable-p i)
                                    'anything-ff-executable
                                    'anything-ff-file)))
                      (cons (anything-c-prefix-filename
                             (propertize i 'face face) "<span class="quote">leaf.xpm</span>")
                            i)))
                   ( <span class="linecomment">;; Empty directories.</span>
                    (and (eq t (car (file-attributes i)))
                         <span class="linecomment">;; Be sure to have permission to list content.</span>
                         (file-readable-p i)
                         (eq 0 (length
                                (directory-files
                                 i nil directory-files-no-dot-files-regexp t))))
                    (cons (anything-c-prefix-filename
                           (propertize
                            i 'face 'anything-ff-directory)
                           "<span class="quote">empty.xpm</span>")
                          i))
                   ( <span class="linecomment">;; Open directories.</span>
                    (and (eq t (car (file-attributes i))) (get-buffer af))
                    (cons (anything-c-prefix-filename
                           (propertize
                            i 'face 'anything-ff-directory)
                           "<span class="quote">open.xpm</span>")
                          i))
                   ( <span class="linecomment">;; Closed directories.</span>
                    (eq t (car (file-attributes i)))
                    (cons (anything-c-prefix-filename
                           (propertize
                            i 'face 'anything-ff-directory)
                           "<span class="quote">close.xpm</span>")
                          i))
                   ( <span class="linecomment">;; Open Symlinks directories.</span>
                    (and (stringp (car (file-attributes i)))
                         (file-directory-p i) (get-buffer af))
                    (cons (anything-c-prefix-filename
                           (propertize i 'face 'anything-ff-symlink))
                          i))
                   ( <span class="linecomment">;; Closed Symlinks directories.</span>
                    (and (stringp (car (file-attributes i)))
                         (file-directory-p i))
                    (cons (anything-c-prefix-filename
                           (propertize i 'face 'anything-ff-symlink))
                          i))
                   ( <span class="linecomment">;; Invalid Symlinks </span>
                    (and (stringp (car (file-attributes i)))
                         (not (anything-ff-valid-symlink-p i))
                         (not (string-match "<span class="quote">^\.#</span>" (anything-c-basename i))))
                    (cons (anything-c-prefix-filename
                           (propertize i 'face 'anything-ff-invalid-symlink)
                           "<span class="quote">leaf.xpm</span>")
                          i))
                   ( <span class="linecomment">;; Files symlinks.</span>
                    (stringp (car (file-attributes i)))
                    (cons (anything-c-prefix-filename
                           (propertize i 'face 'anything-ff-symlink)
                           "<span class="quote">leaf.xpm</span>")
                          i)))))

(defun anything-find-files-action-transformer (actions candidate)
  "<span class="quote">Action transformer for `anything-c-source-find-files'.</span>"
  (cond ((with-current-buffer anything-current-buffer
           (eq major-mode 'message-mode))
         (append (subseq actions 0 4)
                 '(("<span class="quote">Gnus attach file(s)</span>" . anything-ff-gnus-attach-files))
                 (subseq actions 4)))
        ((string-match (image-file-name-regexp) candidate)
         (append (subseq actions 0 4)
                 '(("<span class="quote">Rotate image right `M-r'</span>" . anything-ff-rotate-image-right)
                   ("<span class="quote">Rotate image left `M-l'</span>" . anything-ff-rotate-image-left))
                 (subseq actions 4)))
        ((string-match "<span class="quote">\.el$</span>" (anything-aif (anything-marked-candidates)
                                   (car it) candidate))
         (append (subseq actions 0 4)
                 '(("<span class="quote">Byte compile lisp file(s) `M-B, C-u to load'</span>"
                    . anything-find-files-byte-compile)
                   ("<span class="quote">Load File(s) `M-L'</span>" . anything-find-files-load-files))
                 (subseq actions 4)))
        ((and (string-match "<span class="quote">\.html?$</span>" candidate)
              (file-exists-p candidate))
         (append (subseq actions 0 4)
                 '(("<span class="quote">Browse url file</span>" . browse-url-of-file))
                 (subseq actions 5)))
        ((or (string= (file-name-extension candidate) "<span class="quote">pdf</span>")
             (string= (file-name-extension candidate) "<span class="quote">PDF</span>"))
         (append (subseq actions 0 4)
                 '(("<span class="quote">Pdfgrep File(s)</span>" . anything-ff-pdfgrep))
                 (subseq actions 5)))
        (t actions)))

(defun anything-ff-gnus-attach-files (candidate)
  "<span class="quote">Run `gnus-dired-attach' on `anything-marked-candidates' or CANDIDATE.</span>"
  (let ((flist (anything-marked-candidates)))
    (gnus-dired-attach flist)))

(defun anything-ff-rotate-current-image1 (file &optional num-arg)
  "<span class="quote">Rotate current image at NUM-ARG degrees.
This is a destructive operation on FILE made by external tool mogrify.</span>"
  (setq file (file-truename file)) <span class="linecomment">; For symlinked images.</span>
  <span class="linecomment">;; When FILE is not an image-file, do nothing.</span>
  (when (string-match (image-file-name-regexp) file)
    (if (executable-find "<span class="quote">mogrify</span>")
        (progn
          (shell-command (format "<span class="quote">mogrify -rotate %s %s</span>" (or num-arg 90) file))
          (when (buffer-live-p image-dired-display-image-buffer)
            (kill-buffer image-dired-display-image-buffer))
          (image-dired-display-image file)
          (message nil)
          (display-buffer (get-buffer image-dired-display-image-buffer)))
        (error "<span class="quote">mogrify not found</span>"))))

(defun anything-ff-rotate-image-left (candidate)
  "<span class="quote">Rotate image file CANDIDATE left.
This affect directly file CANDIDATE.</span>"
  (anything-ff-rotate-current-image1 candidate -90))

(defun anything-ff-rotate-image-right (candidate)
  "<span class="quote">Rotate image file CANDIDATE right.
This affect directly file CANDIDATE.</span>"
  (anything-ff-rotate-current-image1 candidate))

(defun anything-ff-rotate-left-persistent ()
  "<span class="quote">Rotate image left without quitting anything.</span>"
  (interactive)
  (anything-execute-persistent-action 'image-action1))

(defun anything-ff-rotate-right-persistent ()
  "<span class="quote">Rotate image right without quitting anything.</span>"
  (interactive)
  (anything-execute-persistent-action 'image-action2))

(defcustom anything-ff-exif-data-program "<span class="quote">exiftran</span>"
  "<span class="quote">*Program used to extract exif data of an image file.</span>"
  :group 'anything-config
  :type 'string)

(defcustom anything-ff-exif-data-program-args "<span class="quote">-d</span>"
  "<span class="quote">*Arguments used for `anything-ff-exif-data-program'.</span>"
  :group 'anything-config
  :type 'string)

(defun anything-ff-exif-data (candidate)
  "<span class="quote">Extract exif data from file CANDIDATE using `anything-ff-exif-data-program'.</span>"
  (if (and anything-ff-exif-data-program
           (executable-find anything-ff-exif-data-program))
      (shell-command-to-string (format "<span class="quote">%s %s %s</span>"
                                       anything-ff-exif-data-program
                                       anything-ff-exif-data-program-args
                                       candidate))
      (format "<span class="quote">No program %s found to extract exif</span>"
              anything-ff-exif-data-program)))

(defun anything-find-files-persistent-action (candidate)
  "<span class="quote">Open subtree CANDIDATE without quitting anything.
If CANDIDATE is not a directory expand CANDIDATE filename.
If CANDIDATE is alone, open file CANDIDATE filename.
That's mean:
First hit on C-z expand CANDIDATE second hit open file.
If a prefix arg is given or `anything-follow-mode' is on open file.</span>"
  (let ((follow        (buffer-local-value
                        'anything-follow-mode
                        (get-buffer-create anything-buffer)))
        (new-pattern   (anything-get-selection))
        (num-lines-buf (with-current-buffer anything-buffer
                         (count-lines (point-min) (point-max)))))
    (flet ((insert-in-minibuffer (fname)
             (with-selected-window (minibuffer-window)
               (unless follow
                 (delete-minibuffer-contents)
                 (set-text-properties 0 (length fname) nil fname)
                 (insert fname)))))
      (cond (<span class="linecomment">;; A symlink directory, expand it's truename.</span>
             (and (file-directory-p candidate) (file-symlink-p candidate))
             (insert-in-minibuffer (file-name-as-directory
                                    (file-truename
                                     (expand-file-name candidate)))))
            <span class="linecomment">;; A directory, open it.</span>
            ((file-directory-p candidate)
             (when (string= (anything-c-basename candidate) "<span class="quote">..</span>")
               (setq anything-ff-last-expanded anything-ff-default-directory))
             (insert-in-minibuffer (file-name-as-directory
                                    (expand-file-name candidate))))
            <span class="linecomment">;; A symlink file, expand to it's true name. (first hit)</span>
            ((and (file-symlink-p candidate) (not current-prefix-arg) (not follow))
             (insert-in-minibuffer (file-truename candidate)))
            <span class="linecomment">;; A regular file, expand it, (first hit)</span>
            ((and (&gt;= num-lines-buf 3) (not current-prefix-arg) (not follow))
             (insert-in-minibuffer new-pattern))
            <span class="linecomment">;; An image file and it is the second hit on C-z,</span>
            <span class="linecomment">;; show the file in `image-dired'.</span>
            ((string-match (image-file-name-regexp) candidate)
             (when (buffer-live-p image-dired-display-image-buffer)
               (kill-buffer image-dired-display-image-buffer))
             (image-dired-display-image candidate)
             (message nil)
             (display-buffer image-dired-display-image-buffer)
             (with-current-buffer image-dired-display-image-buffer
               (let ((exif-data (anything-ff-exif-data candidate)))
                 (image-dired-update-property 'help-echo exif-data))))
            <span class="linecomment">;; Allow browsing archive on avfs fs.</span>
            <span class="linecomment">;; Assume volume is already mounted with mountavfs.</span>
            ((and anything-ff-avfs-directory
                  (string-match
                   (regexp-quote (expand-file-name anything-ff-avfs-directory))
                   (file-name-directory candidate))
                  (anything-ff-file-compressed-p candidate))
             (insert-in-minibuffer (concat candidate "<span class="quote">#</span>")))
            <span class="linecomment">;; On second hit we open file.</span>
            (t (find-file candidate))))))

(defvar anything-ff-avfs-directory nil
  "<span class="quote">*The default avfs directory, usually '.avfs'.
When this is set you will be able to expand archive filenames with `C-z'
inside an avfs directory mounted with mountavfs.
See &lt;http://sourceforge.net/projects/avf/&gt;.</span>")
(defvar anything-ff-file-compressed-list '("<span class="quote">gz</span>" "<span class="quote">bz2</span>" "<span class="quote">zip</span>" "<span class="quote">7z</span>")
  "<span class="quote">*Minimal list of compressed files extension.</span>")
(defun anything-ff-file-compressed-p (candidate)
  "<span class="quote">Whether CANDIDATE is a compressed file or not.</span>"
  (member (file-name-extension candidate)
          anything-ff-file-compressed-list))

(defun anything-c-insert-file-name-completion-at-point (candidate)
  "<span class="quote">Insert file name completion at point.</span>"
  (if buffer-read-only
      (error "<span class="quote">Error: Buffer `%s' is read-only</span>" (buffer-name))
      (let* ((end         (point))
             (guess       (thing-at-point 'filename))
             (full-path-p (or (string-match (concat "<span class="quote">^</span>" (getenv "<span class="quote">HOME</span>")) guess)
                              (string-match "<span class="quote">^[^\~]</span>" guess))))
        (set-text-properties 0 (length candidate) nil candidate)
        (if (and guess (not (string= guess "<span class="quote"></span>")) (string-match "<span class="quote">^~\\|/.*</span>" guess))
            (progn
              (search-backward guess (- (point) (length guess)))
              (delete-region (point) end)
              (if full-path-p
                  (insert (expand-file-name candidate))
                  (insert (abbreviate-file-name candidate))))
            (error "<span class="quote">Aborting completion: No valid file name at point</span>")))))

(defun* anything-find-files-history (&key (comp-read t))
  "<span class="quote">The `anything-find-files' history.
Show the first `anything-ff-history-max-length' elements of `anything-ff-history'
in an `anything-comp-read'.</span>"
  (let ((history (when anything-ff-history
                   (loop with dup for i in anything-ff-history
                      <span class="linecomment">;; Remove duplicate and not existing files.</span>
                      <span class="linecomment">;; Keep remote files.</span>
                      unless (or (member i dup)
                                 (and (not (file-remote-p i))
                                      (not (file-exists-p i))))
                      collect i into dup
                      finally return dup)))) <span class="linecomment">; Remove dups.</span>
    (when history
      (setq anything-ff-history
            (if (&gt;= (length history) anything-ff-history-max-length)
                (subseq history 0 anything-ff-history-max-length)
                history))
      (if comp-read
          (anything-comp-read
           "<span class="quote">Switch to Directory: </span>"
           anything-ff-history
           :name "<span class="quote">Anything Find Files History</span>"
           :must-match t)
          anything-ff-history))))

<span class="linecomment">;;;###autoload</span>
(defun anything-find-files (arg)
  "<span class="quote">Preconfigured `anything' for anything implementation of `find-file'.
Called with a prefix arg show history if some.
Don't call it from programs, use `anything-find-files1' instead.
This is the starting point for nearly all actions you can do on files.</span>"
  (interactive "<span class="quote">P</span>")
  (let ((any-input (if (and arg anything-ff-history)
                       (anything-find-files-history)
                       (anything-find-files-initial-input))))
    (when (and (eq major-mode 'org-agenda-mode)
               org-directory
               (not any-input))
      (setq any-input (expand-file-name org-directory)))
    (if any-input
        (anything-find-files1 any-input)
        (setq any-input (expand-file-name (anything-c-current-directory)))
        (anything-find-files1 any-input (buffer-file-name (current-buffer))))))


(defun anything-find-files1 (fname &optional preselect)
  "<span class="quote">Find FNAME with `anything' completion.
Like `find-file' but with `anything' support.
Use it for non--interactive calls of `anything-find-files'.</span>"
  (when (get-buffer anything-action-buffer)
    (kill-buffer anything-action-buffer))
  (let ((anything-mp-highlight-delay nil))
    (anything :sources 'anything-c-source-find-files
              :input fname
              :preselect preselect
              :keymap anything-find-files-map
              :prompt "<span class="quote">Find Files or Url: </span>"
              :buffer "<span class="quote">*Anything Find Files*</span>")))


(defun anything-find-files-initial-input (&optional input)
  "<span class="quote">Return INPUT if present, otherwise try to guess it.</span>"
  (or (and input (expand-file-name input))
      (anything-find-files-input
       (ffap-guesser)
       (thing-at-point 'filename))))

(defun anything-find-files-input (fap tap)
  "<span class="quote">Default input of `anything-find-files'.</span>"
  (let* ((def-dir (anything-c-current-directory))
         (lib     (anything-find-library-at-point))
         (url     (anything-ff-find-url-at-point))
         (file-p  (and fap (not (string= fap "<span class="quote"></span>"))
                       (file-exists-p fap)
                       tap (not (string= tap "<span class="quote"></span>"))
                       (file-exists-p
                        (file-name-directory (expand-file-name tap def-dir))))))
    (cond (lib) <span class="linecomment">; e.g we are inside a require sexp.</span>
          (url) <span class="linecomment">; String at point is an hyperlink.</span>
          (file-p (expand-file-name tap def-dir))
          (t (and (not (string= fap "<span class="quote"></span>")) fap)))))

(defun anything-c-current-directory ()
  "<span class="quote">Return current-directory name at point.
Useful in dired buffers when there is inserted subdirs.</span>"
  (if (eq major-mode 'dired-mode)
      (dired-current-directory)
      default-directory))

(defun anything-ff-find-url-at-point ()
  "<span class="quote">Try to find link to an url in text-property at point.</span>"
  (let* ((he      (get-text-property (point) 'help-echo))
         (ov      (overlays-at (point)))
         (ov-he   (and ov (overlay-get
                           (car (overlays-at (point))) 'help-echo)))
         (w3m-l   (get-text-property (point) 'w3m-href-anchor))
         (nt-prop (get-text-property (point) 'nt-link)))
    <span class="linecomment">;; Org link.</span>
    (when (and (stringp he) (string-match "<span class="quote">^LINK: </span>" he))
      (setq he (replace-match "<span class="quote"></span>" t t he)))
    (loop for i in (list he ov-he w3m-l nt-prop)
       thereis (and (stringp i) (string-match ffap-url-regexp i) i))))

(defun anything-find-library-at-point ()
  "<span class="quote">Try to find library path at point.
Find inside `require' and `declare-function' sexp.</span>"
  (require 'find-func)
  (let* ((beg-sexp (save-excursion (search-backward "<span class="quote">(</span>" (point-at-bol) t)))
         (end-sexp (save-excursion (search-forward "<span class="quote">)</span>" (point-at-eol) t)))
         (sexp     (and beg-sexp end-sexp
                        (buffer-substring-no-properties
                         (1+ beg-sexp) (1- end-sexp)))))
    (ignore-errors
      (cond ((and sexp (string-match "<span class="quote">require \'.+[^)]</span>" sexp))
             (find-library-name
              (replace-regexp-in-string
               "<span class="quote">'\\|\)\\|\(</span>" "<span class="quote"></span>"
               <span class="linecomment">;; If require use third arg, ignore it,</span>
               <span class="linecomment">;; always use library path found in `load-path'.</span>
               (second (split-string (match-string 0 sexp))))))
            ((and sexp (string-match-p "<span class="quote">^declare-function</span>" sexp))
             (find-library-name
              (replace-regexp-in-string
               "<span class="quote">\"\\|ext:</span>" "<span class="quote"></span>"
               (third (split-string sexp)))))
            (t nil)))))

<span class="linecomment">;;; Anything completion for `write-file'.==&gt; C-x C-w</span>
(defvar anything-c-source-write-file
  `((name . ,(concat "<span class="quote">Write File</span>" anything-c-find-files-doc-header))
    <span class="linecomment">;; It is needed for filenames with capital letters</span>
    (disable-shortcuts)
    (candidates . anything-find-files-get-candidates)
    (filtered-candidate-transformer anything-c-find-files-transformer)
    (persistent-action . anything-find-files-persistent-action)
    (persistent-help . "<span class="quote">Expand Candidate</span>")
    (volatile)
    (action .
     (("<span class="quote">Write File</span>" . (lambda (candidate)
                        (write-file candidate 'confirm)))))))

<span class="linecomment">;;;###autoload</span>
(defun anything-write-file ()
  "<span class="quote">Preconfigured `anything' providing completion for `write-file'.</span>"
  (interactive)
  (anything 'anything-c-source-write-file
            (expand-file-name default-directory)
            "<span class="quote">Write buffer to file: </span>" nil nil "<span class="quote">*Anything write file*</span>"))

<span class="linecomment">;;; Anything completion for `insert-file'.==&gt; C-x i</span>
(defvar anything-c-source-insert-file
  `((name . ,(concat "<span class="quote">Insert File</span>" anything-c-find-files-doc-header))
    <span class="linecomment">;; It is needed for filenames with capital letters</span>
    (disable-shortcuts)
    (candidates . anything-find-files-get-candidates)
    (filtered-candidate-transformer anything-c-find-files-transformer)
    (persistent-action . anything-find-files-persistent-action)
    (persistent-help . "<span class="quote">Expand Candidate</span>")
    (volatile)
    (action .
     (("<span class="quote">Insert File</span>" . (lambda (candidate)
                        (when (y-or-n-p (format "<span class="quote">Really insert %s in %s </span>"
                                                candidate anything-current-buffer))
                          (insert-file-contents candidate))))))))

<span class="linecomment">;;;###autoload</span>
(defun anything-insert-file ()
  "<span class="quote">Preconfigured `anything' providing completion for `insert-file'.</span>"
  (interactive)
  (anything 'anything-c-source-insert-file
            (expand-file-name default-directory)
            "<span class="quote">Insert file: </span>" nil nil "<span class="quote">*Anything insert file*</span>"))

<span class="linecomment">;;; Anything completion for copy, rename and (rel)sym/hard/link files from dired.</span>
(defvar anything-c-source-copy-files
  `((name . ,(concat "<span class="quote">Copy Files</span>" anything-c-find-files-doc-header))
    <span class="linecomment">;; It is needed for filenames with capital letters</span>
    (disable-shortcuts)
    (candidates . anything-find-files-get-candidates)
    (filtered-candidate-transformer anything-c-find-files-transformer)
    (persistent-action . anything-find-files-persistent-action)
    (persistent-help . "<span class="quote">Expand Candidate</span>")
    (volatile)
    (action .
     (("<span class="quote">Copy File</span>"
       . (lambda (candidate)
           (anything-dired-action candidate :action 'copy)))
      ("<span class="quote">Copy and Follow</span>"
       . (lambda (candidate)
           (anything-dired-action candidate :action 'copy :follow t)))))))


(defvar  anything-c-source-rename-files
  `((name . ,(concat "<span class="quote">Rename Files</span>" anything-c-find-files-doc-header))
    <span class="linecomment">;; It is needed for filenames with capital letters</span>
    (disable-shortcuts)
    (candidates . anything-find-files-get-candidates)
    (filtered-candidate-transformer anything-c-find-files-transformer)
    (persistent-action . anything-find-files-persistent-action)
    (persistent-help . "<span class="quote">Expand Candidate</span>")
    (volatile)
    (action .
     (("<span class="quote">Rename File</span>"
       . (lambda (candidate)
           (anything-dired-action candidate :action 'rename)))
      ("<span class="quote">Rename and Follow</span>"
       . (lambda (candidate)
           (anything-dired-action candidate :action 'rename :follow t)))))))

(defvar anything-c-source-symlink-files
  `((name . ,(concat "<span class="quote">Symlink Files</span>" anything-c-find-files-doc-header))
    <span class="linecomment">;; It is needed for filenames with capital letters</span>
    (disable-shortcuts)
    (candidates . anything-find-files-get-candidates)
    (filtered-candidate-transformer anything-c-find-files-transformer)
    (persistent-action . anything-find-files-persistent-action)
    (persistent-help . "<span class="quote">Expand Candidate</span>")
    (volatile)
    (action
     . (("<span class="quote">Symlink File</span>"
         . (lambda (candidate)
             (anything-dired-action candidate :action 'symlink)))
        ("<span class="quote">RelSymlink File</span>"
         . (lambda (candidate)
             (anything-dired-action candidate :action 'relsymlink)))))))


(defvar anything-c-source-hardlink-files
  `((name . ,(concat "<span class="quote">Hardlink Files</span>" anything-c-find-files-doc-header))
    <span class="linecomment">;; It is needed for filenames with capital letters</span>
    (disable-shortcuts)
    (candidates . anything-find-files-get-candidates)
    (filtered-candidate-transformer anything-c-find-files-transformer)
    (persistent-action . anything-find-files-persistent-action)
    (persistent-help . "<span class="quote">Expand Candidate</span>")
    (volatile)
    (action
     . (("<span class="quote">Hardlink File</span>"
         . (lambda (candidate)
             (anything-dired-action candidate :action 'hardlink)))))))

(defun* anything-dired-action (candidate &key action follow (files (dired-get-marked-files)))
  "<span class="quote">Copy, rename or symlink file at point or marked files in dired to CANDIDATE.
ACTION is a key that can be one of 'copy, 'rename, 'symlink, 'relsymlink.</span>"
  (when (get-buffer dired-log-buffer) (kill-buffer dired-log-buffer))
  (let ((fn     (case action
                  ('copy       'dired-copy-file)
                  ('rename     'dired-rename-file)
                  ('symlink    'make-symbolic-link)
                  ('relsymlink 'dired-make-relative-symlink)
                  ('hardlink   'dired-hardlink)))
        (marker (case action
                  ((copy rename)   dired-keep-marker-copy)
                  ('symlink        dired-keep-marker-symlink)
                  ('relsymlink     dired-keep-marker-relsymlink)
                  ('hardlink       dired-keep-marker-hardlink)))
        (dirflag (and (= (length files) 1)
                      (file-directory-p (car files))
                      (not (file-directory-p candidate)))))
    (dired-create-files
     fn (symbol-name action) files
     <span class="linecomment">;; CANDIDATE is the destination.</span>
     (if (file-directory-p candidate)
         <span class="linecomment">;; When CANDIDATE is a directory, build file-name in this directory.</span>
         <span class="linecomment">;; Else we use CANDIDATE.</span>
         #'(lambda (from)
             (expand-file-name (file-name-nondirectory from) candidate))
         #'(lambda (from) candidate))
     marker)
    (when (and follow (not (get-buffer dired-log-buffer)))
      (let ((moved-flist (anything-get-dest-fnames-from-list files candidate dirflag))
            (target      (directory-file-name candidate)))
        (unwind-protect
             (progn
               (setq anything-ff-cand-to-mark moved-flist)
               (if (and dirflag (eq action 'rename))
                   (anything-find-files1 (file-name-directory target) target)
                   (anything-find-files1 (expand-file-name candidate))))
          (setq anything-ff-cand-to-mark nil))))))

<span class="linecomment">;; Internal</span>
(defvar anything-ff-cand-to-mark nil)

(defun anything-c-basename (fname)
  "<span class="quote">Resolve basename of file or directory named FNAME.</span>"
  (file-name-nondirectory (directory-file-name fname)))

(defun anything-get-dest-fnames-from-list (flist dest-cand rename-dir-flag)
  "<span class="quote">Transform filenames of FLIST to abs of DEST-CAND.</span>"
  <span class="linecomment">;; At this point files have been renamed/copied at destination.</span>
  <span class="linecomment">;; That's mean DEST-CAND exists.</span>
  (loop
     with dest = (expand-file-name dest-cand)
     for src in flist
     for basename-src = (anything-c-basename src)
     for fname = (cond (rename-dir-flag (directory-file-name dest))
                       ((file-directory-p dest)
                        (concat (file-name-as-directory dest) basename-src))
                       (t dest))
     when (file-exists-p fname)
     collect fname into tmp-list
     finally return (sort tmp-list 'string&lt;)))

(defun anything-c-maybe-mark-candidates ()
  "<span class="quote">Mark all candidates of list `anything-ff-cand-to-mark'.</span>"
  (when (and (string= (assoc-default 'name (anything-get-current-source))
                      (assoc-default 'name anything-c-source-find-files))
             anything-ff-cand-to-mark)
    (with-anything-window
      (while anything-ff-cand-to-mark
        (if (search-forward (car anything-ff-cand-to-mark) (point-at-eol) t)
            (progn
              (anything-mark-current-line)
              (anything-make-visible-mark)
              (forward-line 1)
              (setq anything-ff-cand-to-mark (cdr anything-ff-cand-to-mark)))
            (forward-line 1)))
      (unless (anything-this-visible-mark)
        (anything-prev-visible-mark)))))

(add-hook 'anything-after-update-hook #'anything-c-maybe-mark-candidates)

(defun* anything-dired-do-action-on-file (&key action)
  (let* ((files     (dired-get-marked-files))
         (len       (length files))
         (fname     (if (&gt; len 1)
                        (format "<span class="quote">* %d Files</span>" len)
                        (car files)))
         (source    (case action
                      ('copy     'anything-c-source-copy-files)
                      ('rename   'anything-c-source-rename-files)
                      ('symlink  'anything-c-source-symlink-files)
                      ('hardlink 'anything-c-source-hardlink-files)))
         (prompt-fm (case action
                      ('copy     "<span class="quote">Copy %s to: </span>")
                      ('rename   "<span class="quote">Rename %s to: </span>")
                      ('symlink  "<span class="quote">Symlink %s to: </span>")
                      ('hardlink "<span class="quote">Hardlink %s to: </span>")))
         (buffer    (case action
                      ('copy     "<span class="quote">*Anything Copy Files*</span>")
                      ('rename   "<span class="quote">*Anything Rename Files*</span>")
                      ('symlink  "<span class="quote">*Anything Symlink Files*</span>")
                      ('hardlink "<span class="quote">*Anything Hardlink Files*</span>")))
         (anything-mp-highlight-delay     nil))
    (anything :sources source
              :input (or (dired-dwim-target-directory)
                         (expand-file-name (anything-c-current-directory)))
              :preselect (dired-get-filename)
              :prompt (format prompt-fm fname)
              :keymap anything-c-read-file-map
              :buffer buffer)))

<span class="linecomment">;;;###autoload</span>
(defun anything-dired-rename-file ()
  "<span class="quote">Preconfigured `anything' to rename files from dired.</span>"
  (interactive)
  (anything-dired-do-action-on-file :action 'rename))

<span class="linecomment">;;;###autoload</span>
(defun anything-dired-copy-file ()
  "<span class="quote">Preconfigured `anything' to copy files from dired.</span>"
  (interactive)
  (anything-dired-do-action-on-file :action 'copy))

<span class="linecomment">;;;###autoload</span>
(defun anything-dired-symlink-file ()
  "<span class="quote">Preconfigured `anything' to symlink files from dired.</span>"
  (interactive)
  (anything-dired-do-action-on-file :action 'symlink))

<span class="linecomment">;;;###autoload</span>
(defun anything-dired-hardlink-file ()
  "<span class="quote">Preconfigured `anything' to hardlink files from dired.</span>"
  (interactive)
  (anything-dired-do-action-on-file :action 'hardlink))

(defvar anything-dired-bindings nil)
<span class="linecomment">;;;###autoload</span>
(defun anything-dired-bindings (&optional arg)
  "<span class="quote">Replace usual dired commands `C' and `R' by anything ones.
When call interactively toggle dired bindings and anything bindings.
When call non--interactively with arg &gt; 0, enable anything bindings.
You can put (anything-dired-binding 1) in init file to enable anything bindings.</span>"
  (interactive)
  (if (or (and arg (&gt; arg 0)) (not anything-dired-bindings))
      <span class="linecomment">;; Replace dired bindings.</span>
      (progn
        (substitute-key-definition
         'dired-do-copy 'anything-dired-copy-file dired-mode-map)
        (substitute-key-definition
         'dired-do-rename 'anything-dired-rename-file dired-mode-map)
        (substitute-key-definition
         'dired-do-symlink 'anything-dired-symlink-file dired-mode-map)
        (substitute-key-definition
         'dired-do-hardlink 'anything-dired-hardlink-file dired-mode-map)
        (setq anything-dired-bindings t))
      <span class="linecomment">;; Replace anything bindings.</span>
      (substitute-key-definition
       'anything-dired-copy-file 'dired-do-copy dired-mode-map)
      (substitute-key-definition
       'anything-dired-rename-file 'dired-do-rename dired-mode-map)
      (substitute-key-definition
       'anything-dired-symlink-file 'dired-do-symlink dired-mode-map)
      (substitute-key-definition
       'anything-dired-hardlink-file 'dired-do-hardlink dired-mode-map)
      (setq anything-dired-bindings nil)))

(defvar anything-c-read-file-map
  (let ((map (copy-keymap anything-map)))
    (define-key map (kbd "<span class="quote">C-.</span>")         'anything-find-files-down-one-level)
    (define-key map (kbd "<span class="quote">C-l</span>")         'anything-find-files-down-one-level)
    (when anything-ff-lynx-style-map
      (define-key map (kbd "<span class="quote">&lt;left&gt;</span>")    'anything-find-files-down-one-level)
      (define-key map (kbd "<span class="quote">&lt;right&gt;</span>")   'anything-execute-persistent-action)
      (define-key map (kbd "<span class="quote">&lt;M-left&gt;</span>")  'anything-previous-source)
      (define-key map (kbd "<span class="quote">&lt;M-right&gt;</span>") 'anything-next-source))
    (delq nil map))
  "<span class="quote">Keymap for `anything-c-read-file-name'.</span>")

(defun* anything-c-read-file-name (prompt
                                   &key
                                   (initial-input (expand-file-name default-directory))
                                   (buffer "<span class="quote">*Anything Completions*</span>")
                                   test
                                   (preselect nil)
                                   must-match
                                   (history nil)
                                   (marked-candidates nil)
                                   (persistent-action 'anything-find-files-persistent-action)
                                   (persistent-help "<span class="quote">Hit1 Expand Candidate, Hit2 or (C-u) Find file</span>"))
  "<span class="quote">Anything `read-file-name' emulation.
INITIAL-INPUT is a valid path, TEST is a predicate that take one arg.</span>"
  (when (get-buffer anything-action-buffer)
    (kill-buffer anything-action-buffer))
  (let ((anything-mp-highlight-delay nil))
    (flet ((action-fn (candidate)
             (if marked-candidates
                 (anything-marked-candidates)
                 (identity candidate))))
      (or (anything
           :sources
           `(((name . ,(concat "<span class="quote">Read File Name History</span>" anything-c-find-files-doc-header))
              (candidates . (lambda ()
                              (anything-comp-read-get-candidates history)))
              (volatile)
              (persistent-action . ,persistent-action)
              (persistent-help . ,persistent-help)
              (action . ,'action-fn))
             ((name . ,(concat "<span class="quote">Read file name</span>" anything-c-find-files-doc-header))
              (init . (lambda ()
                        <span class="linecomment">;; For emacsclient (see `anything-c-source-find-files')</span>
                        (unless window-system
                          (define-key anything-find-files-map (kbd "<span class="quote">C-l</span>")
                            'anything-find-files-down-one-level))))
              <span class="linecomment">;; It is needed for filenames with capital letters</span>
              (disable-shortcuts)
              (candidates . (lambda ()
                              (if test
                                  (loop with seq = (anything-find-files-get-candidates)
                                     for fname in seq when (funcall test fname)
                                     collect fname into ls
                                     finally return (if must-match
                                                        ls
                                                        (append (list anything-pattern) ls)))
                                  (anything-find-files-get-candidates))))
              (filtered-candidate-transformer anything-c-find-files-transformer)
              (persistent-action . ,persistent-action)
              (candidate-number-limit . 9999)
              (persistent-help . ,persistent-help)
              (volatile)
              (action . ,'action-fn)))
           :input initial-input
           :prompt prompt
           :keymap anything-c-read-file-map
           :resume 'noresume
           :buffer buffer
           :preselect preselect)
          (keyboard-quit)))))

<span class="linecomment">;;; File Cache</span>
(defvar anything-c-source-file-cache-initialized nil)

(defvar anything-c-file-cache-files nil)

(defvar anything-c-source-file-cache
  '((name . "<span class="quote">File Cache</span>")
    (init
     . (lambda ()
         (require 'filecache nil t)
         (unless anything-c-source-file-cache-initialized
           (setq anything-c-file-cache-files
                 (loop for item in file-cache-alist append
                       (destructuring-bind (base &rest dirs) item
                         (loop for dir in dirs collect
                               (concat dir base)))))
           (defadvice file-cache-add-file (after file-cache-list activate)
             (add-to-list 'anything-c-file-cache-files (expand-file-name file)))
           (setq anything-c-source-file-cache-initialized t))))
    (candidates . anything-c-file-cache-files)
    (match anything-c-match-on-file-name
           anything-c-match-on-directory-name)
    (type . file)))
<span class="linecomment">;; (anything 'anything-c-source-file-cache)</span>

<span class="linecomment">;;; Locate</span>
<span class="linecomment">;; NOTE for WINDOZE users:</span>
<span class="linecomment">;; You have to install Everything with his command line interface here:</span>
<span class="linecomment">;; http://www.voidtools.com/download.php</span>

(defvar anything-c-locate-command
  (case system-type
    ('gnu/linux "<span class="quote">locate -i -r %s</span>")
    ('berkeley-unix "<span class="quote">locate -i %s</span>")
    ('windows-nt "<span class="quote">es -i -r %s</span>")
    (t "<span class="quote">locate %s</span>"))
  "<span class="quote">A list of arguments for locate program.
The \"-r\" option must be the last option.</span>")

(defvar anything-locate-db-file-regexp "<span class="quote">m?locate\.db$</span>"
  "<span class="quote">Default regexp to match locate database.
If nil Search in all files.</span>")

(defun anything-c-locate-init ()
  "<span class="quote">Initialize async locate process for `anything-c-source-locate'.</span>"
  (setq mode-line-format
        '("<span class="quote"> </span>" mode-line-buffer-identification "<span class="quote"> </span>"
          (line-number-mode "<span class="quote">%l</span>") "<span class="quote"> </span>"
          (:eval (propertize "<span class="quote">(Locate Process Running) </span>"
                  'face '((:foreground "<span class="quote">red</span>"))))))
  (prog1
      (start-process-shell-command "<span class="quote">locate-process</span>" nil
                                   (format anything-c-locate-command
                                           anything-pattern))
    (set-process-sentinel (get-process "<span class="quote">locate-process</span>")
                          #'(lambda (process event)
                              (when (string= event "<span class="quote">finished\n</span>")
                                (kill-local-variable 'mode-line-format)
                                (with-anything-window
                                  (anything-update-move-first-line)))))))

(defvar anything-c-source-locate
  '((name . "<span class="quote">Locate</span>")
    (candidates . anything-c-locate-init)
    (type . file)
    (properties-action . anything-ff-properties)
    (requires-pattern . 3)
    (mode-line . anything-generic-file-mode-line-string)
    (delayed))
  "<span class="quote">Find files matching the current input pattern with locate.</span>")
<span class="linecomment">;; (anything 'anything-c-source-locate)</span>

(defvar anything-generic-file-mode-line-string
  "<span class="quote">\\&lt;anything-generic-files-map&gt;\
\\[anything-generic-file-help]:Help, \
\\&lt;anything-map&gt;\
\\[anything-select-action]:Acts,\
\\[anything-exit-minibuffer]/\\[anything-select-2nd-action-or-end-of-line]/\
\\[anything-select-3rd-action]:NthAct,\
\\[anything-send-bug-report-from-anything]:BugReport.</span>"
  "<span class="quote">String displayed in mode-line in `anything-c-source-find-files'</span>")

(defun anything-generic-file-help ()
  (interactive)
  (let ((anything-help-message "<span class="quote">== Anything Generic files Map ==\
\nSpecific commands for anything locate and others files sources:
\\&lt;anything-generic-files-map&gt;
\\[anything-ff-run-grep]\t\t-&gt;Run grep (C-u recurse).
\\[anything-ff-run-pdfgrep]\t\t-&gt;Run Pdfgrep on marked files.
\\[anything-ff-run-delete-file]\t\t-&gt;Delete file.
\\[anything-ff-run-switch-other-window]\t\t-&gt;Switch other window.
\\[anything-ff-properties-persistent]\t\t-&gt;Show file properties.
\\[anything-ff-run-open-file-externally]\t\t-&gt;Open file with external program (C-u to choose).
\nLocate tips:
You can add after writing search pattern any of the locate command line options.
e.g -b, -e, -n &lt;number&gt;...etc.
See Man locate for more infos.
\n== Anything Map ==
\\{anything-map}</span>"))
    (anything-help)))

(defvar anything-generic-files-map
  (let ((map (copy-keymap anything-map)))
    (define-key map (kbd "<span class="quote">M-g s</span>")   'anything-ff-run-grep)
    (define-key map (kbd "<span class="quote">M-g p</span>")   'anything-ff-run-pdfgrep)
    (define-key map (kbd "<span class="quote">M-D</span>")     'anything-ff-run-delete-file)
    (define-key map (kbd "<span class="quote">C-o</span>")     'anything-ff-run-switch-other-window)
    (define-key map (kbd "<span class="quote">M-i</span>")     'anything-ff-properties-persistent)
    (define-key map (kbd "<span class="quote">C-c C-x</span>") 'anything-ff-run-open-file-externally)
    (define-key map (kbd "<span class="quote">C-c ?</span>")   'anything-generic-file-help)
    map)
  "<span class="quote">Generic Keymap for files.</span>")

<span class="linecomment">;;; Anything Incremental Grep.</span>
<span class="linecomment">;; This allow to grep incrementally with anything interface.</span>
<span class="linecomment">;; It allow also to Grep files recursively without using 'find' shell command.</span>
<span class="linecomment">;; On Windows you will need at least Grep version 2.5.4 of Gnuwin32.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;</span>
(defvar anything-c-grep-default-command
  "<span class="quote">grep -d skip %e -niH -e %p %f</span>"
  "<span class="quote">Default grep format command for `anything-do-grep1'.
Where:
'%e' format spec is for --exclude or --include grep options.
'%p' format spec is for pattern.
'%f' format spec is for filenames.</span>")

(defvar anything-c-grep-default-recurse-command
  "<span class="quote">grep -d recurse %e -niH -e %p %f</span>"
  "<span class="quote">Default recursive grep format command for `anything-do-grep1'.
See `anything-c-grep-default-command' for format specs.</span>")

(defvar anything-c-default-zgrep-command "<span class="quote">zgrep -niH -e %p %f</span>")

(defvar anything-c-rzgrep-cache (make-hash-table :test 'equal))

(defvar anything-c-grep-default-function 'anything-c-grep-init)

(defvar anything-c-grep-debug-command-line nil
  "<span class="quote">Turn on anything grep command-line debugging when non--nil.</span>")

(defvar anything-c-zgrep-recurse-flag nil)

(defvar anything-grep-mode-line-string
  "<span class="quote">\\&lt;anything-c-grep-map&gt;\
\\[anything-grep-help]:Help,\
\\&lt;anything-map&gt;\
\\[anything-select-action]:Acts,\
\\[anything-exit-minibuffer]/\\[anything-select-2nd-action-or-end-of-line]/\
\\[anything-select-3rd-action]:NthAct,\
\\[anything-send-bug-report-from-anything]:BugReport.</span>"
  "<span class="quote">String displayed in mode-line in `anything-do-grep'.</span>")
(defvar anything-c-grep-history nil)

(defvar anything-c-grep-max-length-history 100
  "<span class="quote">*Max number of elements to save in `anything-c-grep-history'.</span>")

(defface anything-grep-match
  '((t (:inherit match)))
  "<span class="quote">Face used to highlight grep matches.</span>"
  :group 'anything-config)

(defface anything-grep-file
  '((t (:foreground "<span class="quote">BlueViolet</span>" :underline t)))
  "<span class="quote">Face used to highlight grep results filenames.</span>"
  :group 'anything-config)

(defface anything-grep-lineno
  '((t (:foreground "<span class="quote">Darkorange1</span>")))
  "<span class="quote">Face used to highlight grep number lines.</span>"
  :group 'anything-config)

(defface anything-grep-running
  '((t (:foreground "<span class="quote">Red</span>")))
  "<span class="quote">Face used in mode line when grep is running.</span>"
  :group 'anything-config)

(defface anything-grep-finish
  '((t (:foreground "<span class="quote">Green</span>")))
  "<span class="quote">Face used in mode line when grep is finish.</span>"
  :group 'anything-config)

(defun anything-c-grep-prepare-candidates (candidates)
  "<span class="quote">Prepare filenames and directories CANDIDATES for grep command line.</span>"
  <span class="linecomment">;; If one or more candidate is a directory, search in all files</span>
  <span class="linecomment">;; of this candidate (e.g /home/user/directory/*).</span>
  <span class="linecomment">;; If r option is enabled search also in subdidrectories.</span>
  <span class="linecomment">;; We need here to expand wildcards to support crap windows filenames</span>
  <span class="linecomment">;; as grep don't accept quoted wildcards (e.g "dir/*.el").</span>
  (if anything-c-zgrep-recurse-flag
      (mapconcat 'shell-quote-argument candidates "<span class="quote"> </span>")
      (loop for i in candidates append
           (cond ( <span class="linecomment">;; Candidate is a directory and we use recursion.</span>
                  (and (file-directory-p i)
                       (anything-c-grep-recurse-p))
                  (list (expand-file-name i)))
                 <span class="linecomment">;; Candidate is a directory, search in all files.</span>
                 ((file-directory-p i)
                  (file-expand-wildcards
                   (concat (file-name-as-directory (expand-file-name i)) "<span class="quote">*</span>") t))
                 <span class="linecomment">;; Candidate is a file or wildcard and we use recursion, use the</span>
                 <span class="linecomment">;; current directory instead of candidate.</span>
                 ((and (or (file-exists-p i) (string-match "<span class="quote">\*</span>" i))
                       (anything-c-grep-recurse-p))
                  (list (directory-file-name <span class="linecomment">; Needed for windoze.</span>
                         (file-name-directory (directory-file-name i)))))
                 <span class="linecomment">;; Candidate use wildcard.</span>
                 ((string-match "<span class="quote">\*</span>" i) (file-expand-wildcards i t))
                 <span class="linecomment">;; Else should be one or more file.</span>
                 (t (list i))) into all-files
           finally return
           (mapconcat 'shell-quote-argument all-files "<span class="quote"> </span>"))))

(defun anything-c-grep-recurse-p ()
  "<span class="quote">Check if `anything-do-grep1' have switched to recursive.</span>"
  (let ((args (replace-regexp-in-string
               "<span class="quote">grep</span>" "<span class="quote"></span>" anything-c-grep-default-command)))
    (string-match-p "<span class="quote">r\\|recurse</span>" args)))

(defun anything-c-grep-init (only-files &optional include zgrep)
  "<span class="quote">Start an asynchronous grep process in ONLY-FILES list.</span>"
  (let* ((fnargs        (anything-c-grep-prepare-candidates
                         (if (file-remote-p anything-ff-default-directory)
                             (mapcar #'(lambda (x)
                                         (file-remote-p x 'localname))
                                     only-files)
                             only-files)))
         (ignored-files (mapconcat
                         #'(lambda (x)
                             (concat "<span class="quote">--exclude=</span>" (shell-quote-argument x)))
                         grep-find-ignored-files "<span class="quote"> </span>"))
         (ignored-dirs  (mapconcat
                         <span class="linecomment">;; Need grep version 2.5.4 of Gnuwin32 on windoze.</span>
                         #'(lambda (x)
                             (concat "<span class="quote">--exclude-dir=</span>" (shell-quote-argument x)))
                         grep-find-ignored-directories "<span class="quote"> </span>"))
         (exclude       (if (anything-c-grep-recurse-p)
                            (concat (or include ignored-files) "<span class="quote"> </span>" ignored-dirs)
                            ignored-files))
         (cmd-line      (format-spec
                         anything-c-grep-default-command
                         (delq nil
                               (list (unless zgrep (cons ?e exclude))
                                     (cons ?p (shell-quote-argument anything-pattern))
                                     (cons ?f fnargs))))))
    (when anything-c-grep-debug-command-line
      (with-current-buffer (get-buffer-create "<span class="quote">*any grep debug*</span>")
        (goto-char (point-max))
        (insert (concat "<span class="quote">&gt;&gt;&gt; </span>" cmd-line "<span class="quote">\n\n</span>"))))
    (setq mode-line-format
          '("<span class="quote"> </span>" mode-line-buffer-identification "<span class="quote"> </span>"
            (line-number-mode "<span class="quote">%l</span>") "<span class="quote"> </span>"
            (:eval (when (get-process "<span class="quote">grep-process</span>")
                     (propertize "<span class="quote">[Grep Process Running] </span>"
                                 'face 'anything-grep-running)))))
    (prog1
        (let ((default-directory anything-ff-default-directory))
          (start-file-process-shell-command "<span class="quote">grep-process</span>" nil cmd-line))
      (message nil)
      (set-process-sentinel
       (get-process "<span class="quote">grep-process</span>")
       #'(lambda (process event)
           (when (string= event "<span class="quote">finished\n</span>")
             (with-anything-window
               (anything-update-move-first-line)
               (kill-local-variable 'mode-line-format)
               (setq mode-line-format
                     '("<span class="quote"> </span>" mode-line-buffer-identification "<span class="quote"> </span>"
                       (line-number-mode "<span class="quote">%l</span>") "<span class="quote"> </span>"
                       (:eval (propertize
                               (format "<span class="quote">[Grep Process Finished - (%s results)] </span>"
                                       (let ((nlines (1- (count-lines
                                                          (point-min)
                                                          (point-max)))))
                                         (if (&gt; nlines 0) nlines 0)))
                               'face 'anything-grep-finish)))))))))))

(defun anything-c-grep-action (candidate &optional where mark)
  "<span class="quote">Define a default action for `anything-do-grep' on CANDIDATE.
WHERE can be one of other-window, elscreen, other-frame.</span>"
  (let* ((split        (anything-c-grep-split-line candidate))
         (lineno       (string-to-number (nth 1 split)))
         (loc-fname    (car split))
         (tramp-method (file-remote-p anything-ff-default-directory 'method))
         (tramp-host   (file-remote-p anything-ff-default-directory 'host))
         (tramp-prefix (concat "<span class="quote">/</span>" tramp-method "<span class="quote">:</span>" tramp-host "<span class="quote">:</span>"))
         (fname        (if tramp-host
                           (concat tramp-prefix loc-fname) loc-fname)))
    (case where
      (other-window (find-file-other-window fname))
      (elscreen     (anything-elscreen-find-file fname))
      (other-frame  (find-file-other-frame fname))
      (t (find-file fname)))
    (anything-goto-line lineno)
    (when mark
      (set-marker (mark-marker) (point))
      (push-mark (point) 'nomsg))
    <span class="linecomment">;; Save history</span>
    (unless (or anything-in-persistent-action
                (string= anything-pattern "<span class="quote"></span>"))
      (setq anything-c-grep-history
            (cons anything-pattern
                  (delete anything-pattern anything-c-grep-history)))
      (when (&gt; (length anything-c-grep-history)
               anything-c-grep-max-length-history)
        (setq anything-c-grep-history
              (delete (car (last anything-c-grep-history))
                      anything-c-grep-history))))))
      
(defun anything-c-grep-other-window (candidate)
  "<span class="quote">Jump to result in other window from anything grep.</span>"
  (anything-c-grep-action candidate 'other-window))

(defun anything-c-grep-other-frame (candidate)
  "<span class="quote">Jump to result in other frame from anything grep.</span>"
  (anything-c-grep-action candidate 'other-frame))

(defun anything-c-grep-jump-elscreen (candidate)
  "<span class="quote">Jump to result in elscreen from anything grep.</span>"
  (anything-c-grep-action candidate 'elscreen))

(defun anything-c-grep-save-results (candidate)
  "<span class="quote">Save anything grep result in a `grep-mode' buffer.</span>"
  (let ((buf "<span class="quote">*grep*</span>")
        new-buf)
    (when (get-buffer buf)
      (setq new-buf (read-string "<span class="quote">GrepBufferName: </span>" buf))
      (loop for b in (anything-c-buffer-list)
         when (and (string= new-buf b)
                   (not (y-or-n-p
                         (format "<span class="quote">Buffer `%s' already exists overwrite? </span>"
                                 new-buf))))
         do (setq new-buf (read-string "<span class="quote">GrepBufferName: </span>" "<span class="quote">*grep </span>")))
      (setq buf new-buf))
    (with-current-buffer (get-buffer-create buf)
      (let ((inhibit-read-only t))
        (erase-buffer)
        (insert "<span class="quote">-*- mode: grep -*-\n\n</span>"
                (format "<span class="quote">Grep Results for `%s':\n\n</span>" anything-pattern))
        (save-excursion
          (insert (with-current-buffer anything-buffer
                    (forward-line 1)
                    (buffer-substring (point) (point-max))))
          (grep-mode))))
    (message "<span class="quote">Anything Grep Results saved in `%s' buffer</span>" buf)))

(defun anything-c-grep-persistent-action (candidate)
  "<span class="quote">Persistent action for `anything-do-grep'.
With a prefix arg record CANDIDATE in `mark-ring'.</span>"
  (if current-prefix-arg
      (anything-c-grep-action candidate nil 'mark)
      (anything-c-grep-action candidate))
  (anything-match-line-color-current-line))

(defun anything-c-grep-guess-extensions (files)
  "<span class="quote">Try to guess file extensions in FILES list when using grep recurse.
These extensions will be added to command line with --include arg of grep.</span>"
  (loop
     with glob-list = nil
     with lst = (if (file-directory-p (car files))
                    (directory-files
                     (car files) nil
                     directory-files-no-dot-files-regexp)
                    files)
     for i in lst
     for ext = (file-name-extension i t)
     for glob = (and ext (not (string= ext "<span class="quote"></span>"))
                     (concat "<span class="quote">*</span>" ext))
     unless (or (not glob)
                (member glob glob-list)
                (member glob grep-find-ignored-files))
     collect glob into glob-list
     finally return glob-list))

(defun anything-do-grep1 (only &optional recurse zgrep)
  "<span class="quote">Launch grep with a list of ONLY files.
When RECURSE is given use -r option of grep and prompt user
to set the --include args of grep.
You can give more than one arg separated by space.
e.g *.el *.py *.tex.
If it's empty --exclude `grep-find-ignored-files' is used instead.</span>"
  (let* ((anything-compile-source-functions
          <span class="linecomment">;; rule out anything-match-plugin because the input is one regexp.</span>
          (delq 'anything-compile-source--match-plugin
                (copy-sequence anything-compile-source-functions)))
         (exts (anything-c-grep-guess-extensions only))
         (globs (and (not zgrep) (mapconcat 'identity exts "<span class="quote"> </span>")))
         (include-files (and recurse (not zgrep)
                             (read-string "<span class="quote">OnlyExt(*.[ext]): </span>"
                                          globs)))
         <span class="linecomment">;; Set `minibuffer-history' AFTER includes-files</span>
         <span class="linecomment">;; to avoid storing wild-cards here.</span>
         (minibuffer-history anything-c-grep-history)
         (anything-c-grep-default-command (cond ((and recurse zgrep) anything-c-default-zgrep-command)
                                                (recurse anything-c-grep-default-recurse-command)
                                                (zgrep anything-c-default-zgrep-command)
                                                (t anything-c-grep-default-command)))
         <span class="linecomment">;; Disable match-plugin and use here own highlighting.</span>
         (anything-mp-highlight-delay     nil))
    (when include-files
      (setq include-files
            (and (not (string= include-files "<span class="quote"></span>"))
                 (mapconcat #'(lambda (x)
                                (concat "<span class="quote">--include=</span>" (shell-quote-argument x)))
                            (split-string include-files) "<span class="quote"> </span>"))))
    <span class="linecomment">;; When called as action from an other source e.g *-find-files</span>
    <span class="linecomment">;; we have to kill action buffer.</span>
    (when (get-buffer anything-action-buffer)
      (kill-buffer anything-action-buffer))
    <span class="linecomment">;; `anything-find-files' haven't already started,</span>
    <span class="linecomment">;; give a default value to `anything-ff-default-directory'.</span>
    (setq anything-ff-default-directory (or anything-ff-default-directory
                                            default-directory))
    (anything
     :sources
     `(((name . "<span class="quote">Grep (C-c ? Help)</span>")
        (candidates
         . (lambda ()
             (funcall anything-c-grep-default-function only include-files zgrep)))
        (filtered-candidate-transformer anything-c-grep-cand-transformer)
        (candidate-number-limit . 9999)
        (mode-line . anything-grep-mode-line-string)
        (jump-persistent . anything-c-grep-persistent-action)
        (action . ,(delq
                    nil
                    `(("<span class="quote">Find File</span>" . anything-c-grep-action)
                      ("<span class="quote">Find file other frame</span>" . anything-c-grep-other-frame)
                      ,(and (locate-library "<span class="quote">elscreen</span>")
                            '("<span class="quote">Find file in Elscreen</span>"
                              . anything-c-grep-jump-elscreen))
                      ("<span class="quote">Save results in grep buffer</span>" . anything-c-grep-save-results)
                      ("<span class="quote">Find file other window</span>" . anything-c-grep-other-window))))
        (persistent-action . anything-c-grep-persistent-action)
        (persistent-help . "<span class="quote">Jump to line (`C-u' Record in mark ring)</span>")
        (requires-pattern . 3)
        (delayed)))
     :keymap anything-c-grep-map
     :buffer "<span class="quote">*anything grep*</span>")))

<span class="linecomment">;;;###autoload</span>
(defun anything-do-grep ()
  "<span class="quote">Preconfigured anything for grep.
Contrarily to Emacs `grep' no default directory is given, but
the full path of candidates in ONLY.
That allow to grep different files not only in `default-directory' but anywhere
by marking them (C-&lt;SPACE&gt;). If one or more directory is selected
grep will search in all files of these directories.
You can use also wildcard in the base name of candidate.
If a prefix arg is given use the -r option of grep.
The prefix arg can be passed before or after start.
See also `anything-do-grep1'.</span>"
  (interactive)
  (let ((only    (anything-c-read-file-name
                  "<span class="quote">Search in file(s): </span>"
                  :marked-candidates t
                  :preselect (or (dired-get-filename nil t)
                                 (buffer-file-name (current-buffer)))))
        (prefarg (or current-prefix-arg anything-current-prefix-arg)))
    (anything-do-grep1 only prefarg)))

(defmacro* anything-c-walk-directory (directory &key (path 'basename) (directories t) match)
  "<span class="quote">Walk through DIRECTORY tree.
PATH can be one of basename, relative, or full.
DIRECTORIES when non--nil (default) return also directories names, otherwise
skip directories names.
MATCH match only filenames matching regexp MATCH.</span>"
  `(let (result
         (fn (case ,path
               (basename 'file-name-nondirectory)
               (relative 'file-relative-name)
               (full     'identity)
               (t (error "<span class="quote">Error: Invalid path spec `%s', must be one of basename, relative or full.</span>" ,path)))))
     (labels ((ls-R (dir)
                (loop with ls = (directory-files dir t directory-files-no-dot-files-regexp)
                   for f in ls
                   if (file-directory-p f)
                   do (progn (when ,directories
                               (push (funcall fn f) result))
                             <span class="linecomment">;; Don't recurse in directory symlink.</span>
                             (unless (file-symlink-p f)
                               (ls-R f)))
                   else do 
                   (unless (and ,match (not (string-match ,match (file-name-nondirectory f))))
                     (push (funcall fn f) result)))))
       (ls-R ,directory)
       (nreverse result))))

(defun anything-ff-zgrep-1 (flist recursive)
  (unwind-protect
       (let* ((def-dir (or anything-ff-default-directory
                           default-directory))
              (only    (if recursive
                           (or (gethash def-dir anything-c-rzgrep-cache)
                               (puthash
                                def-dir
                                (anything-c-walk-directory
                                 def-dir
                                 :directories nil
                                 :path 'full
                                 :match "<span class="quote">.*\\(\.gz\\|\.bz\\|\.xz\\|\.lzma\\)$</span>")
                                anything-c-rzgrep-cache))
                           flist)))
         (when recursive (setq anything-c-zgrep-recurse-flag t))
         (anything-do-grep1 only recursive 'zgrep))
    (setq anything-c-zgrep-recurse-flag nil)))

<span class="linecomment">;;;###autoload</span>
(defun anything-do-zgrep (candidate)
  "<span class="quote">Preconfigured anything for zgrep.</span>"
  (let ((prefarg (or current-prefix-arg anything-current-prefix-arg))
        (ls (anything-c-read-file-name
             "<span class="quote">Search in file(s): </span>"
             :marked-candidates t
             :preselect (or (dired-get-filename nil t)
                            (buffer-file-name (current-buffer))))))
    (anything-ff-zgrep-1 ls prefarg)))

(defun anything-c-grep-split-line (line)
  "<span class="quote">Split a grep output line.</span>"
    (let (beg fname lineno str)
      <span class="linecomment">;; Don't print until grep line is valid.</span>
      (when (string-match "<span class="quote">\\(.*\\)\\(:[0-9]+:\\)\\(.*\\)</span>" line)
        (with-temp-buffer
          (insert line)
          (goto-char (point-min))
          (setq beg (point))
          (forward-char 2)
          (re-search-forward "<span class="quote">:</span>" nil t)
          (setq fname (buffer-substring-no-properties beg (1- (point))))
          (setq beg (point))
          (re-search-forward "<span class="quote">:</span>" nil t)
          (setq lineno (buffer-substring-no-properties beg (1- (point))))
          (setq str (buffer-substring-no-properties (point) (point-at-eol))))
        (list fname lineno str))))

(defun anything-c-grep-cand-transformer (candidates sources)
  "<span class="quote">Filtered candidate transformer function for `anything-do-grep'.</span>"
  (loop for i in candidates
     for split  = (and i (anything-c-grep-split-line i))
     for fname  = (car split)
     for lineno = (nth 1 split)
     for str    = (nth 2 split)
     when (and fname lineno str)
     collect
       (cons (concat (propertize (file-name-nondirectory fname)
                                 'face 'anything-grep-file
                                 'help-echo fname) "<span class="quote">:</span>"
                     (propertize lineno 'face 'anything-grep-lineno) "<span class="quote">:</span>"
                     (anything-c-grep-highlight-match str))
             i)))

(defun anything-c-grep-highlight-match (str)
  "<span class="quote">Highlight in string STR all occurences matching `anything-pattern'.</span>"
  (condition-case nil
      (with-temp-buffer
        (insert str)
        (goto-char (point-min))
        (while (and (re-search-forward anything-pattern nil t)
                    (&gt; (- (match-end 0) (match-beginning 0)) 0))
          (add-text-properties
           (match-beginning 0) (match-end 0)
           '(face anything-grep-match)))
        (buffer-string))
    (error nil)))

<span class="linecomment">;; Go to next or precedent file (common to etags and grep).</span>
(defun anything-c-goto-next-or-prec-file (n)
  "<span class="quote">Go to next or precedent candidate file in anything grep/etags buffers.
If N is positive go forward otherwise go backward.</span>"
  (with-anything-window
    (let* ((current-line-list  (split-string
                                (buffer-substring
                                 (point-at-bol)
                                 (point-at-eol)) "<span class="quote">:</span>"))
           (current-fname      (nth 0 current-line-list))
           (fn-b-o-f           (if (eq n 1) 'eobp 'bobp)))
      (catch 'break
        (while (not (funcall fn-b-o-f))
          (forward-line n) <span class="linecomment">; Go forward or backward depending of n value.</span>
          (unless (search-forward current-fname (point-at-eol) t)
            (anything-mark-current-line)
            (throw 'break nil))))
      (cond ((and (eq n 1) (eobp))
             (re-search-backward "<span class="quote">.</span>")
             (forward-line 0)
             (anything-mark-current-line))
            ((and (&lt; n 1) (bobp))
             (forward-line 1)
             (anything-mark-current-line))))))

<span class="linecomment">;;;###autoload</span>
(defun anything-c-goto-precedent-file ()
  "<span class="quote">Go to precedent file in anything grep/etags buffers.</span>"
  (interactive)
  (anything-c-goto-next-or-prec-file -1))

<span class="linecomment">;;;###autoload</span>
(defun anything-c-goto-next-file ()
  "<span class="quote">Go to precedent file in anything grep/etags buffers.</span>"
  (interactive)
  (anything-c-goto-next-or-prec-file 1))

<span class="linecomment">;;;###autoload</span>
(defun anything-grep-help ()
  (interactive)
  (let ((anything-help-message "<span class="quote">== Anything Grep Map ==\
\nSpecific commands for Grep and Etags:
\\&lt;anything-c-grep-map&gt;
\\[anything-c-goto-next-file]\t-&gt;Next File.
\\[anything-c-goto-precedent-file]\t\t-&gt;Precedent File.
\\[anything-yank-text-at-point]\t\t-&gt;Yank Text at point in minibuffer.
\\[anything-c-grep-run-other-window-action]\t\t-&gt;Jump other window.
\\[anything-c-grep-run-persistent-action]\t\t-&gt;Run persistent action (Same as `C-z').
\\[anything-c-grep-run-default-action]\t\t-&gt;Run default action (Same as RET).
\\[anything-grep-help]\t\t-&gt;Show this help.
\n== Anything Map ==
\\{anything-map}</span>"))
    (anything-help)))

(defcustom anything-c-grep-use-ioccur-style-keys t
  "<span class="quote">Use Arrow keys to jump to occurences.</span>"
  :group 'anything-config
  :type 'boolean)

(defvar anything-c-grep-map
  (let ((map (copy-keymap anything-map)))
    (define-key map (kbd "<span class="quote">M-&lt;down&gt;</span>") 'anything-c-goto-next-file)
    (define-key map (kbd "<span class="quote">M-&lt;up&gt;</span>")   'anything-c-goto-precedent-file)
    (define-key map (kbd "<span class="quote">C-o</span>")      'anything-c-grep-run-other-window-action)
    (define-key map (kbd "<span class="quote">C-w</span>")      'anything-yank-text-at-point)
    (define-key map (kbd "<span class="quote">C-x C-s</span>")  'anything-c-grep-run-save-buffer)
    (when anything-c-grep-use-ioccur-style-keys
      (define-key map (kbd "<span class="quote">&lt;right&gt;</span>")  'anything-c-grep-run-persistent-action)
      (define-key map (kbd "<span class="quote">&lt;left&gt;</span>")  'anything-c-grep-run-default-action))
    (define-key map (kbd "<span class="quote">C-c ?</span>")    'anything-grep-help)
    (delq nil map))
  "<span class="quote">Keymap used in Grep sources.</span>")

(defun anything-c-grep-run-persistent-action ()
  "<span class="quote">Run grep persistent action from `anything-do-grep1'.</span>"
  (interactive)
  (anything-execute-persistent-action 'jump-persistent))

(defun anything-c-grep-run-default-action ()
  "<span class="quote">Run grep default action from `anything-do-grep1'.</span>"
  (interactive)
  (anything-c-quit-and-execute-action 'anything-c-grep-action))

(defun anything-c-grep-run-other-window-action ()
  "<span class="quote">Run grep goto other window action from `anything-do-grep1'.</span>"
  (interactive)
  (anything-c-quit-and-execute-action 'anything-c-grep-other-window))

(defun anything-c-grep-run-save-buffer ()
  "<span class="quote">Run grep save results action from `anything-do-grep1'.</span>"
  (interactive)
  (anything-c-quit-and-execute-action 'anything-c-grep-save-results))

<span class="linecomment">;; Grep buffers</span>
(defun anything-c-grep-buffers-1 (candidate &optional zgrep)
  "<span class="quote">Run grep on all file--buffers or CANDIDATE if it is a file--buffer.
If one of selected buffers is not a file--buffer,
it is ignored and grep will run on all others file--buffers.
If only one candidate is selected and it is not a file--buffer,
switch to this buffer and run `anything-occur'.
If a prefix arg is given run grep on all buffers ignoring non--file-buffers.</span>"
  (let* ((prefarg (or current-prefix-arg anything-current-prefix-arg))
         (cands (if prefarg
                    (buffer-list)
                    (anything-marked-candidates)))
         (bufs (loop for buf in cands
                  for fname = (buffer-file-name (get-buffer buf))
                  when fname
                  collect (expand-file-name fname))))
    (if bufs
        (if zgrep
            (anything-do-grep1 bufs nil 'zgrep)
            (anything-do-grep1 bufs))
        <span class="linecomment">;; bufs is empty, thats mean we have only CANDIDATE</span>
        <span class="linecomment">;; and it is not a buffer-filename, fallback to occur.</span>
        (switch-to-buffer candidate)
        (when (get-buffer anything-action-buffer)
          (kill-buffer anything-action-buffer))
        (anything-occur))))

(defun anything-c-grep-buffers (candidate)
  "<span class="quote">Action to grep buffers.</span>"
  (anything-c-grep-buffers-1 candidate))

(defun anything-c-zgrep-buffers (candidate)
  "<span class="quote">Action to zgrep buffers.</span>"
  (anything-c-grep-buffers-1 candidate 'zgrep))

<span class="linecomment">;;; Anything interface for pdfgrep</span>
<span class="linecomment">;;  pdfgrep program &lt;http://pdfgrep.sourceforge.net/&gt;</span>
<span class="linecomment">;;  and a pdf-reader (e.g xpdf) are needed.</span>
<span class="linecomment">;;</span>
(defvar anything-c-pdfgrep-default-command "<span class="quote">pdfgrep --color never -niH %s %s</span>")
(defvar anything-c-pdfgrep-default-function 'anything-c-pdfgrep-init)
(defvar anything-c-pdfgrep-debug-command-line nil)
(defcustom anything-c-pdfgrep-default-read-command "<span class="quote">xpdf '%f' %p</span>"
  "<span class="quote">Default command to read pdf files from pdfgrep.
Where '%f' format spec is filename and '%p' is page number</span>"
  :group 'anything-config
  :type 'string)

(defun anything-c-pdfgrep-init (only-files)
  "<span class="quote">Start an asynchronous pdfgrep process in ONLY-FILES list.</span>"
  (let* ((fnargs   (anything-c-grep-prepare-candidates
                    (if (file-remote-p anything-ff-default-directory)
                        (mapcar #'(lambda (x)
                                    (file-remote-p x 'localname))
                                only-files)
                        only-files)))
         (cmd-line (format anything-c-pdfgrep-default-command
                           anything-pattern
                           fnargs)))
    (when anything-c-pdfgrep-debug-command-line
      (with-current-buffer (get-buffer-create "<span class="quote">*any pdfgrep debug*</span>")
        (goto-char (point-max))
        (insert (concat "<span class="quote">&gt;&gt;&gt; </span>" cmd-line "<span class="quote">\n\n</span>"))))
    (setq mode-line-format
          '("<span class="quote"> </span>" mode-line-buffer-identification "<span class="quote"> </span>"
            (line-number-mode "<span class="quote">%l</span>") "<span class="quote"> </span>"
            (:eval (propertize "<span class="quote">(Pdfgrep Process Running) </span>"
                    'face '((:foreground "<span class="quote">red</span>"))))))
    (prog1
        (let ((default-directory anything-ff-default-directory))
          (start-file-process-shell-command "<span class="quote">pdfgrep-process</span>" nil cmd-line))
      (message nil)
      (set-process-sentinel
       (get-process "<span class="quote">pdfgrep-process</span>")
       #'(lambda (process event)
           (when (string= event "<span class="quote">finished\n</span>")
             (kill-local-variable 'mode-line-format)
             (with-anything-window
               (anything-update-move-first-line))))))))


(defun anything-do-pdfgrep-1 (only)
  "<span class="quote">Launch pdfgrep with a list of ONLY files.</span>"
  (unless (executable-find "<span class="quote">pdfgrep</span>")
    (error "<span class="quote">Error: No such program `pdfgrep'.</span>"))
  (let* ((anything-compile-source-functions
          <span class="linecomment">;; rule out anything-match-plugin because the input is one regexp.</span>
          (delq 'anything-compile-source--match-plugin
                (copy-sequence anything-compile-source-functions)))
         <span class="linecomment">;; Disable match-plugin and use here own highlighting.</span>
         (anything-mp-highlight-delay nil))
    <span class="linecomment">;; When called as action from an other source e.g *-find-files</span>
    <span class="linecomment">;; we have to kill action buffer.</span>
    (when (get-buffer anything-action-buffer)
      (kill-buffer anything-action-buffer))
    <span class="linecomment">;; If `anything-find-files' haven't already started,</span>
    <span class="linecomment">;; give a default value to `anything-ff-default-directory'.</span>
    (setq anything-ff-default-directory (or anything-ff-default-directory
                                            default-directory))
    (anything
     :sources
     `(((name . "<span class="quote">PdfGrep</span>")
        (candidates
         . (lambda ()
             (funcall anything-c-pdfgrep-default-function only)))
        (filtered-candidate-transformer anything-c-grep-cand-transformer)
        (candidate-number-limit . 9999)
        (mode-line . anything-pdfgrep-mode-line-string)
        (action . anything-c-pdfgrep-action)
        (persistent-help . "<span class="quote">Jump to PDF Page</span>")
        (requires-pattern . 3)
        (delayed)))
     :keymap anything-c-pdfgrep-map
     :buffer "<span class="quote">*anything grep*</span>")))

(defvar anything-pdfgrep-mode-line-string
  "<span class="quote">\\&lt;anything-c-pdfgrep-map&gt;\
\\[anything-pdfgrep-help]:Help,\
\\&lt;anything-map&gt;\
\\[anything-select-action]:Acts,\
\\[anything-exit-minibuffer]/\\[anything-select-2nd-action-or-end-of-line]/\
\\[anything-select-3rd-action]:NthAct,\
\\[anything-send-bug-report-from-anything]:BugReport.</span>"
  "<span class="quote">String displayed in mode-line in `anything-do-pdfgrep'.</span>")

<span class="linecomment">;;;###autoload</span>
(defun anything-pdfgrep-help ()
  (interactive)
  (let ((anything-help-message "<span class="quote">== Anything PdfGrep Map ==\
\nSpecific commands for Pdf Grep:
\\&lt;anything-c-pdfgrep-map&gt;
\\[anything-c-goto-next-file]\t-&gt;Next File.
\\[anything-c-goto-precedent-file]\t\t-&gt;Precedent File.
\\[anything-yank-text-at-point]\t\t-&gt;Yank Text at point in minibuffer.
\\[anything-pdfgrep-help]\t\t-&gt;Show this help.
\n== Anything Map ==
\\{anything-map}</span>"))
    (anything-help)))

(defvar anything-c-pdfgrep-map
  (let ((map (copy-keymap anything-map)))
    (define-key map (kbd "<span class="quote">M-&lt;down&gt;</span>") 'anything-c-goto-next-file)
    (define-key map (kbd "<span class="quote">M-&lt;up&gt;</span>")   'anything-c-goto-precedent-file)
    (define-key map (kbd "<span class="quote">C-w</span>")      'anything-yank-text-at-point)
    (define-key map (kbd "<span class="quote">C-c ?</span>")    'anything-pdfgrep-help)
    map)
  "<span class="quote">Keymap used in pdfgrep.</span>")

(defun anything-c-pdfgrep-action (candidate)
  (let* ((split  (anything-c-grep-split-line candidate))
         (pageno (nth 1 split))
         (fname  (car split)))
    (start-file-process-shell-command
     "<span class="quote">pdf-reader</span>" nil
     (format-spec anything-c-pdfgrep-default-read-command
                  (list (cons ?f fname) (cons ?p pageno))))))

(defun anything-do-pdfgrep ()
  (interactive)
  (let ((only (anything-c-read-file-name
               "<span class="quote">Search in file(s): </span>"
               :marked-candidates t
               :test #'(lambda (file)
                         (or (string= (file-name-extension file) "<span class="quote">pdf</span>")
                             (string= (file-name-extension file) "<span class="quote">PDF</span>")
                             (file-directory-p file)))
               :preselect (or (dired-get-filename nil t)
                              (buffer-file-name (current-buffer)))))
        (anything-c-grep-default-function 'anything-c-pdfgrep-init))
    (anything-do-pdfgrep-1 only)))


<span class="linecomment">;; Yank text at point.</span>
<span class="linecomment">;;</span>
(defvar anything-yank-point nil)
<span class="linecomment">;;;###autoload</span>
(defun anything-yank-text-at-point ()
  "<span class="quote">Yank text at point in minibuffer.</span>"
  (interactive)
  (let (input)
    (flet ((insert-in-minibuffer (word)
             (with-selected-window (minibuffer-window)
               (let ((str anything-pattern))
                 (delete-minibuffer-contents)
                 (set-text-properties 0 (length word) nil word)
                 (insert (concat str word))))))
      (with-current-buffer anything-current-buffer
        <span class="linecomment">;; Start to initial point if C-w have never been hit.</span>
        (unless anything-yank-point (setq anything-yank-point (point)))
        (and anything-yank-point (goto-char anything-yank-point))
        (forward-word 1)
        (setq input (buffer-substring-no-properties anything-yank-point (point)))
        (setq anything-yank-point (point))) <span class="linecomment">; End of last forward-word</span>
      (insert-in-minibuffer input))))

(defun anything-reset-yank-point ()
  (setq anything-yank-point nil))

(add-hook 'anything-after-persistent-action-hook 'anything-reset-yank-point)
(add-hook 'anything-cleanup-hook 'anything-reset-yank-point)
(define-key anything-map (kbd "<span class="quote">C-w</span>") 'anything-yank-text-at-point)

<span class="linecomment">;;; Etags</span>
<span class="linecomment">;;</span>
(eval-when-compile
  (when (locate-library "<span class="quote">anything-etags.el</span>")
    (display-warning
     '(anything-config)
     "<span class="quote">You are using obsolete library `anything-etags.el' and should remove it.</span>"
     :warning)))

<span class="linecomment">;;;###autoload</span>
(defun anything-etags-help ()
  (interactive)
  (let ((anything-help-message "<span class="quote">== Anything Etags Map ==\
\nSpecific commands for Etags:
\\&lt;anything-c-etags-map&gt;
\\[anything-c-goto-next-file]\t-&gt;Next File.
\\[anything-c-goto-precedent-file]\t\t-&gt;Precedent File.
\\[anything-yank-text-at-point]\t\t-&gt;Yank Text at point in minibuffer.
\\[anything-etags-help]\t\t-&gt;Show this help.
\n== Anything Map ==
\\{anything-map}</span>"))
    (anything-help)))

(defvar anything-c-etags-map
  (let ((map (copy-keymap anything-map)))
    (define-key map (kbd "<span class="quote">M-&lt;down&gt;</span>") 'anything-c-goto-next-file)
    (define-key map (kbd "<span class="quote">M-&lt;up&gt;</span>")   'anything-c-goto-precedent-file)
    (define-key map (kbd "<span class="quote">C-w</span>")      'anything-yank-text-at-point)
    (define-key map (kbd "<span class="quote">C-c ?</span>")    'anything-etags-help)
    map)
  "<span class="quote">Keymap used in Etags.</span>")

(defcustom anything-c-etags-tag-file-name "<span class="quote">TAGS</span>"
  "<span class="quote">Etags tag file name.</span>"
  :type 'string
  :group 'anything-config)

(defcustom anything-c-etags-tag-file-search-limit 10
  "<span class="quote">The limit level of directory to search tag file.
Don't search tag file deeply if outside this value.</span>"
  :type 'number
  :group 'anything-config)

(defvar anything-c-etags-tag-file-dir nil
  "<span class="quote">Etags file directory.</span>")
(defvar anything-c-etags-mtime-alist nil)
(defvar anything-c-etags-cache (make-hash-table :test 'equal))

(defun anything-c-etags-get-tag-file ()
  "<span class="quote">Get Etags tag file.</span>"
  <span class="linecomment">;; Get tag file from `default-directory' or upper directory.</span>
  (let ((current-dir (anything-c-etags-find-tag-file default-directory)))
    <span class="linecomment">;; Return nil if not find tag file.</span>
    (when current-dir
      (setq anything-c-etags-tag-file-dir current-dir) <span class="linecomment">;set tag file directory</span>
      (expand-file-name anything-c-etags-tag-file-name current-dir))))

(defun anything-c-etags-find-tag-file (current-dir)
  "<span class="quote">Find tag file.
Try to find tag file in upper directory if haven't found in CURRENT-DIR.</span>"
  (flet ((file-exists? (dir)
           (let ((tag-path (expand-file-name anything-c-etags-tag-file-name dir)))
             (and (stringp tag-path)
                  (file-exists-p tag-path)
                  (file-readable-p tag-path)))))
    (loop with count = 0
       until (file-exists? current-dir)
       <span class="linecomment">;; Return nil if outside the value of</span>
       <span class="linecomment">;; `anything-c-etags-tag-file-search-limit'.</span>
       if (= count anything-c-etags-tag-file-search-limit)
       do (return nil)
       <span class="linecomment">;; Or search upper directories.</span>
       else
       do (incf count)
         (setq current-dir (expand-file-name (concat current-dir "<span class="quote">../</span>")))
       finally return current-dir)))

(defun anything-c-source-etags-header-name (x)
  (concat "<span class="quote">Etags in </span>"
          (with-current-buffer anything-current-buffer
            (anything-c-etags-get-tag-file))
          "<span class="quote"> (C-c ? Help)</span>"))

(defmacro anything-c-etags-create-buffer (file)
  `(let* ((tag-fname ,file)
          max
          (split (with-current-buffer (find-file-noselect tag-fname)
                   (prog1
                       (split-string (buffer-string) "<span class="quote">\n</span>" 'omit-nulls)
                     (setq max (line-number-at-pos (point-max)))
                     (kill-buffer))))
          (progress-reporter (make-progress-reporter "<span class="quote">Loading tag file...</span>" 0 max)))
     (loop
        with fname
        with cand
        for i in split for count from 0
        for elm = (unless (string-match "<span class="quote">^\x0c</span>" i)
                    (anything-aif (string-match "<span class="quote">\177</span>" i)
                        (substring i 0 it)
                      i))
        do (cond ((and elm (string-match "<span class="quote">^\\(.+\\),[0-9]+</span>" elm))
                  (setq fname (match-string 1 elm)))
                 (elm (setq cand (concat fname "<span class="quote">: </span>" elm)))
                 (t (setq cand nil)))
        when cand do (progn
                       (insert (concat cand "<span class="quote">\n</span>"))
                       (progress-reporter-update progress-reporter count)))))

(defun anything-c-etags-init ()
  (let ((tagfile (anything-c-etags-get-tag-file)))
    (when tagfile
      (with-current-buffer (anything-candidate-buffer 'global)
       (anything-aif (gethash tagfile anything-c-etags-cache)
           (insert it)
         (anything-c-etags-create-buffer tagfile)
         (puthash tagfile (buffer-string) anything-c-etags-cache)
         (anything-aif (assoc tagfile anything-c-etags-mtime-alist)
             <span class="linecomment">;; If an entry exists modify it.</span>
             (setcdr it (anything-c-etags-mtime tagfile))
           <span class="linecomment">;; No entry create a new one.</span>
           (add-to-list 'anything-c-etags-mtime-alist
                        (cons tagfile (anything-c-etags-mtime tagfile)))))))))

(defvar anything-c-source-etags-select
  '((name . "<span class="quote">Etags</span>")
    (header-name . anything-c-source-etags-header-name)
    (init . anything-c-etags-init)
    (candidates-in-buffer)
    (mode-line . anything-ff-mode-line-string)
    (action . anything-c-etags-default-action)
    (persistent-action . (lambda (candidate)
                           (anything-c-etags-default-action candidate)
                           (anything-match-line-color-current-line)))))

(defun anything-c-etags-default-action (candidate)
  (let* ((split (split-string candidate "<span class="quote">: </span>"))
         (fname (expand-file-name
                 (car split) anything-c-etags-tag-file-dir))
         (elm   (cadr split)))
    (find-file fname)
    (goto-char (point-min))
    (search-forward elm nil t)
    (goto-char (match-beginning 0))))

(defun anything-c-etags-select (arg)
  "<span class="quote">Preconfigured anything for etags.
Called with one prefix arg use symbol at point as initial input.
Called with two prefix arg reinitialize cache.
If tag file have been modified reinitialize cache.</span>"
  (interactive "<span class="quote">P</span>")
  (let ((tag  (anything-c-etags-get-tag-file))
        (init (and (equal arg '(4)) (thing-at-point 'symbol)))
        (anything-quit-if-no-candidate t)
        (anything-execute-action-at-once-if-one t))
    (when (or (equal arg '(16))
              (and anything-c-etags-mtime-alist
                   (anything-c-etags-file-modified-p tag)))
      (remhash tag anything-c-etags-cache))
    (if (and tag (file-exists-p tag))
        (anything :sources 'anything-c-source-etags-select
                  :keymap anything-c-etags-map
                  :input init
                  :buffer "<span class="quote">*anything etags*</span>")
        (message "<span class="quote">Error: No tag file found, please create one with etags shell command.</span>"))))

(defun anything-c-etags-mtime (file)
  "<span class="quote">Last modification time of FILE.</span>"
  (cadr (nth 5 (file-attributes file))))

(defun anything-c-etags-file-modified-p (file)
  "<span class="quote">Check if tag FILE have been modified in this session.
If FILE is nil return nil.</span>"
  (let ((last-modif (and file
                         (assoc-default file anything-c-etags-mtime-alist))))
    (and last-modif
         (/= last-modif (anything-c-etags-mtime file)))))

<span class="linecomment">;;; Recentf files</span>
(defvar anything-c-source-recentf
  '((name . "<span class="quote">Recentf</span>")
    (init . (lambda ()
              (require 'recentf)
              (or recentf-mode (recentf-mode 1))
              <span class="linecomment">;; Big value empowers anything/recentf</span>
              (when (and (numberp recentf-max-saved-items)
                         (&lt;= recentf-max-saved-items 20))
                (setq recentf-max-saved-items 500))))
    (candidates . recentf-list)
    (match anything-c-match-on-file-name
     anything-c-match-on-directory-name)
    (type . file))
  "<span class="quote">See (info \"(emacs)File Conveniences\").
if `recentf-max-saved-items' is too small, set it to 500.</span>")
<span class="linecomment">;; (anything 'anything-c-source-recentf)</span>

<span class="linecomment">;;; ffap</span>
(eval-when-compile (require 'ffap))
(defvar anything-c-source-ffap-guesser
  '((name . "<span class="quote">File at point</span>")
    (init . (lambda () (require 'ffap)))
    (candidates . (lambda ()
                    (anything-aif
                        (with-current-buffer anything-current-buffer
                          (ffap-guesser))
                        (list it))))
    (type . file)))
<span class="linecomment">;; (anything 'anything-c-source-ffap-guesser)</span>

<span class="linecomment">;;; ffap with line number</span>
(defun anything-c-ffap-file-line-at-point ()
  "<span class="quote">Get (FILENAME . LINENO) at point.</span>"
  (anything-aif (let (ffap-alist) (ffap-file-at-point))
      (save-excursion
        (beginning-of-line)
        (when (and (search-forward it nil t)
                   (looking-at "<span class="quote">:\\([0-9]+\\)</span>"))
          (cons it (string-to-number (match-string 1)))))))

(defvar anything-c-ffap-line-location nil
  "<span class="quote">(FILENAME . LINENO) used by `anything-c-source-ffap-line'.
It is cleared after jumping line.</span>")

(defun anything-c-ffap-line-candidates ()
  (with-current-buffer anything-current-buffer
    (setq anything-c-ffap-line-location (anything-c-ffap-file-line-at-point)))
  (when anything-c-ffap-line-location
    (destructuring-bind (file . line) anything-c-ffap-line-location
      (list (cons (format "<span class="quote">%s (line %d)</span>" file line) file)))))

<span class="linecomment">;;; Goto line after opening file by `anything-c-source-ffap-line'.</span>
(defun anything-c-ffap-line-goto-line ()
  (when (car anything-c-ffap-line-location)
    (unwind-protect
         (ignore-errors
           (with-selected-window
               (get-buffer-window
                (get-file-buffer (car anything-c-ffap-line-location)))
             (anything-goto-line (cdr anything-c-ffap-line-location)))))))
(add-hook 'anything-after-action-hook 'anything-c-ffap-line-goto-line)
(add-hook 'anything-after-persistent-action-hook 'anything-c-ffap-line-goto-line)

(defvar anything-c-source-ffap-line
  '((name . "<span class="quote">File/Lineno at point</span>")
    (init . (lambda () (require 'ffap)))
    (candidates . anything-c-ffap-line-candidates)
    (type . file)))
<span class="linecomment">;; (anything 'anything-c-source-ffap-line)</span>

<span class="linecomment">;;; list of files gleaned from every dired buffer</span>
(defun anything-c-files-in-all-dired-candidates ()
  (save-excursion
    (mapcan
     (lambda (dir)
       (cond ((listp dir)               <span class="linecomment">;filelist</span>
              dir)
             ((equal "<span class="quote"></span>" (file-name-nondirectory dir)) <span class="linecomment">;dir</span>
              (directory-files dir t))
             (t                         <span class="linecomment">;wildcard</span>
              (file-expand-wildcards dir t))))
     (delq nil
           (mapcar (lambda (buf)
                     (set-buffer buf)
                     (when (eq major-mode 'dired-mode)
                       (if (consp dired-directory)
                           (cdr dired-directory) <span class="linecomment">;filelist</span>
                           dired-directory))) <span class="linecomment">;dir or wildcard</span>
                   (buffer-list))))))
<span class="linecomment">;; (dired '("~/" "~/.emacs-custom.el" "~/.emacs.bmk"))</span>

(defvar anything-c-source-files-in-all-dired
  '((name . "<span class="quote">Files in all dired buffer.</span>")
    (candidates . anything-c-files-in-all-dired-candidates)
    (type . file)))
<span class="linecomment">;; (anything 'anything-c-source-files-in-all-dired)</span>

(defcustom anything-c-filelist-file-name nil
  "<span class="quote">*Filename of file list.
Accept a list of string for multiple files.

This file tend to be very large (&gt; 100MB) and recommend to be in ramdisk for speed.
File list is created by make-filelist.rb script.

Usage:
  ruby make-filelist.rb &gt; /tmp/all.filelist

Then
 ;; Assume that /tmp is ramdisk or tmpfs
 (setq anything-grep-candidates-fast-directory-regexp \"^/tmp/\")
 (setq anything-c-filelist-file-name \"/tmp/all.filelist\")
</span>"
  :type 'string
  :group 'anything-config)
(defvar anything-c-source-filelist
  '((name . "<span class="quote">FileList</span>")
    (grep-candidates . anything-c-filelist-file-name)
    (candidate-number-limit . 200)
    (requires-pattern . 4)
    (type . file))
  "<span class="quote">Source to find files instantly.
See `anything-c-filelist-file-name' docstring for usage.</span>")

<span class="linecomment">;;;###autoload</span>
(defun anything-filelist ()
  "<span class="quote">Preconfigured `anything' to open files instantly.

See `anything-c-filelist-file-name' docstring for usage.</span>"
  (interactive)
  (anything-other-buffer 'anything-c-source-filelist "<span class="quote">*anything file list*</span>"))

<span class="linecomment">;;;###autoload</span>
(defun anything-filelist+ ()
  "<span class="quote">Preconfigured `anything' to open files/buffers/bookmarks instantly.

This is a replacement for `anything-for-files'.
See `anything-c-filelist-file-name' docstring for usage.</span>"
  (interactive)
  (anything-other-buffer
   '(anything-c-source-ffap-line
     anything-c-source-ffap-guesser
     anything-c-source-buffers+
     anything-c-source-recentf
     anything-c-source-bookmarks
     anything-c-source-file-cache
     anything-c-source-filelist)
   "<span class="quote">*anything file list*</span>"))


<span class="linecomment">;;;; &lt;info&gt;</span>
<span class="linecomment">;;; Info pages</span>
(defvar anything-c-info-pages nil
  "<span class="quote">All info pages on system.
Will be calculated the first time you invoke anything with this
source.</span>")

(defvar anything-c-source-info-pages
  `((name . "<span class="quote">Info Pages</span>")
    (candidates
     . (lambda ()
         (if anything-c-info-pages
             anything-c-info-pages
             (setq anything-c-info-pages
                   (save-window-excursion
                     (save-excursion
                       (require 'info)
                       (Info-find-node "<span class="quote">dir</span>" "<span class="quote">top</span>")
                       (goto-char (point-min))
                       (let ((info-topic-regexp "<span class="quote">\\* +\\([^:]+: ([^)]+)[^.]*\\)\\.</span>")
                             topics)
                         (while (re-search-forward info-topic-regexp nil t)
                           (add-to-list 'topics (match-string-no-properties 1)))
                         (goto-char (point-min))
                         (Info-exit)
                         topics)))))))
    (action . (("<span class="quote">Show with Info</span>" .(lambda (node-str)
                                    (info (replace-regexp-in-string
                                           "<span class="quote">^[^:]+: </span>" "<span class="quote"></span>" node-str))))))
    (requires-pattern . 2)))
<span class="linecomment">;; (anything 'anything-c-source-info-pages)</span>


<span class="linecomment">;; FIXME should be merged in anything.el with `anything-describe-anything-attribute'.</span>
(defun anything-c-describe-attributes (anything-attribute)
  "<span class="quote">Display the full documentation of ANYTHING-ATTRIBUTE (a symbol).
Same as `anything-describe-anything-attribute' but with anything completion.</span>"
  (interactive (list (intern
                      (anything-comp-read
                       "<span class="quote">Describe anything attribute: </span>"
                       (mapcar 'symbol-name anything-additional-attributes)
                       :must-match t
                       :persistent-action
                       #'(lambda (candidate)
                           (with-output-to-temp-buffer "<span class="quote">*Help*</span>"
                             (princ (get (intern candidate) 'anything-attrdoc))))))))
  (with-output-to-temp-buffer "<span class="quote">*Help*</span>"
    (princ (get anything-attribute 'anything-attrdoc))))

<span class="linecomment">;;; Use info-index plug-in. Note that `name' attribute is</span>
<span class="linecomment">;;; not needed but `anything-c-insert-summary' uses it.</span>
<span class="linecomment">;; Info Elisp</span>
(defvar anything-c-source-info-elisp
  '((name . "<span class="quote">Info index: elisp</span>")
    (info-index . "<span class="quote">elisp</span>")))
<span class="linecomment">;; (anything 'anything-c-source-info-elisp)</span>

<span class="linecomment">;; Info-Common-Lisp</span>
(defvar anything-c-source-info-cl
  '((name . "<span class="quote">Info index: cl</span>")
    (info-index . "<span class="quote">cl</span>")))
<span class="linecomment">;; (anything 'anything-c-source-info-cl)</span>

<span class="linecomment">;; Info Index org</span>
(defvar anything-c-source-info-org
  '((name . "<span class="quote">Info index: org</span>")
    (info-index . "<span class="quote">org</span>")))
<span class="linecomment">;; (anything 'anything-c-source-info-org)</span>

<span class="linecomment">;; Info Index ratpoison</span>
(defvar anything-c-source-info-ratpoison
  '((name . "<span class="quote">Info index: ratpoison</span>")
    (info-index . "<span class="quote">ratpoison</span>")))
<span class="linecomment">;; (anything 'anything-c-source-info-ratpoison)</span>

<span class="linecomment">;; Info Index zsh</span>
(defvar anything-c-source-info-zsh
  '((name . "<span class="quote">Info index: zsh</span>")
    (info-index . "<span class="quote">zsh</span>")))
<span class="linecomment">;; (anything 'anything-c-source-info-zsh)</span>

<span class="linecomment">;; Info Index bash</span>
(defvar anything-c-source-info-bash
  '((name . "<span class="quote">Info index: bash</span>")
    (info-index . "<span class="quote">bash</span>")))
<span class="linecomment">;; (anything 'anything-c-source-info-bash)</span>

<span class="linecomment">;; Info Index coreutils</span>
(defvar anything-c-source-info-coreutils
  '((name . "<span class="quote">Info index: coreutils</span>")
    (info-index . "<span class="quote">coreutils</span>")))
<span class="linecomment">;; (anything 'anything-c-source-info-coreutils)</span>

<span class="linecomment">;; Info Index fileutils</span>
(defvar anything-c-source-info-fileutils
  '((name . "<span class="quote">Info index: fileutils</span>")
    (info-index . "<span class="quote">fileutils</span>")))
<span class="linecomment">;; (anything 'anything-c-source-info-fileutils)</span>

<span class="linecomment">;; Info Index find</span>
(defvar anything-c-source-info-find
  '((name . "<span class="quote">Info index: find</span>")
    (info-index . "<span class="quote">find</span>")))
<span class="linecomment">;; (anything 'anything-c-source-info-find)</span>

<span class="linecomment">;; Info Index sh-utils</span>
(defvar anything-c-source-info-sh-utils
  '((name . "<span class="quote">Info index: sh-utils</span>")
    (info-index . "<span class="quote">sh-utils</span>")))
<span class="linecomment">;; (anything 'anything-c-source-info-sh-utils)</span>

<span class="linecomment">;; Info Index textutils</span>
(defvar anything-c-source-info-textutils
  '((name . "<span class="quote">Info index: textutils</span>")
    (info-index . "<span class="quote">textutils</span>")))
<span class="linecomment">;; (anything 'anything-c-source-info-textutils)</span>

<span class="linecomment">;; Info Index libc</span>
(defvar anything-c-source-info-libc
  '((name . "<span class="quote">Info index: libc</span>")
    (info-index . "<span class="quote">libc</span>")))
<span class="linecomment">;; (anything 'anything-c-source-info-libc)</span>

<span class="linecomment">;; Info Index make</span>
(defvar anything-c-source-info-make
  '((name . "<span class="quote">Info index: make</span>")
    (info-index . "<span class="quote">make</span>")))
<span class="linecomment">;; (anything 'anything-c-source-info-make)</span>

<span class="linecomment">;; Info Index automake</span>
(defvar anything-c-source-info-automake
  '((name . "<span class="quote">Info index: automake</span>")
    (info-index . "<span class="quote">automake</span>")))
<span class="linecomment">;; (anything 'anything-c-source-info-automake)</span>

<span class="linecomment">;; Info Index autoconf</span>
(defvar anything-c-source-info-autoconf
  '((name . "<span class="quote">Info index: autoconf</span>")
    (info-index . "<span class="quote">autoconf</span>")))
<span class="linecomment">;; (anything 'anything-c-source-info-autoconf)</span>

<span class="linecomment">;; Info Index emacs-lisp-intro</span>
(defvar anything-c-source-info-emacs-lisp-intro
  '((name . "<span class="quote">Info index: emacs-lisp-intro</span>")
    (info-index . "<span class="quote">emacs-lisp-intro</span>")))
<span class="linecomment">;; (anything 'anything-c-source-info-emacs-lisp-intro)</span>

<span class="linecomment">;; Info Index emacs</span>
(defvar anything-c-source-info-emacs
  '((name . "<span class="quote">Info index: emacs</span>")
    (info-index . "<span class="quote">emacs</span>")))
<span class="linecomment">;; (anything 'anything-c-source-info-emacs)</span>

<span class="linecomment">;; Info Index elib</span>
(defvar anything-c-source-info-elib
  '((name . "<span class="quote">Info index: elib</span>")
    (info-index . "<span class="quote">elib</span>")))
<span class="linecomment">;; (anything 'anything-c-source-info-elib)</span>

<span class="linecomment">;; Info Index eieio</span>
(defvar anything-c-source-info-eieio
  '((name . "<span class="quote">Info index: eieio</span>")
    (info-index . "<span class="quote">eieio</span>")))
<span class="linecomment">;; (anything 'anything-c-source-info-eieio)</span>

<span class="linecomment">;; Info Index gauche-refe</span>
(defvar anything-c-source-info-gauche-refe
  '((name . "<span class="quote">Info index: gauche</span>")
    (info-index . "<span class="quote">gauche-refe</span>")))
<span class="linecomment">;; (anything 'anything-c-source-info-gauche-refe)</span>

<span class="linecomment">;; Info Index guile</span>
(defvar anything-c-source-info-guile
  '((name . "<span class="quote">Info index: guile</span>")
    (info-index . "<span class="quote">guile</span>")))
<span class="linecomment">;; (anything 'anything-c-source-info-guile)</span>

<span class="linecomment">;; Info Index guile-tut</span>
(defvar anything-c-source-info-guile-tut
  '((name . "<span class="quote">Info index: guile-tut</span>")
    (info-index . "<span class="quote">guile-tut</span>")))
<span class="linecomment">;; (anything 'anything-c-source-info-guile-tut)</span>

<span class="linecomment">;; Info Index goops</span>
(defvar anything-c-source-info-goops
  '((name . "<span class="quote">Info index: goops</span>")
    (info-index . "<span class="quote">goops</span>")))
<span class="linecomment">;; (anything 'anything-c-source-info-goops)</span>

<span class="linecomment">;; Info Index screen</span>
(defvar anything-c-source-info-screen
  '((name . "<span class="quote">Info index: screen</span>")
    (info-index . "<span class="quote">screen</span>")
    (index-nodes "<span class="quote">Concept Index</span>" "<span class="quote">Command Index</span>" "<span class="quote">Keystroke Index</span>")))
<span class="linecomment">;; (anything 'anything-c-source-info-screen)</span>

<span class="linecomment">;; Info Index latex</span>
(defvar anything-c-source-info-latex
  '((name . "<span class="quote">Info index: latex</span>")
    (info-index . "<span class="quote">latex</span>")))
<span class="linecomment">;; (anything 'anything-c-source-info-latex)</span>

<span class="linecomment">;; Info Index gawk</span>
(defvar anything-c-source-info-gawk
  '((name . "<span class="quote">Info index: gawk</span>")
    (info-index . "<span class="quote">gawk</span>")))
<span class="linecomment">;; (anything 'anything-c-source-info-gawk)</span>

<span class="linecomment">;; Info Index sed</span>
(defvar anything-c-source-info-sed
  '((name . "<span class="quote">Info index: sed</span>")
    (info-index . "<span class="quote">sed</span>")))
<span class="linecomment">;; (anything 'anything-c-source-info-sed)</span>

<span class="linecomment">;; Info Index m4</span>
(defvar anything-c-source-info-m4
  '((name . "<span class="quote">Info index: m4</span>")
    (info-index . "<span class="quote">m4</span>")))
<span class="linecomment">;; (anything 'anything-c-source-info-m4)</span>

<span class="linecomment">;; Info Index wget</span>
(defvar anything-c-source-info-wget
  '((name . "<span class="quote">Info index: wget</span>")
    (info-index . "<span class="quote">wget</span>")))
<span class="linecomment">;; (anything 'anything-c-source-info-wget)</span>

<span class="linecomment">;; Info Index binutils</span>
(defvar anything-c-source-info-binutils
  '((name . "<span class="quote">Info index: binutils</span>")
    (info-index . "<span class="quote">binutils</span>")))
<span class="linecomment">;; (anything 'anything-c-source-info-binutils)</span>

<span class="linecomment">;; Info Index as</span>
(defvar anything-c-source-info-as
  '((name . "<span class="quote">Info index: as</span>")
    (info-index . "<span class="quote">as</span>")))
<span class="linecomment">;; (anything 'anything-c-source-info-as)</span>

<span class="linecomment">;; Info Index bfd</span>
(defvar anything-c-source-info-bfd
  '((name . "<span class="quote">Info index: bfd</span>")
    (info-index . "<span class="quote">bfd</span>")))
<span class="linecomment">;; (anything 'anything-c-source-info-bfd)</span>

<span class="linecomment">;; Info Index gprof</span>
(defvar anything-c-source-info-gprof
  '((name . "<span class="quote">Info index: gprof</span>")
    (info-index . "<span class="quote">gprof</span>")))
<span class="linecomment">;; (anything 'anything-c-source-info-gprof)</span>

<span class="linecomment">;; Info Index ld</span>
(defvar anything-c-source-info-ld
  '((name . "<span class="quote">Info index: ld</span>")
    (info-index . "<span class="quote">ld</span>")))
<span class="linecomment">;; (anything 'anything-c-source-info-ld)</span>

<span class="linecomment">;; Info Index diff</span>
(defvar anything-c-source-info-diff
  '((name . "<span class="quote">Info index: diff</span>")
    (info-index . "<span class="quote">diff</span>")))
<span class="linecomment">;; (anything 'anything-c-source-info-diff)</span>

<span class="linecomment">;; Info Index flex</span>
(defvar anything-c-source-info-flex
  '((name . "<span class="quote">Info index: flex</span>")
    (info-index . "<span class="quote">flex</span>")))
<span class="linecomment">;; (anything 'anything-c-source-info-flex)</span>

<span class="linecomment">;; Info Index grep</span>
(defvar anything-c-source-info-grep
  '((name . "<span class="quote">Info index: grep</span>")
    (info-index . "<span class="quote">grep</span>")))
<span class="linecomment">;; (anything 'anything-c-source-info-grep)</span>

<span class="linecomment">;; Info Index gzip</span>
(defvar anything-c-source-info-gzip
  '((name . "<span class="quote">Info index: gzip</span>")
    (info-index . "<span class="quote">gzip</span>")))
<span class="linecomment">;; (anything 'anything-c-source-info-gzip)</span>

<span class="linecomment">;; Info Index libtool</span>
(defvar anything-c-source-info-libtool
  '((name . "<span class="quote">Info index: libtool</span>")
    (info-index . "<span class="quote">libtool</span>")))
<span class="linecomment">;; (anything 'anything-c-source-info-libtool)</span>

<span class="linecomment">;; Info Index texinfo</span>
(defvar anything-c-source-info-texinfo
  '((name . "<span class="quote">Info index: texinfo</span>")
    (info-index . "<span class="quote">texinfo</span>")))
<span class="linecomment">;; (anything 'anything-c-source-info-texinfo)</span>

<span class="linecomment">;; Info Index info</span>
(defvar anything-c-source-info-info
  '((name . "<span class="quote">Info index: info</span>")
    (info-index . "<span class="quote">info</span>")))
<span class="linecomment">;; (anything 'anything-c-source-info-info)</span>

<span class="linecomment">;; Info Index gdb</span>
(defvar anything-c-source-info-gdb
  '((name . "<span class="quote">Info index: gdb</span>")
    (info-index . "<span class="quote">gdb</span>")))
<span class="linecomment">;; (anything 'anything-c-source-info-gdb)</span>

<span class="linecomment">;; Info Index stabs</span>
(defvar anything-c-source-info-stabs
  '((name . "<span class="quote">Info index: stabs</span>")
    (info-index . "<span class="quote">stabs</span>")))
<span class="linecomment">;; (anything 'anything-c-source-info-stabs)</span>

<span class="linecomment">;; Info Index cvsbook</span>
(defvar anything-c-source-info-cvsbook
  '((name . "<span class="quote">Info index: cvsbook</span>")
    (info-index . "<span class="quote">cvsbook</span>")))
<span class="linecomment">;; (anything 'anything-c-source-info-cvsbook)</span>

<span class="linecomment">;; Info Index cvs</span>
(defvar anything-c-source-info-cvs
  '((name . "<span class="quote">Info index: cvs</span>")
    (info-index . "<span class="quote">cvs</span>")))
<span class="linecomment">;; (anything 'anything-c-source-info-cvs)</span>

<span class="linecomment">;; Info Index bison</span>
(defvar anything-c-source-info-bison
  '((name . "<span class="quote">Info index: bison</span>")
    (info-index . "<span class="quote">bison</span>")))
<span class="linecomment">;; (anything 'anything-c-source-info-bison)</span>

<span class="linecomment">;; Info Index id-utils</span>
(defvar anything-c-source-info-id-utils
  '((name . "<span class="quote">Info index: id-utils</span>")
    (info-index . "<span class="quote">id-utils</span>")))
<span class="linecomment">;; (anything 'anything-c-source-info-id-utils)</span>

<span class="linecomment">;; Info Index global</span>
(defvar anything-c-source-info-global
  '((name . "<span class="quote">Info index: global</span>")
    (info-index . "<span class="quote">global</span>")))
<span class="linecomment">;; (anything 'anything-c-source-info-global)</span>

<span class="linecomment">;;;; &lt;Help&gt;</span>
<span class="linecomment">;;; Man Pages</span>
(defvar anything-c-man-pages nil
  "<span class="quote">All man pages on system.
Will be calculated the first time you invoke anything with this
source.</span>")

(defun anything-c-man-default-action (candidate)
  "<span class="quote">Default action for jumping to a woman or man page from anything.</span>"
  (let ((wfiles (woman-file-name-all-completions candidate)))
    (condition-case err
        (if (&gt; (length wfiles) 1)
            (woman-find-file (anything-comp-read "<span class="quote">ManFile: </span>" wfiles
                                                 :must-match t))
            (woman candidate))
            <span class="linecomment">;; If woman is unable to format correctly</span>
            <span class="linecomment">;; use man instead.</span>
      (error (kill-buffer) <span class="linecomment">; Kill woman buffer.</span>
             (man candidate)))))

(defvar anything-c-source-man-pages
  `((name . "<span class="quote">Manual Pages</span>")
    (candidates . (lambda ()
                    (if anything-c-man-pages
                        anything-c-man-pages
                        <span class="linecomment">;; XEmacs doesn't have a woman :)</span>
                        (setq anything-c-man-pages
                              (ignore-errors
                                (require 'woman)
                                (woman-file-name "<span class="quote"></span>")
                                (sort (mapcar 'car woman-topic-all-completions)
                                      'string-lessp))))))
    (action  ("<span class="quote">Show with Woman</span>" . anything-c-man-default-action))
    <span class="linecomment">;; Woman does not work OS X</span>
    <span class="linecomment">;; http://xahlee.org/emacs/modernization_man_page.html</span>
    (action-transformer . (lambda (actions candidate)
                            (if (eq system-type 'darwin)
                                '(("<span class="quote">Show with Man</span>" . man))
                                actions)))
    (requires-pattern . 2)))
<span class="linecomment">;; (anything 'anything-c-source-man-pages)</span>

<span class="linecomment">;;;; &lt;Command&gt;</span>
<span class="linecomment">;;; Complex command history</span>
(defvar anything-c-source-complex-command-history
  '((name . "<span class="quote">Complex Command History</span>")
    (candidates . (lambda () (mapcar 'prin1-to-string command-history)))
    (type . sexp)))
<span class="linecomment">;; (anything 'anything-c-source-complex-command-history)</span>

<span class="linecomment">;;; M-x history</span>
(defvar anything-c-source-extended-command-history
  '((name . "<span class="quote">Emacs Commands History</span>")
    (candidates . extended-command-history)
    (type . command)))
<span class="linecomment">;; (anything 'anything-c-source-extended-command-history)</span>

<span class="linecomment">;;; Emacs commands</span>
(defvar anything-c-source-emacs-commands
  '((name . "<span class="quote">Emacs Commands</span>")
    (candidates . (lambda ()
                    (let (commands)
                      (mapatoms (lambda (a)
                                  (if (commandp a)
                                      (push (symbol-name a)
                                            commands))))
                      (sort commands 'string-lessp))))
    (type . command)
    (requires-pattern . 2))
  "<span class="quote">Source for completing and invoking Emacs commands.
A command is a function with interactive spec that can
be invoked with `M-x'.

To get non-interactive functions listed, use
`anything-c-source-emacs-functions'.</span>")
<span class="linecomment">;; (anything 'anything-c-source-emacs-commands)</span>

<span class="linecomment">;;; Anything M-x</span>

<span class="linecomment">;; Another replacement of `M-x' that act exactly like the</span>
<span class="linecomment">;; vanilla Emacs one, no problem of windows configuration, prefix args</span>
<span class="linecomment">;; can be passed before calling `M-x' (e.g C-u M-x..) but also during</span>
<span class="linecomment">;; anything invocation.</span>
<span class="linecomment">;;;###autoload</span>
(defun anything-M-x ()
  "<span class="quote">Preconfigured `anything' for Emacs commands.
It is `anything' replacement of regular `M-x' `execute-extended-command'.</span>"
  (interactive)
  (let* (in-help
         help-cand
         (history (loop with hist
                     for i in extended-command-history
                     for com = (intern i)
                     when (and (fboundp com) (not (member i hist)))
                     collect i into hist finally return hist))
         (command (anything-comp-read
                   "<span class="quote">M-x </span>" obarray
                   :test 'commandp
                   :must-match t
                   :requires-pattern 2
                   :name "<span class="quote">Emacs Commands</span>"
                   :persistent-action
                   #'(lambda (candidate)
                       (if (and in-help (string= candidate help-cand))
                           (progn (kill-buffer "<span class="quote">*Help*</span>") (setq in-help nil))
                           (describe-function (intern candidate))
                           (setq in-help t))
                       (setq help-cand candidate))
                   :persistent-help "<span class="quote">Describe this command</span>"
                   :history history
                   :sort 'string-lessp
                   :fc-transformer 'anything-M-x-transformer)))
    (unless current-prefix-arg (setq current-prefix-arg anything-current-prefix-arg))
    (call-interactively (intern command))
    (setq extended-command-history (cons command (delete command history)))))

(defun* anything-M-x-get-major-mode-command-alist (mode-map)
  "<span class="quote">Return alist of MODE-MAP.</span>"
  (loop for key being the key-seqs of mode-map using (key-bindings com)
     for str-key  = (key-description key)
     for ismenu   = (string-match "<span class="quote">&lt;menu-bar&gt;</span>" str-key)
     unless ismenu collect (cons str-key com)))

(defun anything-get-mode-map-from-mode (mode)
  "<span class="quote">Guess the mode-map name according to MODE.
Some modes don't use conventional mode-map name
so we need to guess mode-map name. e.g python-mode ==&gt; py-mode-map.
Return nil if no mode-map found.</span>"
  (loop
     <span class="linecomment">;; Start with a conventional mode-map name.</span>
     with mode-map    = (intern-soft (format "<span class="quote">%s-map</span>" mode))
     with mode-string = (symbol-name mode)
     with mode-name   = (replace-regexp-in-string "<span class="quote">-mode</span>" "<span class="quote"></span>" mode-string)
     while (not mode-map)
     for count downfrom (length mode-name)
     <span class="linecomment">;; Return when no result after parsing entire string.</span>
     when (eq count 0) return nil
     for sub-name = (substring mode-name 0 count)
     do (setq mode-map (intern-soft (format "<span class="quote">%s-map</span>" (concat sub-name "<span class="quote">-mode</span>"))))
     finally return mode-map))

(defun anything-M-x-current-mode-map-alist ()
  "<span class="quote">Return mode-map alist of current `major-mode'.</span>"
  (let ((map (anything-get-mode-map-from-mode major-mode)))
    (when (and map (boundp map))
      (anything-M-x-get-major-mode-command-alist (symbol-value map)))))

(defface anything-M-x-key-face '((t (:foreground "<span class="quote">orange</span>" :underline t)))
  "<span class="quote">*Face used in anything-M-x to show keybinding.</span>"
  :group 'anything)

(defun anything-M-x-transformer (candidates sources)
  "<span class="quote">filtered-candidate-transformer to show bindings in emacs commands.
Show global bindings and local bindings according to current `major-mode'.</span>"
  (loop
     with local-map = (with-current-buffer anything-current-buffer
                        (anything-M-x-current-mode-map-alist))
     for i in candidates
     for cand       = (symbol-name i)
     for local-key  = (car (rassq i local-map))
     for key        = (substitute-command-keys (format "<span class="quote">\\[%s]</span>" cand))
     collect
       (cons (if (string-match "<span class="quote">^M-x</span>" key)
                 (if local-key
                     (concat
                      cand "<span class="quote"> (</span>" (propertize local-key 'face 'anything-M-x-key-face)
                      "<span class="quote">)</span>")
                     cand)
                 (concat
                  cand "<span class="quote"> (</span>" (propertize key 'face 'anything-M-x-key-face) "<span class="quote">)</span>"))
             cand)))

<span class="linecomment">;;; LaCarte</span>
(defvar anything-c-source-lacarte
  '((name . "<span class="quote">Lacarte</span>")
    (init . (lambda () (require 'lacarte )))
    (candidates . (lambda () (delete '(nil) (lacarte-get-overall-menu-item-alist))))
    (candidate-number-limit . 9999)
    (action . anything-c-call-interactively))
  "<span class="quote">Needs lacarte.el.

http://www.emacswiki.org/cgi-bin/wiki/download/lacarte.el</span>")
<span class="linecomment">;; (anything 'anything-c-source-lacarte)</span>

<span class="linecomment">;;;; &lt;Function&gt;</span>
<span class="linecomment">;;; Emacs functions</span>
(defvar anything-c-source-emacs-functions
  '((name . "<span class="quote">Emacs Functions</span>")
    (candidates . (lambda ()
                    (let (commands)
                      (mapatoms (lambda (a)
                                  (if (functionp a)
                                      (push (symbol-name a) commands))))
                      (sort commands 'string-lessp))))
    (type . function)
    (requires-pattern . 2))
  "<span class="quote">Source for completing Emacs functions.</span>")
<span class="linecomment">;; (anything 'anything-c-source-emacs-functions)</span>

<span class="linecomment">;;; With abbrev expansion</span>
<span class="linecomment">;;; Similar to my exec-abbrev-cmd.el</span>
<span class="linecomment">;;; See http://www.tsdh.de/cgi-bin/wiki.pl/exec-abbrev-cmd.el</span>
(defvar anything-c-function-abbrev-regexp nil
  "<span class="quote">The regexp for `anything-c-source-emacs-functions-with-abbrevs'.
Regexp built from the current `anything-pattern' interpreting it
as abbreviation.
Only for internal use.</span>")

(defun anything-c-match-function-by-abbrev (candidate)
  "<span class="quote">Return non-nil if `anything-pattern' is an abbreviation of the function CANDIDATE.

Abbreviations are made by taking the first character from each
word in the function's name, e.g. \"bb\" is an abbrev for
`bury-buffer', \"stb\" is an abbrev for `switch-to-buffer'.</span>"
  (string-match anything-c-function-abbrev-regexp candidate))

(defvar anything-c-source-emacs-functions-with-abbrevs
  (append anything-c-source-emacs-functions
          '((match anything-c-match-function-by-abbrev
             anything-c-string-match))
          '((init
             . (lambda ()
                 (defadvice anything-update
                     (before anything-c-update-function-abbrev-regexp activate)
                   (let ((char-list (append anything-pattern nil))
                         (str "<span class="quote">^</span>"))
                     (dolist (c char-list)
                       (setq str (concat str (list c) "<span class="quote">[^-]*-</span>")))
                     (setq str (concat (substring str 0 (1- (length str))) "<span class="quote">$</span>"))
                     (setq anything-c-function-abbrev-regexp str))))))))
<span class="linecomment">;; (anything 'anything-c-source-emacs-functions-with-abbrevs)</span>

(defvar anything-c-source-advice
  '((name . "<span class="quote">Function Advice</span>")
    (candidates . anything-c-advice-candidates)
    (action ("<span class="quote">Toggle Enable/Disable</span>" . anything-c-advice-toggle))
    <span class="linecomment">;;    (real-to-display . anything-c-advice-real-to-display)</span>
    (persistent-action . anything-c-advice-persistent-action)
    (persistent-help . "<span class="quote">Describe function / C-u C-z: Toggle advice</span>")))
<span class="linecomment">;; (anything 'anything-c-source-advice)</span>
<span class="linecomment">;; (let ((debug-on-signal t))(anything 'anything-c-source-advice))</span>
<span class="linecomment">;; (testadvice)</span>

(defun anything-c-advice-candidates ()
  (require 'advice)
  (loop for (fname) in ad-advised-functions
     for function = (intern fname)
     append
       (loop for class in ad-advice-classes append
            (loop for advice in (ad-get-advice-info-field function class)
               for enabled = (ad-advice-enabled advice)
               collect
                 (cons (format
                        "<span class="quote">%s %s %s</span>"
                        (if enabled "<span class="quote">Enabled </span>" "<span class="quote">Disabled</span>")
                        (propertize fname 'face 'font-lock-function-name-face)
                        (ad-make-single-advice-docstring advice class nil))
                       (list function class advice))))))

(defun anything-c-advice-persistent-action (func-class-advice)
  (if current-prefix-arg
      (anything-c-advice-toggle func-class-advice)
      (describe-function (car func-class-advice))))

(defun anything-c-advice-toggle (func-class-advice)
  (destructuring-bind (function class advice) func-class-advice
    (cond ((ad-advice-enabled advice)
           (ad-advice-set-enabled advice nil)
           (message "<span class="quote">Disabled</span>"))
          (t                            <span class="linecomment">;disabled</span>
           (ad-advice-set-enabled advice t)
           (message "<span class="quote">Enabled</span>")))
    (ad-activate function)
    (and anything-in-persistent-action
         (anything-c-advice-update-current-display-string))))

(defun anything-c-advice-update-current-display-string ()
  (anything-edit-current-selection
    (let ((newword (cond ((looking-at "<span class="quote">Disabled</span>") "<span class="quote">Enabled</span>")
                         ((looking-at "<span class="quote">Enabled</span>")  "<span class="quote">Disabled</span>")))
          realvalue)
      (when newword
        (delete-region (point) (progn (forward-word 1) (point)))
        (insert newword)))))

<span class="linecomment">;;;###autoload</span>
(defun anything-manage-advice ()
  "<span class="quote">Preconfigured `anything' to disable/enable function advices.</span>"
  (interactive)
  (anything-other-buffer 'anything-c-source-advice "<span class="quote">*anything advice*</span>"))

<span class="linecomment">;;;; &lt;Variable&gt;</span>
<span class="linecomment">;;; Emacs variables</span>
(defvar anything-c-source-emacs-variables
  '((name . "<span class="quote">Emacs Variables</span>")
    (candidates . (lambda ()
                    (sort (all-completions "<span class="quote"></span>" obarray 'boundp) 'string-lessp)))
    (type . variable)
    (requires-pattern . 2))
  "<span class="quote">Source for completing Emacs variables.</span>")
<span class="linecomment">;; (anything 'anything-c-source-emacs-variables)</span>

<span class="linecomment">;;;; &lt;Bookmark&gt;</span>
<span class="linecomment">;;; Bookmarks</span>
(eval-when-compile (require 'bookmark))
(defvar anything-c-source-bookmarks
  '((name . "<span class="quote">Bookmarks</span>")
    (init . (lambda ()
              (require 'bookmark)))
    (candidates . bookmark-all-names)
    (type . bookmark))
  "<span class="quote">See (info \"(emacs)Bookmarks\").</span>")
<span class="linecomment">;; (anything 'anything-c-source-bookmarks)</span>

<span class="linecomment">;;; bookmark-set</span>
(defvar anything-c-source-bookmark-set
  '((name . "<span class="quote">Set Bookmark</span>")
    (dummy)
    (action . bookmark-set))
  "<span class="quote">See (info \"(emacs)Bookmarks\").</span>")
<span class="linecomment">;; (anything 'anything-c-source-bookmark-set)</span>

<span class="linecomment">;;; Visible Bookmarks</span>
<span class="linecomment">;; (install-elisp "http://cvs.savannah.gnu.org/viewvc/*checkout*/bm/bm/bm.el")</span>


<span class="linecomment">;; http://d.hatena.ne.jp/grandVin/20080911/1221114327</span>
(defvar anything-c-source-bm
  '((name . "<span class="quote">Visible Bookmarks</span>")
    (init . anything-c-bm-init)
    (candidates-in-buffer)
    (type . line))
  "<span class="quote">Needs bm.el.

http://www.nongnu.org/bm/</span>")

(defun anything-c-bm-init ()
  "<span class="quote">Init function for `anything-c-source-bm'.</span>"
  (when (require 'bm nil t)
    (with-no-warnings
      (let ((bookmarks (bm-lists))
            (buf (anything-candidate-buffer 'global)))
        (dolist (bm (sort* (append (car bookmarks) (cdr bookmarks))
                           '&lt; :key 'overlay-start))
          (let ((start (overlay-start bm))
                (end (overlay-end bm))
                (annotation (or (overlay-get bm 'annotation) "<span class="quote"></span>")))
            (unless (&lt; (- end start) 1) <span class="linecomment">; org =&gt; (if (&lt; (- end start) 2)</span>
              (let ((str (format "<span class="quote">%5d: [%s]: %s\n</span>"
                                 (line-number-at-pos start)
                                 annotation
                                 (buffer-substring start (1- end)))))
                (with-current-buffer buf (insert str))))))))))

<span class="linecomment">;;; Special bookmarks</span>
(defvar anything-c-source-bookmarks-ssh
  '((name . "<span class="quote">Bookmarks-ssh</span>")
    (init . (lambda ()
              (require 'bookmark)))
    (candidates . (lambda () (anything-c-collect-bookmarks :ssh t)))
    (type . bookmark))
  "<span class="quote">See (info \"(emacs)Bookmarks\").</span>")
<span class="linecomment">;; (anything 'anything-c-source-bookmarks-ssh)</span>

(defvar anything-c-source-bookmarks-su
  '((name . "<span class="quote">Bookmarks-root</span>")
    (init . (lambda ()
              (require 'bookmark)))
    (candidates . (lambda () (anything-c-collect-bookmarks :su t)))
    (filtered-candidate-transformer anything-c-highlight-bookmark-su)

    (type . bookmark))
  "<span class="quote">See (info \"(emacs)Bookmarks\").</span>")
<span class="linecomment">;; (anything 'anything-c-source-bookmarks-su)</span>

(defvar anything-c-source-bookmarks-local
  '((name . "<span class="quote">Bookmarks-Local</span>")
    (init . (lambda ()
              (require 'bookmark)))
    (candidates . (lambda () (anything-c-collect-bookmarks :local t)))
    (filtered-candidate-transformer
     anything-c-adaptive-sort
     anything-c-highlight-bookmark)
    (type . bookmark))
  "<span class="quote">See (info \"(emacs)Bookmarks\").</span>")
<span class="linecomment">;; (anything 'anything-c-source-bookmarks-local)</span>

(defun* anything-c-collect-bookmarks (&key local su sudo ssh)
  (let* ((lis-all (bookmark-all-names))
         (lis-loc (cond (local (loop for i in lis-all
                                  unless (string-match "<span class="quote">^(ssh)\\|^(su)</span>" i)
                                  collect i))
                        (su (loop for i in lis-all
                               when (string-match "<span class="quote">^(su)</span>" i)
                               collect i))
                        (sudo (loop for i in lis-all
                                 when (string-match "<span class="quote">^(sudo)</span>" i)
                                 collect i))
                        (ssh (loop for i in lis-all
                                when (string-match "<span class="quote">^(ssh)</span>" i)
                                collect i)))))
    (sort lis-loc 'string-lessp)))

(defun anything-c-bookmark-root-logged-p ()
  (catch 'break
    (dolist (i (mapcar #'buffer-name (buffer-list)))
      (when (string-match (format "<span class="quote">*tramp/%s .</span>" anything-su-or-sudo) i)
        (throw 'break t)))))

(defun anything-c-highlight-bookmark-su (files source)
  (if (anything-c-bookmark-root-logged-p)
      (anything-c-highlight-bookmark files source)
      (anything-c-highlight-not-logged files source)))

(defun anything-c-highlight-not-logged (files source)
  (loop for i in files
     collect (propertize i 'face anything-c-bookmarks-face3)))

(defun anything-c-highlight-bookmark (bookmarks source)
  "<span class="quote">Used as `candidate-transformer' to colorize bookmarks.
Work both with standard Emacs bookmarks and bookmark-extensions.el.</span>"
  (loop for i in bookmarks
     for isfile        = (bookmark-get-filename i)
     for bufp          = (and (fboundp 'bmkext-get-buffer-name)
                              (bmkext-get-buffer-name i))
     for handlerp      = (and (fboundp 'bookmark-get-handler)
                              (bookmark-get-handler i))
     for isw3m         = (and (fboundp 'bmkext-w3m-bookmark-p)
                              (bmkext-w3m-bookmark-p i))
     for isgnus        = (and (fboundp 'bmkext-gnus-bookmark-p)
                              (bmkext-gnus-bookmark-p i))
     for isman         = (and (fboundp 'bmkext-man-bookmark-p) <span class="linecomment">; Man</span>
                              (bmkext-man-bookmark-p i))
     for iswoman       = (and (fboundp 'bmkext-woman-bookmark-p) <span class="linecomment">; Woman</span>
                              (bmkext-woman-bookmark-p i))
     for handlerp      = (bookmark-get-handler i)
     for isannotation  = (bookmark-get-annotation i)
     for isabook       = (string= (bookmark-prop-get i 'type) "<span class="quote">addressbook</span>")
     for isinfo        = (eq handlerp 'Info-bookmark-jump)
     <span class="linecomment">;; Add a * if bookmark have annotation</span>
     if (and isannotation (not (string-equal isannotation "<span class="quote"></span>")))
     do (setq i (concat "<span class="quote">*</span>" i))
     collect (cond (<span class="linecomment">;; info buffers</span>
                    isinfo
                    (propertize i 'face 'anything-bmkext-info 'help-echo isfile))
                   (<span class="linecomment">;; w3m buffers</span>
                    isw3m
                    (propertize i 'face 'anything-bmkext-w3m 'help-echo isfile))
                   (<span class="linecomment">;; gnus buffers</span>
                    isgnus
                    (propertize i 'face 'anything-bmkext-gnus 'help-echo isfile))
                   (<span class="linecomment">;; Man Woman</span>
                    (or iswoman isman)
                    (propertize i 'face 'anything-bmkext-man 'help-echo isfile))
                   (<span class="linecomment">;; Addressbook</span>
                    isabook
                    (propertize i 'face '((:foreground "<span class="quote">Tomato</span>"))))
                   (<span class="linecomment">;; directories</span>
                    (and isfile (file-directory-p isfile))
                    (propertize i 'face anything-c-bookmarks-face1 'help-echo isfile))
                   (<span class="linecomment">;; regular files</span>
                    t
                    (propertize i 'face 'anything-bmkext-file 'help-echo isfile)))))


<span class="linecomment">;;; Faces for bookmarks</span>
(defface anything-bmkext-info
    '((t (:foreground "<span class="quote">green</span>")))
  "<span class="quote">*Face used for W3m Emacs bookmarks (not w3m bookmarks).</span>"
  :group 'anything)

(defface anything-bmkext-w3m
    '((t (:foreground "<span class="quote">yellow</span>")))
  "<span class="quote">*Face used for W3m Emacs bookmarks (not w3m bookmarks).</span>"
  :group 'anything)

(defface anything-bmkext-gnus
    '((t (:foreground "<span class="quote">magenta</span>")))
  "<span class="quote">*Face used for Gnus bookmarks.</span>"
  :group 'anything)

(defface anything-bmkext-man
    '((t (:foreground "<span class="quote">Orange4</span>")))
  "<span class="quote">*Face used for Woman/man bookmarks.</span>"
  :group 'anything)

(defface anything-bmkext-no--file
    '((t (:foreground "<span class="quote">grey</span>")))
  "<span class="quote">*Face used for non--file bookmarks.</span>"
  :group 'anything)

(defface anything-bmkext-file
    '((t (:foreground "<span class="quote">Deepskyblue2</span>")))
  "<span class="quote">*Face used for non--file bookmarks.</span>"
  :group 'anything)

(defface anything-bookmarks-su-face '((t (:foreground "<span class="quote">red</span>")))
  "<span class="quote">Face for su/sudo bookmarks.</span>"
  :group 'anything)

(defvar anything-c-bookmarks-face1 'anything-ff-directory)
(defvar anything-c-bookmarks-face2 'anything-ff-file)
(defvar anything-c-bookmarks-face3 'anything-bookmarks-su-face)


<span class="linecomment">;;; Sources to filter bookmark-extensions bookmarks.</span>
<span class="linecomment">;; Dependency: http://mercurial.intuxication.org/hg/emacs-bookmark-extension</span>
<span class="linecomment">;; If you want to enable google-maps in addressbook you will need</span>
<span class="linecomment">;; Julien Danjou google-maps-el package available here:</span>
<span class="linecomment">;; http://julien.danjou.info/google-maps-el.html</span>

(defun anything-c-bmkext-filter-setup-alist (fn &rest args)
  "<span class="quote">Return a filtered `bookmark-alist' sorted alphabetically.</span>"
  (loop
     with alist = (if args
                      (apply #'(lambda (x) (funcall fn x)) args)
                      (funcall fn))
     for i in alist
     for b = (car i)
     collect b into sa
     finally return (sort sa 'string-lessp)))

<span class="linecomment">;; Addressbook</span>
(defvar anything-c-source-bmkext-addressbook
  '((name . "<span class="quote">Bookmark Addressbook</span>")
    (init . (lambda ()
              (require 'bookmark-extensions)
              (bookmark-maybe-load-default-file)))
    (candidates . anything-c-bmkext-addressbook-setup-alist)
    (persistent-action
     . (lambda (candidate)
         (let ((bmk (anything-bookmark-get-bookmark-from-name
                     candidate)))
           (bookmark--jump-via bmk 'pop-to-buffer))))
    (persistent-help . "<span class="quote">Show contact - Prefix with C-u to append</span>")
    (filtered-candidate-transformer
     anything-c-adaptive-sort
     anything-c-highlight-bookmark)
    (action . (("<span class="quote">Show Contact(s)</span>"
                . (lambda (candidate)
                    (let* ((contacts (anything-marked-candidates))
                           (current-prefix-arg (or anything-current-prefix-arg
                                                   (&gt; (length contacts) 1))))
                      (bookmark-jump
                       (anything-bookmark-get-bookmark-from-name (car contacts)))
                      (anything-aif (cdr contacts)
                        (loop for bmk in it do
                             (bookmark-jump
                              (anything-bookmark-get-bookmark-from-name bmk)))))))
               ("<span class="quote">Send Mail</span>"
                . (lambda (candidate)
                    (let* ((contacts (anything-marked-candidates))
                           (bmk      (anything-bookmark-get-bookmark-from-name
                                      (car contacts)))
                           (append   (message-buffers)))
                      (if append
                          (addressbook-set-mail-buffer1 bmk 'append)
                          (addressbook-set-mail-buffer1 bmk))
                      (setq contacts (cdr contacts))
                      (when contacts
                        (loop for bmk in contacts do
                             (addressbook-set-mail-buffer1 bmk 'append))))))
               ("<span class="quote">Edit Bookmark</span>"
                . (lambda (candidate)
                    (let ((bmk (anything-bookmark-get-bookmark-from-name
                                candidate)))
                      (addressbook-bookmark-edit
                       (assoc bmk bookmark-alist)))))
               ("<span class="quote">Insert Email at point</span>"
                . (lambda (candidate)
                    (let* ((bmk   (anything-bookmark-get-bookmark-from-name
                                   candidate))
                           (mlist (split-string
                                   (assoc-default
                                    'email (assoc bmk bookmark-alist))
                                   "<span class="quote">, </span>")))
                      (insert
                       (if (&gt; (length mlist) 1)
                           (anything-comp-read
                            "<span class="quote">Insert Mail Address: </span>" mlist :must-match t)
                           (car mlist))))))
               ("<span class="quote">Show annotation</span>"
                . (lambda (candidate)
                    (let ((bmk (anything-bookmark-get-bookmark-from-name
                                candidate)))
                      (bookmark-show-annotation bmk))))
               ("<span class="quote">Edit annotation</span>"
                . (lambda (candidate)
                    (let ((bmk (anything-bookmark-get-bookmark-from-name
                                candidate)))
                      (bookmark-edit-annotation bmk))))
               ("<span class="quote">Show Google map</span>"
                . (lambda (candidate)
                    (let* ((bmk (anything-bookmark-get-bookmark-from-name
                                 candidate))
                           (full-bmk (assoc bmk bookmark-alist)))
                      (addressbook-google-map full-bmk))))))))


(defun anything-c-bmkext-addressbook-setup-alist ()
  "<span class="quote">Specialized filter function for bookmarks w3m.</span>"
  (anything-c-bmkext-filter-setup-alist 'bmkext-addressbook-alist-only))

<span class="linecomment">;; W3m</span>
(defvar anything-c-source-bookmark-w3m
  '((name . "<span class="quote">Bookmark W3m</span>")
    (init . (lambda ()
              (require 'bookmark-extensions)
              (bookmark-maybe-load-default-file)))
    (candidates . anything-c-bookmark-w3m-setup-alist)
    (filtered-candidate-transformer
     anything-c-adaptive-sort
     anything-c-highlight-bookmark)
    (type . bookmark)))
<span class="linecomment">;; (anything 'anything-c-source-bookmark-w3m)</span>

(defun anything-c-bookmark-w3m-setup-alist ()
  "<span class="quote">Specialized filter function for bookmarks w3m.</span>"
  (anything-c-bmkext-filter-setup-alist 'bmkext-w3m-alist-only))

<span class="linecomment">;; Images</span>
(defvar anything-c-source-bookmark-images
  '((name . "<span class="quote">Bookmark Images</span>")
    (init . (lambda ()
              (require 'bookmark-extensions)
              (bookmark-maybe-load-default-file)))
    (candidates . anything-c-bookmark-images-setup-alist)
    (filtered-candidate-transformer
     anything-c-adaptive-sort
     anything-c-highlight-bookmark)
    (type . bookmark)))
<span class="linecomment">;; (anything 'anything-c-source-bookmark-images)</span>

(defun anything-c-bookmark-images-setup-alist ()
  "<span class="quote">Specialized filter function for images bookmarks.</span>"
  (anything-c-bmkext-filter-setup-alist 'bmkext-image-file-alist-only))

<span class="linecomment">;; Woman Man</span>
(defvar anything-c-source-bookmark-man
  '((name . "<span class="quote">Bookmark Woman&Man</span>")
    (init . (lambda ()
              (require 'bookmark-extensions)
              (bookmark-maybe-load-default-file)))
    (candidates . anything-c-bookmark-man-setup-alist)
    (filtered-candidate-transformer
     anything-c-adaptive-sort
     anything-c-highlight-bookmark)
    (type . bookmark)))
<span class="linecomment">;; (anything 'anything-c-source-bookmark-man)</span>

(defun anything-c-bookmark-man-setup-alist ()
  "<span class="quote">Specialized filter function for bookmarks w3m.</span>"
  (append (anything-c-bmkext-filter-setup-alist 'bmkext-man-alist-only)
          (anything-c-bmkext-filter-setup-alist 'bmkext-woman-alist-only)))

<span class="linecomment">;; Gnus</span>
(defvar anything-c-source-bookmark-gnus
  '((name . "<span class="quote">Bookmark Gnus</span>")
    (init . (lambda ()
              (require 'bookmark-extensions)
              (bookmark-maybe-load-default-file)))
    (candidates . anything-c-bookmark-gnus-setup-alist)
    (filtered-candidate-transformer
     anything-c-adaptive-sort
     anything-c-highlight-bookmark)
    (type . bookmark)))
<span class="linecomment">;; (anything 'anything-c-source-bookmark-gnus)</span>

(defun anything-c-bookmark-gnus-setup-alist ()
  "<span class="quote">Specialized filter function for bookmarks gnus.</span>"
  (anything-c-bmkext-filter-setup-alist 'bmkext-gnus-alist-only))

<span class="linecomment">;; Info</span>
(defvar anything-c-source-bookmark-info
  '((name . "<span class="quote">Bookmark Info</span>")
    (init . (lambda ()
              (require 'bookmark-extensions)
              (bookmark-maybe-load-default-file)))
    (candidates . anything-c-bookmark-info-setup-alist)
    (filtered-candidate-transformer
     anything-c-adaptive-sort
     anything-c-highlight-bookmark)
    (type . bookmark)))
<span class="linecomment">;; (anything 'anything-c-source-bookmark-info)</span>

(defun anything-c-bookmark-info-setup-alist ()
  "<span class="quote">Specialized filter function for bookmarks info.</span>"
  (anything-c-bmkext-filter-setup-alist 'bmkext-info-alist-only))

<span class="linecomment">;; Local Files&directories</span>
(defvar anything-c-source-bookmark-files&dirs
  '((name . "<span class="quote">Bookmark Files&Directories</span>")
    (init . (lambda ()
              (require 'bookmark-extensions)
              (bookmark-maybe-load-default-file)))
    (candidates . anything-c-bookmark-local-files-setup-alist)
    (filtered-candidate-transformer
     anything-c-adaptive-sort
     anything-c-highlight-bookmark)
    (type . bookmark)))
<span class="linecomment">;; (anything 'anything-c-source-bookmark-files&dirs)</span>

(defun anything-c-bookmark-local-files-setup-alist ()
  "<span class="quote">Specialized filter function for bookmarks locals files.</span>"
  (anything-c-bmkext-filter-setup-alist 'bmkext-local-file-alist-only))

<span class="linecomment">;; Su Files&directories</span>
(defvar anything-c-source-bookmark-su-files&dirs
  '((name . "<span class="quote">Bookmark Root-Files&Directories</span>")
    (init . (lambda ()
              (require 'bookmark-extensions)
              (bookmark-maybe-load-default-file)))
    (candidates . anything-c-bookmark-su-files-setup-alist)
    (filtered-candidate-transformer
     anything-c-adaptive-sort
     anything-c-highlight-bookmark-su)
    (type . bookmark)))
<span class="linecomment">;; (anything 'anything-c-source-bookmark-su-files&dirs)</span>

(defun anything-c-bookmark-su-files-setup-alist ()
  "<span class="quote">Specialized filter function for bookmarks su/sudo files.</span>"
  (loop
     with l = (anything-c-bmkext-filter-setup-alist 'bmkext-remote-file-alist-only)
     for i in l
     for isfile = (bookmark-get-filename i)
     for istramp = (and isfile (boundp 'tramp-file-name-regexp)
                        (save-match-data
                          (string-match tramp-file-name-regexp isfile)))
     for issu = (and istramp
                     (string-match bmkext-su-or-sudo-regexp isfile))
     if issu
     collect i))

<span class="linecomment">;; Ssh Files&directories</span>
(defvar anything-c-source-bookmark-ssh-files&dirs
  '((name . "<span class="quote">Bookmark Ssh-Files&Directories</span>")
    (init . (lambda ()
              (require 'bookmark-extensions)
              (bookmark-maybe-load-default-file)))
    (candidates . anything-c-bookmark-ssh-files-setup-alist)
    (filtered-candidate-transformer . anything-c-adaptive-sort)
    (type . bookmark)))
<span class="linecomment">;; (anything 'anything-c-source-bookmark-ssh-files&dirs)</span>

(defun anything-c-bookmark-ssh-files-setup-alist ()
  "<span class="quote">Specialized filter function for bookmarks ssh files.</span>"
  (loop
     with l = (anything-c-bmkext-filter-setup-alist 'bmkext-remote-file-alist-only)
     for i in l
     for isfile = (bookmark-get-filename i)
     for istramp = (and isfile (boundp 'tramp-file-name-regexp)
                        (save-match-data
                          (string-match tramp-file-name-regexp isfile)))
     for isssh = (and istramp
                      (string-match "<span class="quote">/ssh:</span>" isfile))
     if isssh
     collect i))


<span class="linecomment">;; All bookmark-extensions sources.</span>
<span class="linecomment">;;;###autoload</span>
(defun anything-bookmark-ext ()
  "<span class="quote">Preconfigured `anything' for bookmark-extensions sources.
Needs bookmark-ext.el

http://mercurial.intuxication.org/hg/emacs-bookmark-extension</span>"
  (interactive)
  (anything
   :sources
   '(anything-c-source-bookmark-files&dirs
     anything-c-source-bookmark-w3m
     anything-c-source-bmkext-addressbook
     anything-c-source-bookmark-gnus
     anything-c-source-bookmark-info
     anything-c-source-bookmark-man
     anything-c-source-bookmark-images
     anything-c-source-bookmark-su-files&dirs
     anything-c-source-bookmark-ssh-files&dirs)
   :prompt "<span class="quote">SearchBookmark: </span>"
   :buffer "<span class="quote">*anything bmkext*</span>"))


<span class="linecomment">;; Firefox bookmarks</span>
<span class="linecomment">;; You will have to set firefox to import bookmarks in his html file bookmarks.html.</span>
<span class="linecomment">;; (only for firefox versions &gt;=3)</span>
<span class="linecomment">;; To achieve that, open about:config in firefox and double click on this line to enable value</span>
<span class="linecomment">;; to true:</span>
<span class="linecomment">;; user_pref("browser.bookmarks.autoExportHTML", false);</span>
<span class="linecomment">;; You should have now:</span>
<span class="linecomment">;; user_pref("browser.bookmarks.autoExportHTML", true);</span>

(defvar anything-firefox-bookmark-url-regexp "<span class="quote">\\(https\\|http\\|ftp\\|about\\|file\\)://[^ \"]*</span>")
(defvar anything-firefox-bookmarks-regexp "<span class="quote">&gt;\\([^&gt;&lt;]+.[^&lt;/a&gt;]\\)</span>")

(defun anything-get-firefox-user-init-dir ()
  "<span class="quote">Guess the default Firefox user directory name.</span>"
  (let* ((moz-dir (concat (getenv "<span class="quote">HOME</span>") "<span class="quote">/.mozilla/firefox/</span>"))
         (moz-user-dir
          (with-current-buffer (find-file-noselect (concat moz-dir "<span class="quote">profiles.ini</span>"))
            (goto-char (point-min))
            (prog1
                (when (search-forward "<span class="quote">Path=</span>" nil t)
                  (buffer-substring-no-properties (point) (point-at-eol)))
              (kill-buffer)))))
    (file-name-as-directory (concat moz-dir moz-user-dir))))

(defun anything-guess-firefox-bookmark-file ()
  "<span class="quote">Return the path of the Firefox bookmarks file.</span>"
  (concat (anything-get-firefox-user-init-dir) "<span class="quote">bookmarks.html</span>"))

(defun anything-html-bookmarks-to-alist (file url-regexp bmk-regexp)
  "<span class="quote">Parse html bookmark FILE and return an alist with (title . url) as elements.</span>"
  (let (bookmarks-alist url title)
    (with-temp-buffer
      (insert-file-contents file)
      (goto-char (point-min))
      (while (re-search-forward "<span class="quote">href=\\|^ *&lt;DT&gt;&lt;A HREF=</span>" nil t)
        (forward-line 0)
        (when (re-search-forward url-regexp nil t)
          (setq url (match-string 0)))
        (when (re-search-forward bmk-regexp nil t)
          (setq title (match-string 1)))
        (push (cons title url) bookmarks-alist)
        (forward-line)))
    (nreverse bookmarks-alist)))

(defvar anything-c-firefox-bookmarks-alist nil)
(defvar anything-c-source-firefox-bookmarks
  '((name . "<span class="quote">Firefox Bookmarks</span>")
    (init . (lambda ()
              (setq anything-c-firefox-bookmarks-alist
                    (anything-html-bookmarks-to-alist
                     (anything-guess-firefox-bookmark-file)
                     anything-firefox-bookmark-url-regexp
                     anything-firefox-bookmarks-regexp))))
    (candidates . (lambda ()
                    (mapcar #'car anything-c-firefox-bookmarks-alist)))
    (filtered-candidate-transformer
     anything-c-adaptive-sort
     anything-c-highlight-firefox-bookmarks)
    (action . (("<span class="quote">Browse Url Firefox</span>"
                . (lambda (candidate)
                    (browse-url-firefox
                     (anything-c-firefox-bookmarks-get-value candidate))))
               ("<span class="quote">Browse Url w3m</span>"
                . (lambda (candidate)
                    (w3m-browse-url
                     (anything-c-firefox-bookmarks-get-value candidate))))
               ("<span class="quote">Copy Url</span>"
                . (lambda (elm)
                    (kill-new (anything-c-w3m-bookmarks-get-value elm))))))))

<span class="linecomment">;; (anything 'anything-c-source-firefox-bookmarks)</span>

(defun anything-c-firefox-bookmarks-get-value (elm)
  (assoc-default elm anything-c-firefox-bookmarks-alist))

(defun anything-c-highlight-firefox-bookmarks (bookmarks source)
  (loop for i in bookmarks
     collect (propertize
              i 'face '((:foreground "<span class="quote">YellowGreen</span>"))
              'help-echo (anything-c-firefox-bookmarks-get-value i))))

<span class="linecomment">;; W3m bookmark</span>
<span class="linecomment">;; Bugfix:</span>
<span class="linecomment">;; Some users have the emacs-w3m library in load-path</span>
<span class="linecomment">;; without having the w3m executable :-;</span>
<span class="linecomment">;; So check if w3m program is present before trying to load</span>
<span class="linecomment">;; emacs-w3m.</span>
(eval-when-compile
  (when (executable-find "<span class="quote">w3m</span>")
    (require 'w3m-bookmark nil t)))
(defvar w3m-bookmark-file "<span class="quote">~/.w3m/bookmark.html</span>")


(defface anything-w3m-bookmarks-face '((t (:foreground "<span class="quote">cyan1</span>" :underline t)))
  "<span class="quote">Face for w3m bookmarks</span>" :group 'anything)

(defvar anything-w3m-bookmarks-regexp "<span class="quote">&gt;\\([^&gt;&lt;]+.[^&lt;/a&gt;]\\)</span>")
(defvar anything-w3m-bookmark-url-regexp "<span class="quote">\\(https\\|http\\|ftp\\|file\\)://[^&gt;]*</span>")
(defvar anything-c-w3m-bookmarks-alist nil)
(defvar anything-c-source-w3m-bookmarks
  '((name . "<span class="quote">W3m Bookmarks</span>")
    (init . (lambda ()
              (setq anything-c-w3m-bookmarks-alist
                    (anything-html-bookmarks-to-alist
                     w3m-bookmark-file
                     anything-w3m-bookmark-url-regexp
                     anything-w3m-bookmarks-regexp))))
    (candidates . (lambda ()
                    (mapcar #'car anything-c-w3m-bookmarks-alist)))
    (filtered-candidate-transformer
     anything-c-adaptive-sort
     anything-c-highlight-w3m-bookmarks)
    (action . (("<span class="quote">Browse Url</span>"
                . (lambda (candidate)
                    (anything-c-w3m-browse-bookmark candidate)))
               ("<span class="quote">Copy Url</span>"
                . (lambda (elm)
                    (kill-new (anything-c-w3m-bookmarks-get-value elm))))
               ("<span class="quote">Browse Url Firefox</span>"
                . (lambda (candidate)
                    (anything-c-w3m-browse-bookmark candidate t)))
               ("<span class="quote">Delete Bookmark</span>"
                . (lambda (candidate)
                    (anything-c-w3m-delete-bookmark candidate)))
               ("<span class="quote">Rename Bookmark</span>"
                . (lambda (candidate)
                    (anything-c-w3m-rename-bookmark candidate)))))
    (persistent-action . (lambda (candidate)
                           (if current-prefix-arg
                               (anything-c-w3m-browse-bookmark candidate t)
                               (anything-c-w3m-browse-bookmark candidate nil t))))
    (persistent-help . "<span class="quote">Open URL with emacs-w3m in new tab / \
C-u \\[anything-execute-persistent-action]: Open URL with Firefox</span>"))
  "<span class="quote">Needs w3m and emacs-w3m.

http://w3m.sourceforge.net/
http://emacs-w3m.namazu.org/</span>")

<span class="linecomment">;; (anything 'anything-c-source-w3m-bookmarks)</span>

(defun anything-c-w3m-bookmarks-get-value (elm)
  (replace-regexp-in-string
   "<span class="quote">\"</span>" "<span class="quote"></span>" (cdr (assoc elm anything-c-w3m-bookmarks-alist))))

(defun anything-c-w3m-browse-bookmark (elm &optional use-firefox new-tab)
  (let* ((fn (if use-firefox 'browse-url-firefox 'w3m-browse-url))
         (arg (and (eq fn 'w3m-browse-url) new-tab)))
    (funcall fn (anything-c-w3m-bookmarks-get-value elm) arg)))

(defun anything-c-highlight-w3m-bookmarks (bookmarks source)
  (loop for i in bookmarks
     collect (propertize
              i 'face 'anything-w3m-bookmarks-face
              'help-echo (anything-c-w3m-bookmarks-get-value i))))


(defun anything-c-w3m-delete-bookmark (elm)
  (save-excursion
    (find-file-literally w3m-bookmark-file)
    (goto-char (point-min))
    (when (re-search-forward elm nil t)
      (beginning-of-line)
      (delete-region (point)
                     (line-end-position))
      (delete-blank-lines))
    (save-buffer (current-buffer))
    (kill-buffer (current-buffer))))

(defun anything-c-w3m-rename-bookmark (elm)
  (let* ((old-title (replace-regexp-in-string "<span class="quote">&gt;</span>" "<span class="quote"></span>" elm))
         (new-title (read-string "<span class="quote">NewTitle: </span>" old-title)))
    (save-excursion
      (find-file-literally w3m-bookmark-file)
      (goto-char (point-min))
      (when (re-search-forward (concat elm "<span class="quote">&lt;</span>") nil t)
        (goto-char (1- (point)))
        (delete-char (- (length old-title)))
        (insert new-title))
      (save-buffer (current-buffer))
      (kill-buffer (current-buffer)))))

<span class="linecomment">;;;; &lt;Library&gt;</span>
<span class="linecomment">;;; Elisp library scan</span>
(defvar anything-c-source-elisp-library-scan
  '((name . "<span class="quote">Elisp libraries (Scan)</span>")
    (init . (anything-c-elisp-library-scan-init))
    (candidates-in-buffer)
    (action ("<span class="quote">Find library</span>"
             . (lambda (candidate) (find-file (find-library-name candidate))))
     ("<span class="quote">Find library other window</span>"
      . (lambda (candidate)
          (find-file-other-window (find-library-name candidate))))
     ("<span class="quote">Load library</span>"
      . (lambda (candidate) (load-library candidate))))))
<span class="linecomment">;; (anything 'anything-c-source-elisp-library-scan)</span>

(defun anything-c-elisp-library-scan-init ()
  "<span class="quote">Init anything buffer status.</span>"
  (let ((anything-buffer (anything-candidate-buffer 'global))
        (library-list (anything-c-elisp-library-scan-list)))
    (with-current-buffer anything-buffer
      (dolist (library library-list)
        (insert (format "<span class="quote">%s\n</span>" library))))))

(defun anything-c-elisp-library-scan-list (&optional dirs string)
  "<span class="quote">Do completion for file names passed to `locate-file'.
DIRS is directory to search path.
STRING is string to match.</span>"
  <span class="linecomment">;; Use `load-path' as path when ignore `dirs'.</span>
  (or dirs (setq dirs load-path))
  <span class="linecomment">;; Init with blank when ignore `string'.</span>
  (or string (setq string "<span class="quote"></span>"))
  <span class="linecomment">;; Get library list.</span>
  (let ((string-dir (file-name-directory string))
        <span class="linecomment">;; File regexp that suffix match `load-file-rep-suffixes'.</span>
        (match-regexp (format "<span class="quote">^.*\\.el%s$</span>" (regexp-opt load-file-rep-suffixes)))
        name
        names)
    (dolist (dir dirs)
      (unless dir
        (setq dir default-directory))
      (if string-dir
          (setq dir (expand-file-name string-dir dir)))
      (when (file-directory-p dir)
        (dolist (file (file-name-all-completions
                       (file-name-nondirectory string) dir))
          <span class="linecomment">;; Suffixes match `load-file-rep-suffixes'.</span>
          (setq name (if string-dir (concat string-dir file) file))
          (if (string-match match-regexp name)
              (add-to-list 'names name)))))
    names))

<span class="linecomment">;;;; &lt;Programming&gt;</span>
<span class="linecomment">;;; Imenu</span>
(defvar anything-c-imenu-delimiter "<span class="quote"> / </span>")

(defvar anything-c-imenu-index-filter nil)
(make-variable-buffer-local 'anything-c-imenu-index-filter)

(defvar anything-c-cached-imenu-alist nil)
(make-variable-buffer-local 'anything-c-cached-imenu-alist)

(defvar anything-c-cached-imenu-candidates nil)
(make-variable-buffer-local 'anything-c-cached-imenu-candidates)

(defvar anything-c-cached-imenu-tick nil)
(make-variable-buffer-local 'anything-c-cached-imenu-tick)

(eval-when-compile (require 'imenu))
(setq imenu-auto-rescan t)

(defun anything-imenu-create-candidates (entry)
  "<span class="quote">Create candidates with ENTRY.</span>"
  (if (listp (cdr entry))
      (mapcan
       (lambda (sub)
         (if (consp (cdr sub))
             (mapcar
              (lambda (subentry)
                (concat (car entry) anything-c-imenu-delimiter subentry))
              (anything-imenu-create-candidates sub))
             (list (concat (car entry) anything-c-imenu-delimiter (car sub)))))
       (cdr entry))
      (list entry)))

(defvar anything-c-source-imenu
  '((name . "<span class="quote">Imenu</span>")
    (init . (lambda () (require 'imenu)))
    (candidates . anything-c-imenu-candidates)
    (persistent-action . (lambda (elm)
                           (anything-c-imenu-default-action elm)
                           (unless (fboundp 'semantic-imenu-tag-overlay)
                             (anything-match-line-color-current-line))))
    (persistent-help . "<span class="quote">Show this entry</span>")
    (action . anything-c-imenu-default-action))
  "<span class="quote">See (info \"(emacs)Imenu\")</span>")

<span class="linecomment">;; (anything 'anything-c-source-imenu)</span>

(defun anything-c-imenu-candidates ()
  (with-current-buffer anything-current-buffer
    (let ((tick (buffer-modified-tick)))
      (if (eq anything-c-cached-imenu-tick tick)
          anything-c-cached-imenu-candidates
          (setq imenu--index-alist nil)
          (setq anything-c-cached-imenu-tick tick
                anything-c-cached-imenu-candidates
                (ignore-errors
                  (mapcan
                   'anything-imenu-create-candidates
                   (setq anything-c-cached-imenu-alist
                         (let ((index (imenu--make-index-alist)))
                           (if anything-c-imenu-index-filter
                               (funcall anything-c-imenu-index-filter index)
                               index))))))
          (setq anything-c-cached-imenu-candidates
                (mapcar #'(lambda (x)
                            (if (stringp x)
                                x
                                (car x)))
                        anything-c-cached-imenu-candidates))))))

(setq imenu-default-goto-function 'imenu-default-goto-function)
(defun anything-c-imenu-default-action (elm)
  "<span class="quote">The default action for `anything-c-source-imenu'.</span>"
  (let ((path (split-string elm anything-c-imenu-delimiter))
        (alist anything-c-cached-imenu-alist))
    (dolist (elm path)
      (setq alist (assoc elm alist)))
    (imenu alist)))

<span class="linecomment">;;; Ctags</span>
(defvar anything-c-ctags-modes
  '( c-mode c++-mode awk-mode csharp-mode java-mode javascript-mode lua-mode
    makefile-mode pascal-mode perl-mode cperl-mode php-mode python-mode
    scheme-mode sh-mode slang-mode sql-mode tcl-mode ))

(defun anything-c-source-ctags-init ()
  (when (and buffer-file-name
             (memq major-mode anything-c-ctags-modes)
             (anything-current-buffer-is-modified))
    (with-current-buffer (anything-candidate-buffer 'local)
      (call-process-shell-command
       (if (string-match "<span class="quote">\\.el\\.gz$</span>" anything-buffer-file-name)
           (format "<span class="quote">ctags -e -u -f- --language-force=lisp --fields=n =(zcat %s) </span>"
                   anything-buffer-file-name)
           (format "<span class="quote">ctags -e -u -f- --fields=n %s </span>" anything-buffer-file-name))
       nil (current-buffer))
      (goto-char (point-min))
      (forward-line 2)
      (delete-region (point-min) (point))
      (loop while (and (not (eobp)) (search-forward "<span class="quote">\001</span>" (point-at-eol) t))
         for lineno-start = (point)
         for lineno = (buffer-substring
                       lineno-start
                       (1- (search-forward "<span class="quote">,</span>" (point-at-eol) t)))
         do
           (beginning-of-line)
           (insert (format "<span class="quote">%5s:</span>" lineno))
           (search-forward "<span class="quote">\177</span>" (point-at-eol) t)
           (delete-region (1- (point)) (point-at-eol))
           (forward-line 1)))))

(defvar anything-c-source-ctags
  '((name . "<span class="quote">Exuberant ctags</span>")
    (init . anything-c-source-ctags-init)
    (candidates-in-buffer)
    (adjust)
    (type . line))
  "<span class="quote">Needs Exuberant Ctags.

http://ctags.sourceforge.net/</span>")
<span class="linecomment">;; (anything 'anything-c-source-ctags)</span>

<span class="linecomment">;; Semantic</span>
(eval-when-compile (require 'semantic nil t))
(declare-function semantic-format-tag-summarize "<span class="quote">ext:format.el</span>" (tag &optional parent color) t)
(declare-function semantic-tag-components "<span class="quote">ext:tag.el</span>" (tag) t)
(declare-function semantic-go-to-tag "<span class="quote">ext:tag-file.el</span>" (tag) t)
(declare-function semantic-tag-type "<span class="quote">ext:tag-file.el</span>" (tag) t)
(declare-function semantic-tag-class "<span class="quote">ext:tag-file.el</span>" (tag) t)
(defvar anything-semantic-candidates nil)

(defun anything-semantic-construct-candidates (tags depth)
  (when (require 'semantic nil t)
    (apply
     'append
     (mapcar
      (lambda (tag)
        (if (listp tag)
            (let ((type (semantic-tag-type tag))
                  (class (semantic-tag-class tag)))
              (if (or (and (stringp type)
                           (or (string= type "<span class="quote">class</span>")
                               (string= type "<span class="quote">namespace</span>")))
                      (eq class 'function)
                      (eq class 'variable))
                  (cons (cons (concat (make-string (* depth 2) ?\s)
                                      (semantic-format-tag-summarize tag nil t))
                              tag)
                        (anything-semantic-construct-candidates
                         (semantic-tag-components tag) (1+ depth)))))))
      tags))))

(defun anything-semantic-default-action (candidate)
  (let ((tag (cdr (assoc candidate anything-semantic-candidates))))
    (semantic-go-to-tag tag)))

(defvar anything-c-source-semantic
  '((name . "<span class="quote">Semantic Tags</span>")
    (init . (lambda ()
              (setq anything-semantic-candidates
                    (ignore-errors (anything-semantic-construct-candidates
                                    (semantic-fetch-tags) 0)))))
    (candidates . (lambda ()
                    (if anything-semantic-candidates
                        (mapcar 'car anything-semantic-candidates))))
    (persistent-action . (lambda (elm)
                           (anything-semantic-default-action elm)
                           (anything-match-line-color-current-line)))
    (persistent-help . "<span class="quote">Show this entry</span>")
    (action . anything-semantic-default-action)
    "<span class="quote">Needs semantic in CEDET.

http://cedet.sourceforge.net/semantic.shtml
http://cedet.sourceforge.net/</span>"))

<span class="linecomment">;; (anything 'anything-c-source-semantic)</span>

<span class="linecomment">;;; Function is called by</span>
<span class="linecomment">;;;###autoload</span>
(defun anything-simple-call-tree ()
  "<span class="quote">Preconfigured `anything' for simple-call-tree. List function relationships.

Needs simple-call-tree.el.
http://www.emacswiki.org/cgi-bin/wiki/download/simple-call-tree.el</span>"
  (interactive)
  (anything-other-buffer
   '(anything-c-source-simple-call-tree-functions-callers
     anything-c-source-simple-call-tree-callers-functions)
   "<span class="quote">*anything simple-call-tree*</span>"))

(defvar anything-c-source-simple-call-tree-functions-callers
  '((name . "<span class="quote">Function is called by</span>")
    (init . anything-c-simple-call-tree-functions-callers-init)
    (multiline)
    (candidates . anything-c-simple-call-tree-candidates)
    (persistent-action . anything-c-simple-call-tree-persistent-action)
    (persistent-help . "<span class="quote">Show function definitions by rotation</span>")
    (action ("<span class="quote">Find definition selected by persistent-action</span>" .
             anything-c-simple-call-tree-find-definition)))
  "<span class="quote">Needs simple-call-tree.el.
http://www.emacswiki.org/cgi-bin/wiki/download/simple-call-tree.el</span>")

(defvar anything-c-simple-call-tree-tick nil)
(make-variable-buffer-local 'anything-c-simple-call-tree-tick)
(defun anything-c-simple-call-tree-analyze-maybe ()
  (unless (eq (buffer-chars-modified-tick) anything-c-simple-call-tree-tick)
    (simple-call-tree-analyze)
    (setq anything-c-simple-call-tree-tick (buffer-chars-modified-tick))))

(defun anything-c-simple-call-tree-init-base (function message)
  (require 'simple-call-tree)
  (with-no-warnings
    (when (anything-current-buffer-is-modified)
      (anything-c-simple-call-tree-analyze-maybe)
      (let ((list (funcall function simple-call-tree-alist)))
        (with-current-buffer (anything-candidate-buffer 'local)
          (dolist (entry list)
            (let ((funcs (concat "<span class="quote">  </span>" (mapconcat #'identity (cdr entry) "<span class="quote">\n  </span>"))))
              (insert (car entry) message
                      (if (string= funcs "<span class="quote">  </span>")
                          "<span class="quote">  no functions.</span>"
                          funcs)
                      "<span class="quote">\n\n</span>"))))))))

(defun anything-c-simple-call-tree-functions-callers-init ()
  (anything-c-simple-call-tree-init-base 'simple-call-tree-invert
                                         "<span class="quote"> is called by\n</span>"))

(defun anything-c-simple-call-tree-candidates ()
  (with-current-buffer (anything-candidate-buffer)
    (split-string (buffer-string) "<span class="quote">\n\n</span>")))

(defvar anything-c-simple-call-tree-related-functions nil)
(defvar anything-c-simple-call-tree-function-index 0)
(defun anything-c-simple-call-tree-persistent-action (candidate)
  (unless (eq last-command 'anything-execute-persistent-action)
    (setq anything-c-simple-call-tree-related-functions
          (delete "<span class="quote">no functions.</span>"
                  (split-string
                   (replace-regexp-in-string "<span class="quote">  \\| is called by\\| calls </span>"
                                             "<span class="quote"></span>" candidate)
                   "<span class="quote">\n</span>")))
    (setq anything-c-simple-call-tree-function-index -1))
  (incf anything-c-simple-call-tree-function-index)
  (anything-c-simple-call-tree-find-definition candidate))

(defun anything-c-simple-call-tree-find-definition (candidate)
  (find-function
   (intern
    (nth (mod anything-c-simple-call-tree-function-index
              (length anything-c-simple-call-tree-related-functions))
         anything-c-simple-call-tree-related-functions))))

<span class="linecomment">;; (anything 'anything-c-source-simple-call-tree-functions-callers)</span>

<span class="linecomment">;;; Function calls</span>
(defvar anything-c-source-simple-call-tree-callers-functions
  '((name . "<span class="quote">Function calls</span>")
    (init . anything-c-simple-call-tree-callers-functions-init)
    (multiline)
    (candidates . anything-c-simple-call-tree-candidates)
    (persistent-action . anything-c-simple-call-tree-persistent-action)
    (persistent-help . "<span class="quote">Show function definitions by rotation</span>")
    (action ("<span class="quote">Find definition selected by persistent-action</span>" .
             anything-c-simple-call-tree-find-definition)))
  "<span class="quote">Needs simple-call-tree.el.
http://www.emacswiki.org/cgi-bin/wiki/download/simple-call-tree.el</span>")

(defun anything-c-simple-call-tree-callers-functions-init ()
  (anything-c-simple-call-tree-init-base 'identity "<span class="quote"> calls \n</span>"))

<span class="linecomment">;; (anything 'anything-c-source-simple-call-tree-callers-functions)</span>

<span class="linecomment">;;; Commands/Options with doc</span>
(defvar anything-c-auto-document-data nil)
(make-variable-buffer-local 'anything-c-auto-document-data)
(defvar anything-c-source-commands-and-options-in-file
  '((name . "<span class="quote">Commands/Options in file</span>")
    (header-name
     . (lambda (x) (format "<span class="quote">Commands/Options in %s</span>"
                           (buffer-local-value 'buffer-file-name
                                               anything-current-buffer))))
    (candidates . anything-command-and-options-candidates)
    (multiline)
    (action . imenu))
  "<span class="quote">List Commands and Options with doc. It needs auto-document.el .

http://www.emacswiki.org/cgi-bin/wiki/download/auto-document.el</span>")

(eval-when-compile (require 'auto-document nil t))
(defun anything-command-and-options-candidates ()
  (with-current-buffer anything-current-buffer
    (when (and (require 'auto-document nil t)
               (eq major-mode 'emacs-lisp-mode)
               (or (anything-current-buffer-is-modified)
                   (not anything-c-auto-document-data)))
      (or imenu--index-alist (imenu--make-index-alist t))
      (setq anything-c-auto-document-data
            (destructuring-bind (commands options)
                (adoc-construct anything-current-buffer)
              (append
               (loop for (command . doc) in commands
                  for cmdname = (symbol-name command)
                  collect
                    (cons
                     (format "<span class="quote">Command: %s\n %s</span>"
                             (propertize cmdname 'face font-lock-function-name-face)
                             (adoc-first-line doc))
                     (assoc cmdname imenu--index-alist)))
               (loop with var-alist = (cdr (assoc "<span class="quote">Variables</span>" imenu--index-alist))
                  for (option doc default) in options
                  for optname = (symbol-name option)
                  collect
                    (cons
                     (format "<span class="quote">Option: %s\n %s\n default = %s</span>"
                             (propertize optname 'face font-lock-variable-name-face)
                             (adoc-first-line doc)
                             (adoc-prin1-to-string default))
                     (assoc optname
                            var-alist)))))))
    anything-c-auto-document-data))

<span class="linecomment">;; (anything 'anything-c-source-commands-and-options-in-file)</span>

<span class="linecomment">;;;; &lt;Color and Face&gt;</span>
<span class="linecomment">;;; Customize Face</span>
(defvar anything-c-source-customize-face
  '((name . "<span class="quote">Customize Face</span>")
    (init . (lambda ()
              (unless (anything-candidate-buffer)
                (save-window-excursion (list-faces-display))
                (anything-candidate-buffer (get-buffer "<span class="quote">*Faces*</span>")))))
    (candidates-in-buffer)
    (get-line . buffer-substring)
    (action . (lambda (line)
                (customize-face (intern (car (split-string line))))))
    (requires-pattern . 3))
  "<span class="quote">See (info \"(emacs)Faces\")</span>")
<span class="linecomment">;; (anything 'anything-c-source-customize-face)</span>

<span class="linecomment">;; Color</span>
(defvar anything-c-source-colors
  '((name . "<span class="quote">Colors</span>")
    (init . (lambda () (unless (anything-candidate-buffer)
                         (save-window-excursion (list-colors-display))
                         (anything-candidate-buffer (get-buffer "<span class="quote">*Colors*</span>")))))
    (candidates-in-buffer)
    (get-line . buffer-substring)
    (action
     ("<span class="quote">Copy Name</span>" . (lambda (candidate)
                      (kill-new (anything-c-colors-get-name candidate))))
     ("<span class="quote">Copy RGB</span>" . (lambda (candidate)
                     (kill-new (anything-c-colors-get-rgb candidate))))
     ("<span class="quote">Insert Name</span>" . (lambda (candidate)
                        (with-current-buffer anything-current-buffer
                          (insert (anything-c-colors-get-name candidate)))))
     ("<span class="quote">Insert RGB</span>" . (lambda (candidate)
                       (with-current-buffer anything-current-buffer
                         (insert (anything-c-colors-get-rgb candidate))))))))
<span class="linecomment">;; (anything 'anything-c-source-colors)</span>

(defun anything-c-colors-get-name (candidate)
  "<span class="quote">Get color name.</span>"
  (replace-regexp-in-string
   "<span class="quote"> </span>" "<span class="quote"></span>"
   (with-temp-buffer
     (insert (capitalize candidate))
     (goto-char (point-min))
     (search-forward-regexp "<span class="quote">\\s-\\{2,\\}</span>")
     (delete-region (point) (point-max))
     (buffer-string))))

(defun anything-c-colors-get-rgb (candidate)
  "<span class="quote">Get color RGB.</span>"
  (replace-regexp-in-string
   "<span class="quote"> </span>" "<span class="quote"></span>"
   (with-temp-buffer
     (insert (capitalize candidate))
     (goto-char (point-max))
     (search-backward-regexp "<span class="quote">\\s-\\{2,\\}</span>")
     (delete-region (point) (point-min))
     (buffer-string))))

<span class="linecomment">;;;; &lt;Search Engine&gt;</span>
<span class="linecomment">;;; Tracker desktop search</span>
(defvar anything-c-source-tracker-search
  '((name . "<span class="quote">Tracker Search</span>")
    (candidates . (lambda ()
                    (start-process "<span class="quote">tracker-search-process</span>" nil
                                   "<span class="quote">tracker-search</span>"
                                   anything-pattern)))
    (type . file)
    (requires-pattern . 3)
    (delayed))
  "<span class="quote">Source for retrieving files matching the current input pattern
with the tracker desktop search.</span>")
<span class="linecomment">;; (anything 'anything-c-source-tracker-search)</span>

<span class="linecomment">;;; Spotlight (MacOS X desktop search)</span>
(defvar anything-c-source-mac-spotlight
  '((name . "<span class="quote">mdfind</span>")
    (candidates
     . (lambda () (start-process "<span class="quote">mdfind-process</span>" nil "<span class="quote">mdfind</span>" anything-pattern)))
    (type . file)
    (requires-pattern . 3)
    (delayed))
  "<span class="quote">Source for retrieving files via Spotlight's command line
utility mdfind.</span>")
<span class="linecomment">;; (anything 'anything-c-source-mac-spotlight)</span>


<span class="linecomment">;;;; &lt;Kill ring&gt;</span>
<span class="linecomment">;;; Kill ring</span>
(defvar anything-c-source-kill-ring
  '((name . "<span class="quote">Kill Ring</span>")
    (init . (lambda () (anything-attrset 'last-command last-command)))
    (candidates . anything-c-kill-ring-candidates)
    (action . anything-c-kill-ring-action)
    (last-command)
    (migemo)
    (multiline))
  "<span class="quote">Source for browse and insert contents of kill-ring.</span>")

(defun anything-c-kill-ring-candidates ()
  (loop for kill in kill-ring
     unless (or (&lt; (length kill) anything-kill-ring-threshold)
                (string-match "<span class="quote">^[\\s\\t]+$</span>" kill))
     collect kill))

(defun anything-c-kill-ring-action (str)
  "<span class="quote">Insert STR in `kill-ring' and set STR to the head.
If this action is executed just after `yank',
replace with STR as yanked string.</span>"
  (setq kill-ring (delete str kill-ring))
  (if (not (eq (anything-attr 'last-command) 'yank))
      (insert-for-yank str)
      <span class="linecomment">;; from `yank-pop'</span>
      (let ((inhibit-read-only t)
            (before (&lt; (point) (mark t))))
        (if before
            (funcall (or yank-undo-function 'delete-region) (point) (mark t))
            (funcall (or yank-undo-function 'delete-region) (mark t) (point)))
        (setq yank-undo-function nil)
        (set-marker (mark-marker) (point) (current-buffer))
        (insert-for-yank str)
        <span class="linecomment">;; Set the window start back where it was in the yank command,</span>
        <span class="linecomment">;; if possible.</span>
        (set-window-start (selected-window) yank-window-start t)
        (if before
            <span class="linecomment">;; This is like exchange-point-and-mark, but doesn't activate the mark.</span>
            <span class="linecomment">;; It is cleaner to avoid activation, even though the command</span>
            <span class="linecomment">;; loop would deactivate the mark because we inserted text.</span>
            (goto-char (prog1 (mark t)
                         (set-marker (mark-marker) (point) (current-buffer)))))))
  (kill-new str))

<span class="linecomment">;; (anything 'anything-c-source-kill-ring)</span>

<span class="linecomment">;;;; &lt;Mark ring&gt;</span>
<span class="linecomment">;; DO NOT include these sources in `anything-sources' use</span>
<span class="linecomment">;; the commands `anything-mark-ring', `anything-global-mark-ring' or</span>
<span class="linecomment">;; `anything-all-mark-rings' instead.</span>

(defun anything-c-source-mark-ring-candidates ()
  (flet ((get-marks (pos)
           (save-excursion
             (goto-char pos)
             (beginning-of-line)
             (let ((line  (car (split-string (thing-at-point 'line) "<span class="quote">[\n\r]</span>"))))
               (when (string= "<span class="quote"></span>" line)
                 (setq line  "<span class="quote">&lt;EMPTY LINE&gt;</span>"))
               (format "<span class="quote">%7d: %s</span>" (line-number-at-pos) line)))))
    (with-current-buffer anything-current-buffer
      (loop
         with marks = (if (mark) (cons (mark-marker) mark-ring) mark-ring)
         with recip = nil
         for i in marks
         for m = (get-marks i)
         unless (member m recip)
         collect m into recip
         finally return recip))))

(defvar anything-mark-ring-cache nil)
(defvar anything-c-source-mark-ring
  '((name . "<span class="quote">mark-ring</span>")
    (init . (lambda ()
              (setq anything-mark-ring-cache
                    (ignore-errors (anything-c-source-mark-ring-candidates)))))
    (candidates . (lambda ()
                    (anything-aif anything-mark-ring-cache
                        it)))
    (action . (("<span class="quote">Goto line</span>"
                . (lambda (candidate)
                    (anything-goto-line (string-to-number candidate))))))
    (persistent-action . (lambda (candidate)
                           (anything-goto-line (string-to-number candidate))
                           (anything-match-line-color-current-line)))
    (persistent-help . "<span class="quote">Show this line</span>")))

<span class="linecomment">;; (anything 'anything-c-source-mark-ring)</span>

<span class="linecomment">;;;###autoload</span>
(defun anything-mark-ring ()
  "<span class="quote">Preconfigured `anything' for `anything-c-source-mark-ring'.</span>"
  (interactive)
  (anything 'anything-c-source-mark-ring))

<span class="linecomment">;;; Global-mark-ring</span>
(defvar anything-c-source-global-mark-ring
  '((name . "<span class="quote">global-mark-ring</span>")
    (candidates . anything-c-source-global-mark-ring-candidates)
    (action . (("<span class="quote">Goto line</span>"
                . (lambda (candidate)
                    (let ((items (split-string candidate "<span class="quote">:</span>")))
                      (switch-to-buffer (second items))
                      (anything-goto-line (string-to-number (car items))))))))
    (persistent-action . (lambda (candidate)
                           (let ((items (split-string candidate "<span class="quote">:</span>")))
                             (switch-to-buffer (second items))
                             (anything-goto-line (string-to-number (car items)))
                             (anything-match-line-color-current-line))))
    (persistent-help . "<span class="quote">Show this line</span>")))

(defun anything-c-source-global-mark-ring-candidates ()
  (flet ((buf-fn (m)
           (with-current-buffer (marker-buffer m)
             (goto-char m)
             (beginning-of-line)
             (let (line)
               (if (string= "<span class="quote"></span>" line)
                   (setq line  "<span class="quote">&lt;EMPTY LINE&gt;</span>")
                   (setq line (car (split-string (thing-at-point 'line)
                                                 "<span class="quote">[\n\r]</span>"))))
               (format "<span class="quote">%7d:%s:    %s</span>"
                       (line-number-at-pos) (marker-buffer m) line)))))
    (loop
       with marks = global-mark-ring
       with recip = nil
       for i in marks
       for gm = (unless (or (string-match
                             "<span class="quote">^ </span>" (format "<span class="quote">%s</span>" (marker-buffer i)))
                            (null (marker-buffer i)))
                  (buf-fn i))
       when (and gm (not (member gm recip)))
       collect gm into recip
       finally return recip)))

<span class="linecomment">;; (anything 'anything-c-source-global-mark-ring)</span>

<span class="linecomment">;;;###autoload</span>
(defun anything-global-mark-ring ()
  "<span class="quote">Preconfigured `anything' for `anything-c-source-global-mark-ring'.</span>"
  (interactive)
  (anything 'anything-c-source-global-mark-ring))

<span class="linecomment">;;;###autoload</span>
(defun anything-all-mark-rings ()
  "<span class="quote">Preconfigured `anything' for `anything-c-source-global-mark-ring' and \
`anything-c-source-mark-ring'.</span>"
  (interactive)
  (anything '(anything-c-source-mark-ring
              anything-c-source-global-mark-ring)))

<span class="linecomment">;;;; &lt;Register&gt;</span>
<span class="linecomment">;;; Insert from register</span>
(defvar anything-c-source-register
  '((name . "<span class="quote">Registers</span>")
    (candidates . anything-c-register-candidates)
    (action-transformer . anything-c-register-action-transformer)
    (multiline)
    (action))
  "<span class="quote">See (info \"(emacs)Registers\")</span>")

(defun anything-c-register-candidates ()
  "<span class="quote">Collecting register contents and appropriate commands.</span>"
  (loop for (char . val) in register-alist
     for key    = (single-key-description char)
     for string-actions =
       (cond
         ((numberp val)
          (list (int-to-string val)
                'insert-register
                'increment-register))
         ((markerp val)
          (let ((buf (marker-buffer val)))
            (if (null buf)
                (list "<span class="quote">a marker in no buffer</span>")
                (list (concat
                       "<span class="quote">a buffer position:</span>"
                       (buffer-name buf)
                       "<span class="quote">, position </span>"
                       (int-to-string (marker-position val)))
                      'jump-to-register
                      'insert-register))))
         ((and (consp val) (window-configuration-p (car val)))
          (list "<span class="quote">window configuration.</span>"
                'jump-to-register))
         ((and (consp val) (frame-configuration-p (car val)))
          (list "<span class="quote">frame configuration.</span>"
                'jump-to-register))
         ((and (consp val) (eq (car val) 'file))
          (list (concat "<span class="quote">file:</span>"
                        (prin1-to-string (cdr val))
                        "<span class="quote">.</span>")
                'jump-to-register))
         ((and (consp val) (eq (car val) 'file-query))
          (list (concat "<span class="quote">file:a file-query reference: file </span>"
                        (car (cdr val))
                        "<span class="quote">, position </span>"
                        (int-to-string (car (cdr (cdr val))))
                        "<span class="quote">.</span>")
                'jump-to-register))
         ((consp val)
          (let ((lines (format "<span class="quote">%4d</span>" (length val))))
            (list (format "<span class="quote">%s: %s\n</span>" lines
                          (truncate-string-to-width
                           (mapconcat 'identity (list (car val))
                                      <span class="linecomment">;; (mapconcat (lambda (y) y) val</span>
                                      "<span class="quote">^J</span>") (- (window-width) 15)))
                  'insert-register)))
         ((stringp val)
          (list <span class="linecomment">;; without properties</span>
           (substring-no-properties val)
           'insert-register
           'append-to-register
           'prepend-to-register))
         (t
          "<span class="quote">GARBAGE!</span>"))
     collect (cons (format "<span class="quote">register %3s: %s</span>" key (car string-actions))
                   (cons char (cdr string-actions)))))

(defun anything-c-register-action-transformer (actions register-and-functions)
  "<span class="quote">Decide actions by the contents of register.</span>"
  (loop with func-actions =
       '((insert-register
          "<span class="quote">Insert Register</span>" .
          (lambda (c) (insert-register (car c))))
         (jump-to-register
          "<span class="quote">Jump to Register</span>" .
          (lambda (c) (jump-to-register (car c))))
         (append-to-register
          "<span class="quote">Append Region to Register</span>" .
          (lambda (c) (append-to-register
                       (car c) (region-beginning) (region-end))))
         (prepend-to-register
          "<span class="quote">Prepend Region to Register</span>" .
          (lambda (c) (prepend-to-register
                       (car c) (region-beginning) (region-end))))
         (increment-register
          "<span class="quote">Increment Prefix Arg to Register</span>" .
          (lambda (c) (increment-register
                       anything-current-prefix-arg (car c)))))
     for func in (cdr register-and-functions)
     for cell = (assq func func-actions)
     when cell
     collect (cdr cell)))

<span class="linecomment">;; (anything 'anything-c-source-register)</span>

<span class="linecomment">;;; Latex completion</span>
(defun anything-c-latex-math-candidates ()
  "<span class="quote">Collect candidates for latex math completion.</span>"
  (loop for i in (cddr LaTeX-math-menu)
     for elm = (loop for s in i when (vectorp s)
                  collect (cons (aref s 0) (aref s 1)))
     append elm))

(defvar anything-c-source-latex-math
  '((name . "<span class="quote">Latex Math Menu</span>")
    (init . (lambda ()
              (with-current-buffer anything-current-buffer
                (LaTeX-math-mode 1))))
    (candidate-number-limit . 9999)
    (candidates . anything-c-latex-math-candidates)
    (action . (lambda (candidate)
                (call-interactively candidate)))))

<span class="linecomment">;;;; &lt;Headline Extraction&gt;</span>
(defvar anything-c-source-fixme
  '((name . "<span class="quote">TODO/FIXME/DRY comments</span>")
    (headline . "<span class="quote">^.*\\&lt;\\(TODO\\|FIXME\\|DRY\\)\\&gt;.*$</span>")
    (adjust)
    (recenter))
  "<span class="quote">Show TODO/FIXME/DRY comments in current file.</span>")
<span class="linecomment">;; (anything 'anything-c-source-fixme)</span>

(defvar anything-c-source-rd-headline
  '((name . "<span class="quote">RD HeadLine</span>")
    (headline  "<span class="quote">^= \\(.+\\)$</span>" "<span class="quote">^== \\(.+\\)$</span>" "<span class="quote">^=== \\(.+\\)$</span>" "<span class="quote">^==== \\(.+\\)$</span>")
    (condition . (memq major-mode '(rdgrep-mode rd-mode)))
    (migemo)
    (subexp . 1))
  "<span class="quote">Show RD headlines.

RD is Ruby's POD.
http://en.wikipedia.org/wiki/Ruby_Document_format</span>")
<span class="linecomment">;; (anything 'anything-c-source-rd-headline)</span>

(defvar anything-c-source-oddmuse-headline
  '((name . "<span class="quote">Oddmuse HeadLine</span>")
    (headline  "<span class="quote">^= \\(.+\\) =$</span>" "<span class="quote">^== \\(.+\\) ==$</span>"
     "<span class="quote">^=== \\(.+\\) ===$</span>" "<span class="quote">^==== \\(.+\\) ====$</span>")
    (condition . (memq major-mode '(oddmuse-mode yaoddmuse-mode)))
    (migemo)
    (subexp . 1))
  "<span class="quote">Show Oddmuse headlines, such as EmacsWiki.</span>")
<span class="linecomment">;; (anything 'anything-c-source-oddmuse-headline)</span>

(defvar anything-c-source-emacs-source-defun
  '((name . "<span class="quote">Emacs Source DEFUN</span>")
    (headline . "<span class="quote">DEFUN\\|DEFVAR</span>")
    (condition . (string-match "<span class="quote">/emacs2[0-9].+/src/.+c$</span>"
                  (or buffer-file-name "<span class="quote"></span>"))))
  "<span class="quote">Show DEFUN/DEFVAR in Emacs C source file.</span>")
<span class="linecomment">;; (anything 'anything-c-source-emacs-source-defun)</span>

(defvar anything-c-source-emacs-lisp-expectations
  '((name . "<span class="quote">Emacs Lisp Expectations</span>")
    (headline . "<span class="quote">(desc[ ]\\|(expectations</span>")
    (condition . (eq major-mode 'emacs-lisp-mode)))
  "<span class="quote">Show descriptions (desc) in Emacs Lisp Expectations.

http://www.emacswiki.org/cgi-bin/wiki/download/el-expectations.el</span>")
<span class="linecomment">;; (anything 'anything-c-source-emacs-lisp-expectations)</span>

(defvar anything-c-source-emacs-lisp-toplevels
  '((name . "<span class="quote">Emacs Lisp Toplevel / Level 4 Comment / Linkd Star</span>")
    (headline . "<span class="quote">^(\\|(@\\*\\|^;;;;</span>")
    (get-line . buffer-substring)
    (condition . (eq major-mode 'emacs-lisp-mode))
    (adjust))
  "<span class="quote">Show top-level forms, level 4 comments and linkd stars (optional) in Emacs Lisp.
linkd.el is optional because linkd stars are extracted by regexp.
http://www.emacswiki.org/cgi-bin/wiki/download/linkd.el</span>")
<span class="linecomment">;; (anything 'anything-c-source-emacs-lisp-toplevels)</span>

(defvar anything-c-source-org-headline
  '((name . "<span class="quote">Org HeadLine</span>")
    (headline
     "<span class="quote">^\\* \\(.+?\\)\\([ \t]*:[a-zA-Z0-9_@:]+:\\)?[ \t]*$</span>"
     "<span class="quote">^\\*\\* \\(.+?\\)\\([ \t]*:[a-zA-Z0-9_@:]+:\\)?[ \t]*$</span>"
     "<span class="quote">^\\*\\*\\* \\(.+?\\)\\([ \t]*:[a-zA-Z0-9_@:]+:\\)?[ \t]*$</span>"
     "<span class="quote">^\\*\\*\\*\\* \\(.+?\\)\\([ \t]*:[a-zA-Z0-9_@:]+:\\)?[ \t]*$</span>"
     "<span class="quote">^\\*\\*\\*\\*\\* \\(.+?\\)\\([ \t]*:[a-zA-Z0-9_@:]+:\\)?[ \t]*$</span>"
     "<span class="quote">^\\*\\*\\*\\*\\*\\* \\(.+?\\)\\([ \t]*:[a-zA-Z0-9_@:]+:\\)?[ \t]*$</span>"
     "<span class="quote">^\\*\\*\\*\\*\\*\\*\\* \\(.+?\\)\\([ \t]*:[a-zA-Z0-9_@:]+:\\)?[ \t]*$</span>"
     "<span class="quote">^\\*\\*\\*\\*\\*\\*\\*\\* \\(.+?\\)\\([ \t]*:[a-zA-Z0-9_@:]+:\\)?[ \t]*$</span>")
    (condition . (eq major-mode 'org-mode))
    (migemo)
    (subexp . 1)
    (persistent-action . (lambda (elm)
                           (anything-c-action-line-goto elm)
                           (org-cycle)))
    (action-transformer
     . (lambda (actions candidate)
         '(("<span class="quote">Go to Line</span>" . anything-c-action-line-goto)
           ("<span class="quote">Insert Link to This Headline</span>" . anything-c-org-headline-insert-link-to-headline)))))
  "<span class="quote">Show Org headlines.
org-mode is very very much extended text-mode/outline-mode.

See (find-library \"org.el\")
See http://orgmode.org for the latest version.</span>")

(defun anything-c-org-headline-insert-link-to-headline (lineno-and-content)
  (insert
   (save-excursion
     (anything-goto-line (car lineno-and-content))
     (and (looking-at org-complex-heading-regexp)
          (org-make-link-string (concat "<span class="quote">*</span>" (match-string 4)))))))

<span class="linecomment">;; (anything 'anything-c-source-org-headline)</span>

<span class="linecomment">;;; Anything yaoddmuse</span>
<span class="linecomment">;; Be sure to have yaoddmuse.el installed</span>
<span class="linecomment">;; install-elisp may be required if you want to install elisp file from here.</span>
(defvar anything-yaoddmuse-use-cache-file nil)
(defvar anything-c-yaoddmuse-cache-file "<span class="quote">~/.emacs.d/yaoddmuse-cache.el</span>")
(defvar anything-c-yaoddmuse-ew-cache nil)
(defvar anything-c-source-yaoddmuse-emacswiki-edit-or-view
  '((name . "<span class="quote">Yaoddmuse Edit or View (EmacsWiki)</span>")
    (candidates . (lambda ()
                    (if anything-yaoddmuse-use-cache-file
                        (ignore-errors
                          (unless anything-c-yaoddmuse-ew-cache
                            (load anything-c-yaoddmuse-cache-file)
                            (setq anything-c-yaoddmuse-ew-cache
                                  (gethash "<span class="quote">EmacsWiki</span>" yaoddmuse-pages-hash)))
                          anything-c-yaoddmuse-ew-cache)
                        (yaoddmuse-update-pagename t)
                        (gethash "<span class="quote">EmacsWiki</span>" yaoddmuse-pages-hash))))
    (action . (("<span class="quote">Edit page</span>" . (lambda (candidate)
                                (yaoddmuse-edit "<span class="quote">EmacsWiki</span>" candidate)))
               ("<span class="quote">Browse page</span>" . (lambda (candidate)
                                  (yaoddmuse-browse-page "<span class="quote">EmacsWiki</span>" candidate)))
               ("<span class="quote">Browse page other window</span>" . (lambda (candidate)
                                               (if (one-window-p)
                                                   (split-window-vertically))
                                               (yaoddmuse-browse-page "<span class="quote">EmacsWiki</span>" candidate)))
               ("<span class="quote">Browse diff</span>" . (lambda (candidate)
                                  (yaoddmuse-browse-page-diff "<span class="quote">EmacsWiki</span>" candidate)))
               ("<span class="quote">Copy URL</span>" . (lambda (candidate)
                               (kill-new (yaoddmuse-url "<span class="quote">EmacsWiki</span>" candidate))
                               (message "<span class="quote">Have copy page %s's URL to yank.</span>" candidate)))
               ("<span class="quote">Create page</span>" . (lambda (candidate)
                                  (yaoddmuse-edit "<span class="quote">EmacsWiki</span>" anything-input)))
               ("<span class="quote">Update cache</span>" . (lambda (candidate)
                                   (if anything-yaoddmuse-use-cache-file
                                       (progn
                                         (anything-yaoddmuse-cache-pages t)
                                         (setq anything-c-yaoddmuse-ew-cache
                                               (gethash "<span class="quote">EmacsWiki</span>" yaoddmuse-pages-hash)))
                                       (yaoddmuse-update-pagename))))))
    (action-transformer anything-c-yaoddmuse-action-transformer))
  "<span class="quote">Needs yaoddmuse.el.

http://www.emacswiki.org/emacs/download/yaoddmuse.el</span>")

<span class="linecomment">;; (anything 'anything-c-source-yaoddmuse-emacswiki-edit-or-view)</span>

(defvar anything-c-source-yaoddmuse-emacswiki-post-library
  '((name . "<span class="quote">Yaoddmuse Post library (EmacsWiki)</span>")
    (init . (anything-yaoddmuse-init))
    (candidates-in-buffer)
    (action . (("<span class="quote">Post library and Browse</span>" . (lambda (candidate)
                                              (yaoddmuse-post-file (find-library-name candidate)
                                                                   "<span class="quote">EmacsWiki</span>"
                                                                   (file-name-nondirectory (find-library-name candidate))
                                                                   nil t)))
               ("<span class="quote">Post library</span>" . (lambda (candidate)
                                   (yaoddmuse-post-file (find-library-name candidate)
                                                        "<span class="quote">EmacsWiki</span>"
                                                        (file-name-nondirectory (find-library-name candidate))))))))
  "<span class="quote">Needs yaoddmuse.el.

http://www.emacswiki.org/emacs/download/yaoddmuse.el</span>")

<span class="linecomment">;; (anything 'anything-c-source-yaoddmuse-emacswiki-post-library)</span>

(defun anything-c-yaoddmuse-action-transformer (actions candidate)
  "<span class="quote">Allow the use of `install-elisp' only on elisp files.</span>"
  (if (string-match "<span class="quote">\.el$</span>" candidate)
      (append actions '(("<span class="quote">Install Elisp</span>" . (lambda (elm)
                                             (install-elisp-from-emacswiki elm)))))
      actions))

<span class="linecomment">;;;###autoload</span>
(defun anything-yaoddmuse-cache-pages (&optional load)
  "<span class="quote">Fetch the list of files on emacswiki and create cache file.
If load is non--nil load the file and feed `yaoddmuse-pages-hash'.</span>"
  (interactive)
  (yaoddmuse-update-pagename)
  (save-excursion
    (find-file anything-c-yaoddmuse-cache-file)
    (erase-buffer)
    (insert "<span class="quote">(puthash \"EmacsWiki\" '(</span>")
    (loop for i in (gethash "<span class="quote">EmacsWiki</span>" yaoddmuse-pages-hash)
       do
         (insert (concat "<span class="quote">(\"</span>" (car i) "<span class="quote">\") </span>")))
    (insert "<span class="quote">) yaoddmuse-pages-hash)\n</span>")
    (save-buffer)
    (kill-buffer (current-buffer))
    (when (or current-prefix-arg
              load)
      (load anything-c-yaoddmuse-cache-file))))

<span class="linecomment">;;;###autoload</span>
(defun anything-yaoddmuse-emacswiki-edit-or-view ()
  "<span class="quote">Preconfigured `anything' to edit or view EmacsWiki page.

Needs yaoddmuse.el.

http://www.emacswiki.org/emacs/download/yaoddmuse.el</span>"
  (interactive)
  (anything 'anything-c-source-yaoddmuse-emacswiki-edit-or-view))

<span class="linecomment">;;;###autoload</span>
(defun anything-yaoddmuse-emacswiki-post-library ()
  "<span class="quote">Preconfigured `anything' to post library to EmacsWiki.

Needs yaoddmuse.el.

http://www.emacswiki.org/emacs/download/yaoddmuse.el</span>"
  (interactive)
  (anything 'anything-c-source-yaoddmuse-emacswiki-post-library))

(defun anything-yaoddmuse-init ()
  "<span class="quote">Init anything buffer status.</span>"
  (let ((anything-buffer (anything-candidate-buffer 'global))
        (library-list (yaoddmuse-get-library-list)))
    (with-current-buffer anything-buffer
      <span class="linecomment">;; Insert library name.</span>
      (dolist (library library-list)
        (insert (format "<span class="quote">%s\n</span>" library)))
      <span class="linecomment">;; Sort lines.</span>
      (sort-lines nil (point-min) (point-max)))))

<span class="linecomment">;;; Eev anchors</span>
(defvar anything-c-source-eev-anchor
  '((name . "<span class="quote">Anchors</span>")
    (candidates
     . (lambda ()
         (ignore-errors
           (with-current-buffer anything-current-buffer
             (loop initially (goto-char (point-min))
                while (re-search-forward (format ee-anchor-format "<span class="quote">\\([^\.].+\\)</span>") nil t)
                for anchor = (match-string-no-properties 1)
                collect (cons (format "<span class="quote">%5d:%s</span>"
                                      (line-number-at-pos (match-beginning 0))
                                      (format ee-anchor-format anchor)) anchor))))))
    (persistent-action . (lambda (item)
                           (ee-to item)
                           (anything-match-line-color-current-line)))
    (persistent-help . "<span class="quote">Show this entry</span>")
    (action . (("<span class="quote">Goto link</span>" . ee-to)))))
<span class="linecomment">;; (anything 'anything-c-source-eev-anchor)</span>

<span class="linecomment">;;;; &lt;Misc&gt;</span>
<span class="linecomment">;;; Org keywords</span>
(defvar anything-c-source-org-keywords
  '((name . "<span class="quote">Org Keywords</span>")
    (init . anything-c-org-keywords-init)
    (candidates . anything-c-org-keywords-candidates)
    (action . anything-c-org-keywords-insert)
    (persistent-action . anything-c-org-keywords-show-help)
    (persistent-help . "<span class="quote">Show an example and info page to describe this keyword.</span>")
    (keywords-examples)
    (keywords)))
<span class="linecomment">;; (anything 'anything-c-source-org-keywords)</span>
(defvar anything-c-org-keywords-info-location
  '(("<span class="quote">#+TITLE:</span>" . "<span class="quote">(org)Export options</span>")
    ("<span class="quote">#+AUTHOR:</span>" . "<span class="quote">(org)Export options</span>")
    ("<span class="quote">#+DATE:</span>" . "<span class="quote">(org)Export options</span>")
    ("<span class="quote">#+EMAIL:</span>" . "<span class="quote">(org)Export options</span>")
    ("<span class="quote">#+DESCRIPTION:</span>" . "<span class="quote">(org)Export options</span>")
    ("<span class="quote">#+KEYWORDS:</span>" . "<span class="quote">(org)Export options</span>")
    ("<span class="quote">#+LANGUAGE:</span>" . "<span class="quote">(org)Export options</span>")
    ("<span class="quote">#+TEXT:</span>" . "<span class="quote">(org)Export options</span>")
    ("<span class="quote">#+TEXT:</span>" . "<span class="quote">(org)Export options</span>")
    ("<span class="quote">#+OPTIONS:</span>" . "<span class="quote">(org)Export options</span>")
    ("<span class="quote">#+BIND:</span>" . "<span class="quote">(org)Export options</span>")
    ("<span class="quote">#+LINK_UP:</span>" . "<span class="quote">(org)Export options</span>")
    ("<span class="quote">#+LINK_HOME:</span>" . "<span class="quote">(org)Export options</span>")
    ("<span class="quote">#+LATEX_HEADER:</span>" . "<span class="quote">(org)Export options</span>")
    ("<span class="quote">#+EXPORT_SELECT_TAGS:</span>" . "<span class="quote">(org)Export options</span>")
    ("<span class="quote">#+EXPORT_EXCLUDE_TAGS:</span>" . "<span class="quote">(org)Export options</span>")
    ("<span class="quote">#+INFOJS_OPT</span>" . "<span class="quote">(org)Javascript support</span>")
    ("<span class="quote">#+BEGIN_HTML</span>" . "<span class="quote">(org)Quoting HTML tags</span>")
    ("<span class="quote">#+BEGIN_LaTeX</span>" . "<span class="quote">(org)Quoting LaTeX code</span>")
    ("<span class="quote">#+ORGTBL</span>" . "<span class="quote">(org)Radio tables</span>")
    ("<span class="quote">#+HTML:</span>" . "<span class="quote">(org)Quoting HTML tags</span>")
    ("<span class="quote">#+LaTeX:</span>" . "<span class="quote">(org)Quoting LaTeX code</span>")
    ("<span class="quote">#+BEGIN:</span>" . "<span class="quote">(org)Dynamic blocks</span>") <span class="linecomment">;clocktable columnview</span>
    ("<span class="quote">#+BEGIN_EXAMPLE</span>" . "<span class="quote">(org)Literal examples</span>")
    ("<span class="quote">#+BEGIN_QUOTE</span>" . "<span class="quote">(org)Paragraphs</span>")
    ("<span class="quote">#+BEGIN_VERSE</span>" . "<span class="quote">(org)Paragraphs</span>")
    ("<span class="quote">#+BEGIN_SRC</span>" . "<span class="quote">(org)Literal examples</span>")
    ("<span class="quote">#+CAPTION</span>" . "<span class="quote">(org)Tables in HTML export</span>")
    ("<span class="quote">#+LABEL</span>" . "<span class="quote">(org)Tables in LaTeX export</span>")
    ("<span class="quote">#+ATTR_HTML</span>" . "<span class="quote">(org)Links</span>")
    ("<span class="quote">#+ATTR_LaTeX</span>" . "<span class="quote">(org)Images in LaTeX export</span>")))

(defun anything-c-org-keywords-init ()
  (unless (anything-attr 'keywords-examples)
    (require 'org)
    (anything-attrset 'keywords-examples
                      (append
                       (mapcar
                        (lambda (x)
                          (string-match "<span class="quote">^#\\+\\(\\([A-Z_]+:?\\).*\\)</span>" x)
                          (cons (match-string 2 x) (match-string 1 x)))
                        (org-split-string (org-get-current-options) "<span class="quote">\n</span>"))
                       (mapcar 'list org-additional-option-like-keywords)))
    (anything-attrset 'keywords (mapcar 'car (anything-attr 'keywords-examples)))))

(defun anything-c-org-keywords-candidates ()
  (and (or (eq (buffer-local-value 'major-mode anything-current-buffer) 'org-mode)
           (eq (buffer-local-value 'major-mode anything-current-buffer) 'message-mode))
       (anything-attr 'keywords)))

(defun anything-c-org-keywords-insert (keyword)
  (cond ((and (string-match "<span class="quote">BEGIN</span>" keyword)
              (anything-region-active-p))
         (let ((beg (region-beginning))
               (end (region-end)))
           (goto-char beg)
           (insert "<span class="quote">#+</span>" keyword "<span class="quote"> </span>")
           (save-excursion
             (insert "<span class="quote">\n</span>")
             (goto-char end)
             (forward-line 1)
             (insert "<span class="quote">\n#+</span>" (replace-regexp-in-string "<span class="quote">BEGIN</span>" "<span class="quote">END</span>" keyword) "<span class="quote">\n</span>"))))
        ((string-match "<span class="quote">BEGIN</span>" keyword)
         (insert "<span class="quote">#+</span>" keyword "<span class="quote"> </span>")
         (save-excursion
           (insert "<span class="quote">\n#+</span>" (replace-regexp-in-string "<span class="quote">BEGIN</span>" "<span class="quote">END</span>" keyword) "<span class="quote">\n</span>")))
        (t
         (insert "<span class="quote">#+</span>" keyword "<span class="quote"> </span>"))))

(defun anything-c-org-keywords-show-help (keyword)
  (info (or (assoc-default (concat "<span class="quote">#+</span>" keyword) anything-c-org-keywords-info-location)
            "<span class="quote">(org)In-buffer settings</span>"))
  (search-forward (concat "<span class="quote">#+</span>" keyword) nil t)
  (anything-persistent-highlight-point)
  (message "<span class="quote">%s</span>" (or (cdr (assoc keyword (anything-attr 'keywords-examples))) "<span class="quote"></span>")))


<span class="linecomment">;;; Picklist</span>
(defvar anything-c-source-picklist
  '((name . "<span class="quote">Picklist</span>")
    (candidates . (lambda () (mapcar 'car picklist-list)))
    (type . file)))
<span class="linecomment">;; (anything 'anything-c-source-picklist)</span>

<span class="linecomment">;;; BBDB</span>
(defvar bbdb-records)
(defvar bbdb-buffer-name)
(declare-function bbdb "<span class="quote">ext:bbdb-com</span>")
(declare-function bbdb-current-record "<span class="quote">ext:bbdb-com</span>")
(declare-function bbdb-redisplay-one-record "<span class="quote">ext:bbdb-com</span>")
(declare-function bbdb-record-net "<span class="quote">ext:bbdb-com</span>" (string) t)
(declare-function bbdb-current-record "<span class="quote">ext:bbdb-com</span>")
(declare-function bbdb-dwim-net-address "<span class="quote">ext:bbdb-com</span>")
(declare-function bbdb-records "<span class="quote">ext:bbdb-com</span>"
                  (&optional dont-check-disk already-in-db-buffer))

(defun anything-c-bbdb-candidates ()
  "<span class="quote">Return a list of all names in the bbdb database.  The format
is \"Firstname Lastname\".</span>"
  (mapcar (lambda (bbdb-record)
            (replace-regexp-in-string
             "<span class="quote">\\s-+$</span>" "<span class="quote"></span>"
             (concat (aref bbdb-record 0) "<span class="quote"> </span>" (aref bbdb-record 1))))
          (bbdb-records)))

(defun anything-c-bbdb-create-contact (actions candidate)
  "<span class="quote">Action transformer that returns only an entry to add the
current `anything-pattern' as new contact.  All other actions are
removed.</span>"
  (if (string= candidate "<span class="quote">*Add to contacts*</span>")
      '(("<span class="quote">Add to contacts</span>" . (lambda (actions)
                               (bbdb-create-internal
                                (read-from-minibuffer "<span class="quote">Name: </span>" anything-c-bbdb-name)
                                (read-from-minibuffer "<span class="quote">Company: </span>")
                                (read-from-minibuffer "<span class="quote">Email: </span>")
                                nil
                                nil
                                (read-from-minibuffer "<span class="quote">Note: </span>")))))
      actions))

(defun anything-c-bbdb-get-record (candidate)
  "<span class="quote">Return record that match CANDIDATE.</span>"
  (bbdb candidate nil)
  (set-buffer "<span class="quote">*BBDB*</span>")
  (bbdb-current-record))

(defvar anything-c-bbdb-name nil
  "<span class="quote">Only for internal use.</span>")

(defvar anything-c-source-bbdb
  '((name . "<span class="quote">BBDB</span>")
    (candidates . anything-c-bbdb-candidates)
    (action ("<span class="quote">Send a mail</span>" . anything-c-bbdb-compose-mail)
     ("<span class="quote">View person's data</span>" . anything-c-bbdb-view-person-action))
    (filtered-candidate-transformer . (lambda (candidates source)
                                        (setq anything-c-bbdb-name anything-pattern)
                                        (if (not candidates)
                                            (list "<span class="quote">*Add to contacts*</span>")
                                            candidates)))
    (action-transformer . (lambda (actions candidate)
                            (anything-c-bbdb-create-contact actions candidate))))
  "<span class="quote">Needs BBDB.

http://bbdb.sourceforge.net/</span>")
<span class="linecomment">;; (anything 'anything-c-source-bbdb)</span>

(defun anything-c-bbdb-view-person-action (candidate)
  "<span class="quote">View BBDB data of single CANDIDATE or marked candidates.</span>"
  (anything-aif (anything-marked-candidates)
      (let ((bbdb-append-records (length it)))
        (dolist (i it)
          (bbdb-redisplay-one-record (anything-c-bbdb-get-record i))))
    (bbdb-redisplay-one-record (anything-c-bbdb-get-record candidate))))

(defun anything-c-bbdb-collect-mail-addresses ()
  "<span class="quote">Return a list of all mail addresses of records in bbdb buffer.</span>"
  (with-current-buffer bbdb-buffer-name
    (loop for i in bbdb-records
       if (bbdb-record-net (car i))
       collect (bbdb-dwim-net-address (car i)))))

(defun anything-c-bbdb-compose-mail (candidate)
  "<span class="quote">Compose a mail with all records of bbdb buffer.</span>"
  (anything-c-bbdb-view-person-action candidate)
  (let* ((address-list (anything-c-bbdb-collect-mail-addresses))
         (address-str  (mapconcat 'identity address-list "<span class="quote">,\n    </span>")))
    (compose-mail address-str)))

<span class="linecomment">;;; Evaluation Result</span>
(defvar anything-c-source-evaluation-result
  '((name . "<span class="quote">Evaluation Result</span>")
    (disable-shortcuts)
    (dummy)
    (filtered-candidate-transformer . (lambda (candidates source)
                                        (list
                                         (condition-case nil
                                             (with-current-buffer anything-current-buffer
                                               (pp-to-string
                                                (eval (read anything-pattern))))
                                           (error "<span class="quote">Error</span>")))))
    (action ("<span class="quote">Copy result to kill-ring</span>" . (lambda (candidate)
                                            (with-current-buffer anything-buffer
                                              (let ((end (save-excursion
                                                           (goto-char (point-max))
                                                           (search-backward "<span class="quote">\n</span>")
                                                           (point))))
                                                (kill-region (point) end))))))))
<span class="linecomment">;; (anything 'anything-c-source-evaluation-result)</span>

<span class="linecomment">;;;###autoload</span>
(defun anything-eval-expression (arg)
  "<span class="quote">Preconfigured anything for `anything-c-source-evaluation-result'.</span>"
  (interactive "<span class="quote">P</span>")
  (anything 'anything-c-source-evaluation-result (when arg (thing-at-point 'sexp))
            nil nil nil "<span class="quote">*anything eval*</span>"))

<span class="linecomment">;;;###autoload</span>
(defun anything-eval-expression-with-eldoc ()
  "<span class="quote">Preconfigured anything for `anything-c-source-evaluation-result' with `eldoc' support. </span>"
  (interactive)
  (let ((timer (run-with-idle-timer eldoc-idle-delay
                                    'repeat 'anything-eldoc-show-in-eval)))
    (unwind-protect
         (call-interactively 'anything-eval-expression)
      (cancel-timer timer))))

(defun anything-eldoc-show-in-eval ()
  "<span class="quote">Return eldoc in a tooltip for current minibuffer input.</span>"
  (let* ((str-all (minibuffer-completion-contents))
         (sym     (when str-all
                    (with-temp-buffer
                      (insert str-all)
                      (goto-char (point-max))
                      (unless (looking-back "<span class="quote">)\\|\"</span>") (forward-char -1))
                      (eldoc-current-symbol))))
         (doc     (or (eldoc-get-var-docstring sym)
                      (eldoc-get-fnsym-args-string
                       (car (eldoc-fnsym-in-current-sexp))))))
    (when doc (funcall anything-c-eldoc-in-minibuffer-show-fn doc))))

(defcustom anything-c-eldoc-in-minibuffer-show-fn 'anything-c-eldoc-show-in-mode-line
  "<span class="quote">A function to display eldoc info.
Should take one arg: the string to display.</span>"
  :group 'anything-config
  :type  'symbol)

(defvar anything-c-eldoc-show-in-mode-line-delay 12)
(defun anything-c-eldoc-show-in-mode-line (str)
  "<span class="quote">Show string STR in mode-line.</span>"
  (with-anything-window
    (let ((mode-line-format (concat "<span class="quote"> </span>" str)))
      (force-mode-line-update)
      (sit-for anything-c-eldoc-show-in-mode-line-delay))
    (force-mode-line-update)))

<span class="linecomment">;;; Calculation Result</span>
(defvar anything-c-source-calculation-result
  '((name . "<span class="quote">Calculation Result</span>")
    (dummy)
    (filtered-candidate-transformer . (lambda (candidates source)
                                        (list
                                         (condition-case nil
                                             (calc-eval anything-pattern)
                                           (error "<span class="quote">error</span>")))))
    (action ("<span class="quote">Copy result to kill-ring</span>" . kill-new))))
<span class="linecomment">;; (anything 'anything-c-source-calculation-result)</span>

<span class="linecomment">;;;###autoload</span>
(defun anything-calcul-expression ()
  "<span class="quote">Preconfigured anything for `anything-c-source-calculation-result'.</span>"
  (interactive)
  (anything-other-buffer 'anything-c-source-calculation-result "<span class="quote">*anything calcul*</span>"))

<span class="linecomment">;;; Google Suggestions</span>
(defvar anything-gg-sug-lgh-flag 0)
(defun anything-c-google-suggest-fetch (input)
  "<span class="quote">Fetch suggestions for INPUT from XML buffer.
Return an alist with elements like (data . number_results).</span>"
  (let ((request (concat anything-c-google-suggest-url
                         (url-hexify-string input))))
    (flet ((fetch ()
             (loop
                with result-alist = (xml-get-children
                                     (car (xml-parse-region (point-min) (point-max)))
                                     'CompleteSuggestion)
                for i in result-alist
                for data = (cdr (caadr (assoc 'suggestion i)))
                for nqueries = (cdr (caadr (assoc 'num_queries i)))
                for ldata = (length data)
                do
                  (when (&gt; ldata anything-gg-sug-lgh-flag)
                    (setq anything-gg-sug-lgh-flag ldata))
                collect (cons data nqueries) into cont
                finally return cont)))
      (if anything-google-suggest-use-curl-p
          (with-temp-buffer
            (call-process "<span class="quote">curl</span>" nil t nil request)
            (fetch))
          (with-current-buffer
              (url-retrieve-synchronously request)
            (fetch))))))


(defun anything-c-google-suggest-set-candidates ()
  "<span class="quote">Set candidates with result and number of google results found.</span>"
  (let ((suggestions (anything-c-google-suggest-fetch anything-input)))
    (setq suggestions (loop for i in suggestions
                         for interval = (- anything-gg-sug-lgh-flag (length (car i)))
                         for elm = (concat (car i)
                                           (make-string (+ 2 interval) ? )
                                           "<span class="quote">(</span>" (cdr i) "<span class="quote"> results)</span>")
                         collect (cons elm (car i))))
    (if (some (lambda (data) (equal (cdr data) anything-input)) suggestions)
        suggestions
        <span class="linecomment">;; if there is no suggestion exactly matching the input then</span>
        <span class="linecomment">;; prepend a Search on Google item to the list</span>
        (append
         suggestions
         (list (cons (concat "<span class="quote">Search for </span>" "<span class="quote">'</span>" anything-input "<span class="quote">'</span>" "<span class="quote"> on Google</span>")
                     anything-input))))))

(defvar anything-c-google-suggest-default-browser-function nil
  "<span class="quote">*The browse url function you prefer to use with google suggest.
When nil, use the first browser function available
See `anything-browse-url-default-browser-alist'.</span>")

(defun anything-c-google-suggest-action (candidate)
  "<span class="quote">Default action to jump to a google suggested candidate.</span>"
  (let ((arg (concat anything-c-google-suggest-search-url
                                 (url-hexify-string candidate))))
    (anything-aif anything-c-google-suggest-default-browser-function
        (funcall it arg)
      (anything-c-browse-url arg))))

(defvar anything-c-source-google-suggest
  '((name . "<span class="quote">Google Suggest</span>")
    (candidates . anything-c-google-suggest-set-candidates)
    (action . (("<span class="quote">Google Search</span>" . anything-c-google-suggest-action)))
    (volatile)
    (requires-pattern . 3)
    (delayed)))

<span class="linecomment">;; (anything 'anything-c-source-google-suggest)</span>

<span class="linecomment">;;; Yahoo suggestions</span>

(defun anything-c-yahoo-suggest-fetch (input)
  "<span class="quote">Fetch Yahoo suggestions for INPUT from XML buffer.
Return an alist with elements like (data . number_results).</span>"
  (let ((request (concat anything-c-yahoo-suggest-url
                         (url-hexify-string input))))
    (flet ((fetch ()
             (loop
                with result-alist = (xml-get-children
                                     (car (xml-parse-region (point-min) (point-max)))
                                     'Result)
                for i in result-alist
                collect (caddr i))))
      (with-current-buffer
          (url-retrieve-synchronously request)
        (fetch)))))

(defun anything-c-yahoo-suggest-set-candidates ()
  "<span class="quote">Set candidates with Yahoo results found.</span>"
  (let ((suggestions (anything-c-yahoo-suggest-fetch anything-input)))
    (or suggestions
        (append
         suggestions
         (list (cons (concat "<span class="quote">Search for </span>" "<span class="quote">'</span>" anything-input "<span class="quote">'</span>" "<span class="quote"> on Yahoo</span>")
                     anything-input))))))

(defun anything-c-yahoo-suggest-action (candidate)
  "<span class="quote">Default action to jump to a Yahoo suggested candidate.</span>"
  (anything-c-browse-url (concat anything-c-yahoo-suggest-search-url
                                 (url-hexify-string candidate))))

(defvar anything-c-source-yahoo-suggest
  '((name . "<span class="quote">Yahoo Suggest</span>")
    (candidates . anything-c-yahoo-suggest-set-candidates)
    (action . (("<span class="quote">Yahoo Search</span>" . anything-c-yahoo-suggest-action)))
    (volatile)
    (requires-pattern . 3)
    (delayed)))

<span class="linecomment">;; (anything 'anything-c-source-yahoo-suggest)</span>

<span class="linecomment">;;; Surfraw</span>
<span class="linecomment">;;; Need external program surfraw.</span>
<span class="linecomment">;;; http://surfraw.alioth.debian.org/</span>
<span class="linecomment">;; user variables</span>
(require 'browse-url)
(defvar w3m-command nil)
(defvar anything-c-home-url "<span class="quote">http://www.google.fr</span>"
  "<span class="quote">*Default url to use as home url.</span>")

(defvar browse-url-chromium-program "<span class="quote">chromium-browser</span>")
(defvar anything-browse-url-default-browser-alist
  `((,w3m-command . w3m-browse-url)
    (,browse-url-firefox-program . browse-url-firefox)
    (,browse-url-chromium-program . browse-url-chromium)
    (,browse-url-kde-program . browse-url-kde)
    (,browse-url-gnome-moz-program . browse-url-gnome-moz)
    (,browse-url-mozilla-program . browse-url-mozilla)
    (,browse-url-galeon-program . browse-url-galeon)
    (,browse-url-netscape-program . browse-url-netscape)
    (,browse-url-mosaic-program . browse-url-mosaic)
    (,browse-url-xterm-program . browse-url-text-xterm))
  "<span class="quote">*Alist of (executable . function) to try to find a suitable url browser.</span>")

(defun* anything-c-generic-browser (url name &rest args)
  (let ((proc (concat name "<span class="quote"> </span>" url)))
    (message "<span class="quote">Starting %s...</span>" name)
    (apply 'start-process proc nil name
           (append args (list url)))
    (set-process-sentinel
     (get-process proc)
     #'(lambda (process event)
         (when (string= event "<span class="quote">finished\n</span>")
           (message "<span class="quote">%s process %s</span>" process event))))))

(defun browse-url-chromium (url)
  (interactive "<span class="quote">sURL: </span>")
  (anything-c-generic-browser
   url browse-url-chromium-program))

(defun anything-browse-url-default-browser (url &rest args)
  "<span class="quote">Find the first available browser and ask it to load URL.</span>"
  (let ((default-browser (loop
                            for i in anything-browse-url-default-browser-alist
                            thereis (and (car i) (executable-find (car i))))))
    (if default-browser
        (apply default-browser url args)
        (error "<span class="quote">No usable browser found</span>"))))

(defun* anything-c-browse-url (&optional (url anything-c-home-url))
  "<span class="quote">Default command to browse URL.</span>"
  (if browse-url-browser-function
      (funcall browse-url-browser-function url)
      (anything-browse-url-default-browser url)))

(defun anything-c-build-elvi-list ()
  "<span class="quote">Return list of all engines and descriptions handled by surfraw.</span>"
  (cdr
   (with-temp-buffer
     (call-process "<span class="quote">surfraw</span>" nil t nil
                   "<span class="quote">-elvi</span>")
     (split-string (buffer-string) "<span class="quote">\n</span>"))))

(defvar anything-surfraw-default-browser-function nil
  "<span class="quote">*The browse url function you prefer to use with surfraw.
When nil, fallback to `browse-url-browser-function'.</span>")
(defvar anything-surfraw-engines-history nil)
<span class="linecomment">;;;###autoload</span>
(defun anything-surfraw (pattern engine)
  "<span class="quote">Preconfigured `anything' to search PATTERN with search ENGINE.</span>"
  (interactive (list (read-string "<span class="quote">SearchFor: </span>")
                     (anything-comp-read
                      "<span class="quote">Engine: </span>"
                      (anything-c-build-elvi-list)
                      :must-match t
                      :name "<span class="quote">Surfraw Search Engines</span>"
                      :history anything-surfraw-engines-history)))
  (let* ((engine-nodesc (car (split-string engine)))
         (url (with-temp-buffer
                (apply 'call-process "<span class="quote">surfraw</span>" nil t nil
                       (list engine-nodesc "<span class="quote">-p</span>" pattern))
                (replace-regexp-in-string
                 "<span class="quote">\n</span>" "<span class="quote"></span>" (buffer-string))))
         (browse-url-browser-function (or anything-surfraw-default-browser-function
                                          browse-url-browser-function)))
    (if (string= engine-nodesc "<span class="quote">W</span>")
        (anything-c-browse-url)
        (anything-c-browse-url url)
        (setq anything-surfraw-engines-history
              (cons engine (delete engine anything-surfraw-engines-history))))))

<span class="linecomment">;;; Emms</span>

(defun anything-emms-stream-edit-bookmark (elm)
  "<span class="quote">Change the information of current emms-stream bookmark from anything.</span>"
  (let* ((cur-buf anything-current-buffer)
         (bookmark (assoc elm emms-stream-list))
         (name     (read-from-minibuffer "<span class="quote">Description: </span>"
                                         (nth 0 bookmark)))
         (url      (read-from-minibuffer "<span class="quote">URL: </span>"
                                         (nth 1 bookmark)))
         (fd       (read-from-minibuffer "<span class="quote">Feed Descriptor: </span>"
                                         (int-to-string (nth 2 bookmark))))
         (type     (read-from-minibuffer "<span class="quote">Type (url, streamlist, or lastfm): </span>"
                                         (format "<span class="quote">%s</span>" (car (last bookmark))))))
    (save-excursion
      (emms-streams)
      (when (re-search-forward (concat "<span class="quote">^</span>" name) nil t)
        (beginning-of-line)
        (emms-stream-delete-bookmark)
        (emms-stream-add-bookmark name url (string-to-number fd) type)
        (emms-stream-save-bookmarks-file)
        (emms-stream-quit)
        (switch-to-buffer cur-buf)))))

(defun anything-emms-stream-delete-bookmark (elm)
  "<span class="quote">Delete an emms-stream bookmark from anything.</span>"
  (let* ((cur-buf anything-current-buffer)
         (bookmark (assoc elm emms-stream-list))
         (name (nth 0 bookmark)))
    (save-excursion
      (emms-streams)
      (when (re-search-forward (concat "<span class="quote">^</span>" name) nil t)
        (beginning-of-line)
        (emms-stream-delete-bookmark)
        (emms-stream-save-bookmarks-file)
        (emms-stream-quit)
        (switch-to-buffer cur-buf)))))

(defvar anything-c-source-emms-streams
  '((name . "<span class="quote">Emms Streams</span>")
    (init . (lambda ()
              (emms-stream-init)))
    (candidates . (lambda ()
                    (mapcar 'car emms-stream-list)))
    (action . (("<span class="quote">Play</span>" . (lambda (elm)
                           (let* ((stream (assoc elm emms-stream-list))
                                  (fn (intern (concat "<span class="quote">emms-play-</span>" (symbol-name (car (last stream))))))
                                  (url (second stream)))
                             (funcall fn url))))
               ("<span class="quote">Delete</span>" . anything-emms-stream-delete-bookmark)
               ("<span class="quote">Edit</span>" . anything-emms-stream-edit-bookmark)))
    (filtered-candidate-transformer . anything-c-adaptive-sort)))
<span class="linecomment">;; (anything 'anything-c-source-emms-streams)</span>

<span class="linecomment">;; Don't forget to set `emms-source-file-default-directory'</span>
(defvar anything-c-source-emms-dired
  '((name . "<span class="quote">Music Directory</span>")
    (candidates . (lambda ()
                    (cddr (directory-files emms-source-file-default-directory))))
    (action .
     (("<span class="quote">Play Directory</span>" . (lambda (item)
                            (emms-play-directory
                             (expand-file-name
                              item
                              emms-source-file-default-directory))))
      ("<span class="quote">Open dired in file's directory</span>" . (lambda (item)
                                            (anything-c-open-dired
                                             (expand-file-name
                                              item
                                              emms-source-file-default-directory))))))
    (filtered-candidate-transformer . anything-c-adaptive-sort)))
<span class="linecomment">;; (anything 'anything-c-source-emms-dired)</span>

(defface anything-emms-playlist
    '((t (:foreground "<span class="quote">Springgreen4</span>" :underline t)))
  "<span class="quote">*Face used for tracks in current emms playlist.</span>"
  :group 'anything)

(defun anything-c-emms-files-modifier (candidates source)
  (let ((current-playlist (with-current-emms-playlist
                            (loop
                               with cur-list = (emms-playlist-tracks-in-region
                                                (point-min) (point-max))
                               for i in cur-list
                               collect (assoc-default 'name i)))))
    (loop for i in candidates
       if (member (cdr i) current-playlist)
       collect (cons (propertize (car i)
                                 'face 'anything-emms-playlist)
                     (cdr i)) into lis
       else collect i into lis
       finally return lis)))

(defun anything-c-emms-play-current-playlist ()
  "<span class="quote">Play current playlist.</span>"
  (with-current-emms-playlist
    (emms-playlist-first)
    (emms-playlist-mode-play-smart)))

(defvar anything-c-source-emms-files
  '((name . "<span class="quote">Emms files</span>")
    (candidates . (lambda ()
                    (loop for v being the hash-values in emms-cache-db
                       for name      = (assoc-default 'name v)
                       for artist    = (or (assoc-default 'info-artist v) "<span class="quote">unknown</span>")
                       for genre     = (or (assoc-default 'info-genre v) "<span class="quote">unknown</span>")
                       for tracknum  = (or (assoc-default 'info-tracknumber v) "<span class="quote">unknown</span>")
                       for song      = (or (assoc-default 'info-title v) "<span class="quote">unknown</span>")
                       for info      = (concat artist "<span class="quote"> - </span>" genre "<span class="quote"> - </span>" tracknum "<span class="quote">: </span>" song)
                       unless (string-match "<span class="quote">^http:</span>" name) collect (cons info name))))
    (filtered-candidate-transformer . anything-c-emms-files-modifier)
    (action . (("<span class="quote">Play file</span>" . emms-play-file)
               ("<span class="quote">Add to Playlist and play (C-u clear current)</span>"
                . (lambda (candidate)
                    (when anything-current-prefix-arg
                      (emms-playlist-current-clear))
                    (emms-playlist-new)
                    (mapc 'emms-add-playlist-file (anything-marked-candidates))
                    (unless emms-player-playing-p
                      (anything-c-emms-play-current-playlist))))))))

<span class="linecomment">;; (anything 'anything-c-source-emms-files)</span>

<span class="linecomment">;;; Jabber Contacts (jabber.el)</span>
(defun anything-c-jabber-online-contacts ()
  "<span class="quote">List online Jabber contacts.</span>"
  (with-no-warnings
    (let (jids)
      (dolist (item (jabber-concat-rosters) jids)
        (when (get item 'connected)
          (push (if (get item 'name)
                    (cons (get item 'name) item)
                    (cons (symbol-name item) item)) jids))))))

(defvar anything-c-source-jabber-contacts
  '((name . "<span class="quote">Jabber Contacts</span>")
    (init . (lambda () (require 'jabber)))
    (candidates . (lambda () (mapcar 'car (anything-c-jabber-online-contacts))))
    (action . (lambda (x)
                (jabber-chat-with
                 (jabber-read-account)
                 (symbol-name
                  (cdr (assoc x (anything-c-jabber-online-contacts)))))))))
<span class="linecomment">;; (anything 'anything-c-source-jabber-contacts)</span>


<span class="linecomment">;;; Call source.</span>
(defvar anything-source-select-buffer "<span class="quote">*anything source select*</span>")
(defvar anything-c-source-call-source
  `((name . "<span class="quote">Call anything source</span>")
    (candidate-number-limit)
    (candidates . (lambda ()
                    (loop for vname in (all-completions "<span class="quote">anything-c-source-</span>" obarray)
                       for var = (intern vname)
                       for name = (ignore-errors (assoc-default 'name (symbol-value var)))
                       if name collect (cons (format "<span class="quote">%s `%s'</span>"
                                                     name (propertize vname 'face 'font-lock-variable-name-face))
                                             var))))
    (action . (("<span class="quote">Invoke anything with selected source</span>" .
                                                       (lambda (candidate)
                                                         (setq anything-candidate-number-limit 9999)
                                                         (anything candidate nil nil nil nil
                                                                   anything-source-select-buffer)))
               ("<span class="quote">Describe variable</span>" . describe-variable)
               ("<span class="quote">Find variable</span>" . find-variable)))
    (persistent-action . describe-variable)
    (persistent-help . "<span class="quote">Show description of this source</span>")))
<span class="linecomment">;; (anything 'anything-c-source-call-source)</span>

<span class="linecomment">;;;###autoload</span>
(defun anything-call-source ()
  "<span class="quote">Preconfigured `anything' to call anything source.</span>"
  (interactive)
  (anything 'anything-c-source-call-source nil nil nil nil
            anything-source-select-buffer))

(defun anything-call-source-from-anything ()
  "<span class="quote">Call anything source within `anything' session.</span>"
  (interactive)
  (setq anything-input-idle-delay 0)
  (anything-set-sources '(anything-c-source-call-source)))

<span class="linecomment">;;; Execute Preconfigured anything.</span>
(defvar anything-c-source-anything-commands
  '((name . "<span class="quote">Preconfigured Anything</span>")
    (candidates . anything-c-anything-commands-candidates)
    (type . command)
    (candidate-number-limit)))
<span class="linecomment">;; (anything 'anything-c-source-anything-commands)</span>

(defun anything-c-anything-commands-candidates ()
  (loop for (cmd . desc) in (anything-c-list-preconfigured-anything)
     collect (cons (if (where-is-internal cmd nil t)
                       (substitute-command-keys (format "<span class="quote">M-x %s (\\[%s]) : %s</span>" cmd cmd desc))
                       (substitute-command-keys (format "<span class="quote">\\[%s] : %s</span>" cmd desc)))
                   cmd)))

<span class="linecomment">;;;###autoload</span>
(defun anything-execute-anything-command ()
  "<span class="quote">Preconfigured `anything' to execute preconfigured `anything'.</span>"
  (interactive)
  (anything-other-buffer 'anything-c-source-anything-commands
                         "<span class="quote">*anything commands*</span>"))

<span class="linecomment">;; Occur</span>
(defun anything-c-occur-init ()
  (anything-candidate-buffer anything-current-buffer))

(defun anything-c-occur-get-line (s e)
  (format "<span class="quote">%7d:%s</span>" (line-number-at-pos (1- s)) (buffer-substring s e)))

(defvar anything-c-source-occur
  '((name . "<span class="quote">Occur</span>")
    (init . anything-c-occur-init)
    (candidates-in-buffer)
    (migemo)
    (get-line . anything-c-occur-get-line)
    (type . line)
    (recenter)
    (requires-pattern . 1)
    (delayed)
    (volatile)))
<span class="linecomment">;; (anything 'anything-c-source-occur)</span>

<span class="linecomment">;;; Anything browse code.</span>
(defun anything-c-browse-code-get-line (beg end)
  "<span class="quote">Select line if it match the regexp corresponding to current `major-mode'.
Line is parsed for BEG position to END position.</span>"
  (let ((str-line (buffer-substring beg end))
        (regexp   (assoc-default major-mode
                                 anything-c-browse-code-regexp-alist))
        (num-line (if (string= anything-pattern "<span class="quote"></span>") beg (1- beg))))
    (when (and regexp (string-match regexp str-line))
      (format "<span class="quote">%4d:%s</span>" (line-number-at-pos num-line) str-line))))


(defvar anything-c-source-browse-code
  '((name . "<span class="quote">Browse code</span>")
    (init . (lambda ()
              (anything-candidate-buffer anything-current-buffer)
              (with-current-buffer anything-current-buffer
                (jit-lock-fontify-now))))
    (candidate-number-limit . 9999)
    (candidates-in-buffer)
    (get-line . anything-c-browse-code-get-line)
    (type . line)
    (recenter)))

<span class="linecomment">;; Do many actions for input</span>
(defvar anything-c-source-create
  '((name . "<span class="quote">Create</span>")
    (dummy)
    (action)
    (action-transformer . anything-create--actions))
  "<span class="quote">Do many create actions from `anything-pattern'.
See also `anything-create--actions'.</span>")
<span class="linecomment">;; (anything 'anything-c-source-create)</span>

(defun anything-create-from-anything ()
  "<span class="quote">Run `anything-create' from `anything' as a fallback.</span>"
  (interactive)
  (anything-run-after-quit 'anything-create nil anything-pattern))

<span class="linecomment">;;;###autoload</span>
(defun anything-create (&optional string initial-input)
  "<span class="quote">Preconfigured `anything' to do many create actions from STRING.
See also `anything-create--actions'.</span>"
  (interactive)
  (setq string (or string (read-string "<span class="quote">Create Anything: </span>" initial-input)))
  (anything '(((name . "<span class="quote">Anything Create</span>")
               (header-name . (lambda (_) (format "<span class="quote">Action for \"%s\"</span>" string)))
               (candidates . anything-create--actions)
               (candidate-number-limit)
               (action . (lambda (func) (funcall func string)))))))

(defun anything-create--actions (&rest ignored)
  "<span class="quote">Default actions for `anything-create' / `anything-c-source-create'.</span>"
  (remove-if-not
   (lambda (pair) (and (consp pair) (functionp (cdr pair))))
   (append anything-create--actions-private
           '(("<span class="quote">find-file</span>" . find-file)
             ("<span class="quote">find-file other window</span>" . find-file-other-window)
             ("<span class="quote">New buffer</span>" . switch-to-buffer)
             ("<span class="quote">New buffer other window</span>" . switch-to-buffer-other-window)
             ("<span class="quote">Bookmark Set</span>" . bookmark-set)
             ("<span class="quote">Set Register</span>" .
              (lambda (x) (set-register (read-char "<span class="quote">Register: </span>") x)))
             ("<span class="quote">Insert Linkd star</span>" . linkd-insert-star)
             ("<span class="quote">Insert Linkd Tag</span>" . linkd-insert-tag)
             ("<span class="quote">Insert Linkd Link</span>" . linkd-insert-link)
             ("<span class="quote">Insert Linkd Lisp</span>" . linkd-insert-lisp)
             ("<span class="quote">Insert Linkd Wiki</span>" . linkd-insert-wiki)
             ("<span class="quote">Google Search</span>" . google)))))

<span class="linecomment">;; Minibuffer History</span>
(defvar anything-c-source-minibuffer-history
  '((name . "<span class="quote">Minibuffer History</span>")
    (header-name . (lambda (name) (format "<span class="quote">%s (%s)</span>" name minibuffer-history-variable)))
    (candidates
     . (lambda ()
         (let ((history (loop
                           for i in (symbol-value minibuffer-history-variable)
                           unless (string= "<span class="quote"></span>" i) collect i)))
           (if (consp (car history))
               (mapcar 'prin1-to-string history)
               history))))
    (migemo)
    (action . insert)))
<span class="linecomment">;; (anything 'anything-c-source-minibuffer-history)</span>

<span class="linecomment">;; elscreen</span>
(defvar anything-c-source-elscreen
  '((name . "<span class="quote">Elscreen</span>")
    (candidates . (lambda ()
                    (if (cdr (elscreen-get-screen-to-name-alist))
                        (sort
                         (loop for sname in (elscreen-get-screen-to-name-alist)
                            append (list (format "<span class="quote">[%d] %s</span>" (car sname) (cdr sname))) into lst
                            finally (return lst))
                         #'(lambda (a b) (compare-strings a nil nil b nil nil))))))
    (action . (("<span class="quote">Change Screen</span>".
                               (lambda (candidate)
                                 (elscreen-goto (- (aref candidate 1) (aref "<span class="quote">0</span>" 0)))))
               ("<span class="quote">Kill Screen(s)</span>".
                                (lambda (candidate)
                                  (dolist (i (anything-marked-candidates))
                                    (elscreen-goto (- (aref i 1) (aref "<span class="quote">0</span>" 0)))
                                    (elscreen-kill))))
               ("<span class="quote">Only Screen</span>".
                             (lambda (candidate)
                               (elscreen-goto (- (aref candidate 1) (aref "<span class="quote">0</span>" 0)))
                               (elscreen-kill-others)))))))
<span class="linecomment">;; (anything 'anything-c-source-elscreen)</span>

<span class="linecomment">;;;; &lt;System&gt;</span>

<span class="linecomment">;;; Top (process)</span>
(defvar anything-c-top-command "<span class="quote">COLUMNS=%s top -b -n 1</span>"
  "<span class="quote">Top command (batch mode). %s is replaced with `frame-width'.</span>")
(defvar anything-c-source-top
  '((name . "<span class="quote">Top (Press C-c C-u to refresh)</span>")
    (init . anything-c-top-init)
    (candidates-in-buffer)
    (display-to-real . anything-c-top-display-to-real)
    (update . anything-c-top-update)
    (persistent-action . anything-c-top-sh-persistent-action)
    (persistent-help . "<span class="quote">SIGTERM</span>")
    (action
     ("<span class="quote">kill (TERM)</span>" . (lambda (pid) (anything-c-top-sh (format "<span class="quote">kill -TERM %s</span>" pid))))
     ("<span class="quote">kill (KILL)</span>" . (lambda (pid) (anything-c-top-sh (format "<span class="quote">kill -KILL %s</span>" pid))))
     ("<span class="quote">Copy PID</span>" . (lambda (pid) (kill-new pid))))))
<span class="linecomment">;; (anything 'anything-c-source-top)</span>

(defun anything-c-top-sh (cmd)
  (message "<span class="quote">Executed %s\n%s</span>" cmd (shell-command-to-string cmd)))

(defun anything-c-top-sh-persistent-action (pid)
  (delete-other-windows)
  (anything-c-top-sh (format "<span class="quote">kill -TERM %s</span>" pid))
  (anything-force-update))

(defun anything-c-top-init ()
  (with-current-buffer (anything-candidate-buffer 'global)
    (call-process-shell-command
     (format anything-c-top-command
             (- (frame-width) (if anything-enable-digit-shortcuts 4 0)))
     nil (current-buffer))))

(defun anything-c-top-display-to-real (line)
  (car (split-string line)))

(defun anything-c-top-update ()
  (let ((anything-source-name (assoc-default 'name anything-c-source-top))) <span class="linecomment">;UGLY HACK</span>
    (anything-c-top-init)))

<span class="linecomment">;;;###autoload</span>
(defun anything-top ()
  "<span class="quote">Preconfigured `anything' for top command.</span>"
  (interactive)
  (let ((anything-samewindow t)
        (anything-enable-shortcuts)
        (anything-display-function 'anything-default-display-buffer)
        (anything-candidate-number-limit 9999))
    (save-window-excursion
      (delete-other-windows)
      (anything-other-buffer 'anything-c-source-top "<span class="quote">*anything top*</span>"))))

<span class="linecomment">;;; Timers</span>
(defvar anything-c-source-absolute-time-timers
  '((name . "<span class="quote">Absolute Time Timers</span>")
    (candidates . timer-list)
    (type . timer)))
<span class="linecomment">;; (anything 'anything-c-source-absolute-time-timers)</span>

(defvar anything-c-source-idle-time-timers
  '((name . "<span class="quote">Idle Time Timers</span>")
    (candidates . timer-idle-list)
    (type . timer)))
<span class="linecomment">;; (anything 'anything-c-source-idle-time-timers)</span>

(defun anything-c-timer-real-to-display (timer)
  (destructuring-bind (triggered t1 t2 t3 repeat-delay func args idle-delay)
      (append timer nil)                <span class="linecomment">;use `append' to convert vector-&gt;list</span>
    (format "<span class="quote">%s repeat=%5S %s(%s)</span>"
            (let ((time (list t1 t2 t3)))
              (if idle-delay
                  (format-time-string "<span class="quote">idle-for=%5s</span>" time)
                  (format-time-string "<span class="quote">%m/%d %T</span>" time)))
            repeat-delay
            func
            (mapconcat 'prin1-to-string args "<span class="quote"> </span>"))))

<span class="linecomment">;;; X RandR resolution change</span>
<span class="linecomment">;;; FIXME I do not care multi-display.</span>
(defvar anything-c-xrandr-output "<span class="quote">VGA</span>")
(defvar anything-c-xrandr-screen "<span class="quote">0</span>")
(defvar anything-c-source-xrandr-change-resolution
  '((name . "<span class="quote">Change Resolution</span>")
    (candidates
     . (lambda ()
         (with-temp-buffer
           (call-process "<span class="quote">xrandr</span>" nil (current-buffer) nil
                         "<span class="quote">--screen</span>" anything-c-xrandr-screen "<span class="quote">-q</span>")
           (goto-char 1)
           (loop while (re-search-forward "<span class="quote">   \\([0-9]+x[0-9]+\\)</span>" nil t)
              collect (match-string 1)))))
    (action
     ("<span class="quote">Change Resolution</span>" . (lambda (mode)
                              (call-process "<span class="quote">xrandr</span>" nil nil nil
                                            "<span class="quote">--screen</span>" anything-c-xrandr-screen
                                            "<span class="quote">--output</span>" anything-c-xrandr-output
                                            "<span class="quote">--mode</span>" mode))))))
<span class="linecomment">;; (anything 'anything-c-source-xrandr-change-resolution)</span>

<span class="linecomment">;;; Xfont selection</span>
(defun anything-c-persistent-xfont-action (elm)
  "<span class="quote">Show current font temporarily</span>"
  (let ((current-font (cdr (assoc 'font (frame-parameters))))
        (default-font elm))
    (unwind-protect
         (progn (set-frame-font default-font 'keep-size) (sit-for 2))
      (set-frame-font current-font))))

(defvar anything-c-xfonts-cache nil)
(defvar anything-c-source-xfonts
  '((name . "<span class="quote">X Fonts</span>")
    (init . (lambda ()
              (unless anything-c-xfonts-cache
                (setq anything-c-xfonts-cache
                      (x-list-fonts "<span class="quote">*</span>")))))
    (candidates . anything-c-xfonts-cache)
    (action . (("<span class="quote">Copy to kill ring</span>" . (lambda (elm)
                                        (kill-new elm)))
               ("<span class="quote">Set Font</span>" . (lambda (elm)
                               (kill-new elm)
                               (set-frame-font elm 'keep-size)
                               (message "<span class="quote">New font have been copied to kill ring</span>")))))
    (persistent-action . anything-c-persistent-xfont-action)
    (persistent-help . "<span class="quote">Switch to this font temporarily</span>")))

<span class="linecomment">;;;###autoload</span>
(defun anything-select-xfont ()
  "<span class="quote">Preconfigured `anything' to select Xfont.</span>"
  (interactive)
  (anything-other-buffer 'anything-c-source-xfonts "<span class="quote">*anything select* xfont</span>"))

<span class="linecomment">;; (anything 'anything-c-source-xfonts)</span>

<span class="linecomment">;;; World time</span>

(defvar anything-c-source-time-world
  '((name . "<span class="quote">Time World List</span>")
    (init . (lambda ()
              (let ((anything-buffer (anything-candidate-buffer 'global)))
                (with-current-buffer anything-buffer
                  (display-time-world-display display-time-world-list)))))
    (candidates-in-buffer)))

<span class="linecomment">;;;###autoload</span>
(defun anything-world-time ()
  "<span class="quote">Preconfigured `anything' to show world time.</span>"
  (interactive)
  (anything-other-buffer 'anything-c-source-time-world "<span class="quote">*anything world time*</span>"))

<span class="linecomment">;;; Source for Debian/Ubuntu users</span>
(defvar anything-c-source-apt
  '((name . "<span class="quote">APT</span>")
    (init . anything-c-apt-init)
    (candidates-in-buffer)
    (candidate-transformer anything-c-apt-candidate-transformer)
    (display-to-real . anything-c-apt-display-to-real)
    (candidate-number-limit . 9999)
    (action
     ("<span class="quote">Show package description</span>" . anything-c-apt-cache-show)
     ("<span class="quote">Install package</span>" . anything-c-apt-install)
     ("<span class="quote">Remove package</span>" . anything-c-apt-uninstall)
     ("<span class="quote">Purge package</span>" . anything-c-apt-purge))
    (persistent-action . anything-c-apt-persistent-action)
    (persistent-help . "<span class="quote">Show - C-u Refresh</span>")))
<span class="linecomment">;; (anything 'anything-c-source-apt)</span>

(defvar anything-c-apt-query "<span class="quote">emacs</span>")
(defvar anything-c-apt-search-command "<span class="quote">apt-cache search '%s'</span>")
(defvar anything-c-apt-show-command "<span class="quote">apt-cache show '%s'</span>")
(defvar anything-c-apt-installed-packages nil)

(defface anything-apt-installed
    '((t (:foreground "<span class="quote">green</span>")))
  "<span class="quote">*Face used for apt installed candidates.</span>"
  :group 'anything)

(defun anything-c-apt-refresh ()
  "<span class="quote">Refresh installed candidates list.</span>"
  (setq anything-c-apt-installed-packages nil)
  (anything-force-update))

(defun anything-c-apt-persistent-action (candidate)
  "<span class="quote">Persistent action for APT source.</span>"
  (if current-prefix-arg
      (anything-c-apt-refresh)
      (anything-c-apt-cache-show candidate)))

<span class="linecomment">;;;###autoload</span>
(defun anything-apt (query)
  "<span class="quote">Preconfigured `anything' : frontend of APT package manager.</span>"
  (interactive "<span class="quote">sAPT search: </span>")
  (let ((anything-c-apt-query query))
    (anything 'anything-c-source-apt)))

(defun anything-c-apt-candidate-transformer (candidates)
  "<span class="quote">Show installed candidates in a different color.</span>"
  (loop
     with all
     for cand in candidates
     for name = (anything-c-apt-display-to-real cand)
     if (member name anything-c-apt-installed-packages)
     collect (propertize cand 'face 'anything-apt-installed) into all
     else collect cand into all finally return all))

(defun anything-c-apt-init ()
  "<span class="quote">Initialize list of debian packages.</span>"
  (unless anything-c-apt-installed-packages
    (message "<span class="quote">Updating installed candidate list...</span>")
    (setq anything-c-apt-installed-packages
          (with-temp-buffer
            (call-process-shell-command "<span class="quote">dpkg --get-selections</span>"
                                        nil (current-buffer))
            (loop for i in (split-string (buffer-string) "<span class="quote">\n</span>" t)
               collect (car (split-string i))))))
  (with-current-buffer
      (anything-candidate-buffer
       (get-buffer-create (format "<span class="quote">*anything-apt:%s*</span>" anything-c-apt-query)))
    (erase-buffer)
    (call-process-shell-command
     (format anything-c-apt-search-command anything-c-apt-query)
     nil (current-buffer)))
  (message "<span class="quote">Updating installed candidate list...done</span>"))

(defun anything-c-apt-display-to-real (line)
  "<span class="quote">Return only name of a debian package.
LINE is displayed like:
package name - description.</span>"
  (car (split-string line "<span class="quote"> - </span>")))

<span class="linecomment">;;;###autoload</span>
(defun anything-c-shell-command-if-needed (command)
  (interactive "<span class="quote">sShell command: </span>")
  (if (get-buffer command)		<span class="linecomment">; if the buffer already exists</span>
      (switch-to-buffer command)	<span class="linecomment">; then just switch to it</span>
      (switch-to-buffer command)	<span class="linecomment">; otherwise create it</span>
      (insert (shell-command-to-string command))))

(defun anything-c-apt-cache-show (package)
  (anything-c-shell-command-if-needed (format anything-c-apt-show-command package)))

(defun anything-c-apt-install (package)
  (anything-c-apt-install1 :action 'install))

(defun anything-c-apt-uninstall (package)
  (anything-c-apt-install1 :action 'uninstall))

(defun anything-c-apt-purge (package)
  (anything-c-apt-install1 :action 'purge))

(defun* anything-c-apt-install1 (&key action)
  (ansi-term (getenv "<span class="quote">SHELL</span>") "<span class="quote">anything apt</span>")
  (term-line-mode)
  (let ((command   (case action
                   ('install   "<span class="quote">sudo apt-get install </span>")
                   ('uninstall "<span class="quote">sudo apt-get remove </span>")
                   ('purge     "<span class="quote">sudo apt-get purge </span>")
                   (t          (error "<span class="quote">Unknow action</span>"))))
        (beg       (point))
        end
        (cand-list (mapconcat #'(lambda (x) (format "<span class="quote">'%s'</span>" x))
                              (anything-marked-candidates) "<span class="quote"> </span>")))
    (goto-char (point-max))
    (insert (concat command cand-list))
    (setq end (point))
    (if (y-or-n-p (format "<span class="quote">%s package</span>" (symbol-name action)))
        (progn
          (setq anything-c-external-commands-list nil)
          (setq anything-c-apt-installed-packages nil)
          (term-char-mode) (term-send-input))
        (delete-region beg end) (term-send-eof) (kill-buffer))))

<span class="linecomment">;; (anything-c-apt-install "jed")</span>

<span class="linecomment">;;; Sources for gentoo users</span>
(defvar anything-c-gentoo-use-flags nil)
(defvar anything-c-gentoo-buffer "<span class="quote">*anything-gentoo-output*</span>")
(defvar anything-c-cache-gentoo nil)
(defvar anything-c-cache-world nil)
(defvar anything-c-source-gentoo
  '((name . "<span class="quote">Portage sources</span>")
    (init . (lambda ()
              (get-buffer-create anything-c-gentoo-buffer)
              (unless anything-c-cache-gentoo
                (anything-c-gentoo-setup-cache))
              (unless anything-c-cache-world
                (setq anything-c-cache-world (anything-c-gentoo-get-world)))
              (anything-c-gentoo-init-list)))
    (candidates-in-buffer)
    (match . identity)
    (candidate-transformer anything-c-highlight-world)
    (action . (("<span class="quote">Show package</span>" . (lambda (elm)
                                   (anything-c-gentoo-eshell-action elm "<span class="quote">eix</span>")))
               ("<span class="quote">Show history</span>" . (lambda (elm)
                                   (if (member elm anything-c-cache-world)
                                       (anything-c-gentoo-eshell-action elm "<span class="quote">genlop -qe</span>")
                                       (message "<span class="quote">No infos on packages not yet installed</span>"))))
               ("<span class="quote">Copy in kill-ring</span>" . kill-new)
               ("<span class="quote">insert at point</span>" . insert)
               ("<span class="quote">Browse HomePage</span>" . (lambda (elm)
                                      (let ((urls (anything-c-gentoo-get-url elm)))
                                        (browse-url (anything-comp-read "<span class="quote">Url: </span>" urls :must-match t)))))
               ("<span class="quote">Show extra infos</span>" . (lambda (elm)
                                       (if (member elm anything-c-cache-world)
                                           (anything-c-gentoo-eshell-action elm "<span class="quote">genlop -qi</span>")
                                           (message "<span class="quote">No infos on packages not yet installed</span>"))))
               ("<span class="quote">Show use flags</span>" . (lambda (elm)
                                     (anything-c-gentoo-default-action elm "<span class="quote">equery</span>" "<span class="quote">-C</span>" "<span class="quote">u</span>")
                                     (font-lock-add-keywords nil '(("<span class="quote">^\+.*</span>" . font-lock-variable-name-face)))
                                     (font-lock-mode 1)))
               ("<span class="quote">Run emerge pretend</span>" . (lambda (elm)
                                         (anything-c-gentoo-eshell-action elm "<span class="quote">emerge -p</span>")))
               ("<span class="quote">Emerge</span>" . (lambda (elm)
                             (anything-gentoo-install elm :action 'install)))
               ("<span class="quote">Unmerge</span>" . (lambda (elm)
                              (anything-gentoo-install elm :action 'uninstall)))
               ("<span class="quote">Show dependencies</span>" . (lambda (elm)
                                        (anything-c-gentoo-default-action elm "<span class="quote">equery</span>" "<span class="quote">-C</span>" "<span class="quote">d</span>")))
               ("<span class="quote">Show related files</span>" . (lambda (elm)
                                         (anything-c-gentoo-default-action elm "<span class="quote">equery</span>" "<span class="quote">files</span>")))
               ("<span class="quote">Refresh</span>" . (lambda (elm)
                              (anything-c-gentoo-setup-cache)
                              (setq anything-c-cache-world (anything-c-gentoo-get-world))))))))

<span class="linecomment">;; (anything 'anything-c-source-gentoo)</span>

(defun* anything-gentoo-install (candidate &key action)
  (setq anything-c-external-commands-list nil)
  (ansi-term (getenv "<span class="quote">SHELL</span>") "<span class="quote">Gentoo emerge</span>")
  (term-line-mode)
  (let ((command (case action
                   ('install "<span class="quote">sudo emerge -av </span>")
                   ('uninstall "<span class="quote">sudo emerge -avC </span>")
                   (t (error "<span class="quote">Unknow action</span>"))))
        (elms (mapconcat 'identity (anything-marked-candidates) "<span class="quote"> </span>"))
        (beg (point)) end)
    (goto-char (point-max))
    (insert (concat command elms))
    (setq end (point))
    (term-char-mode) (term-send-input)))

(defun anything-c-gentoo-default-action (elm command &rest args)
  "<span class="quote">Gentoo default action that use `anything-c-gentoo-buffer'.</span>"
  (if (member elm anything-c-cache-world)
      (progn
        (switch-to-buffer anything-c-gentoo-buffer)
        (erase-buffer)
        (let ((com-list (append args (list elm))))
          (apply #'call-process command nil t nil
                 com-list)))
      (message "<span class="quote">No infos on packages not yet installed</span>")))

(defvar anything-c-source-use-flags
  '((name . "<span class="quote">Use Flags</span>")
    (init . (lambda ()
              (unless anything-c-gentoo-use-flags
                (anything-c-gentoo-setup-use-flags-cache))
              (anything-c-gentoo-get-use)))
    (candidates-in-buffer)
    (match . identity)
    (candidate-transformer anything-c-highlight-local-use)
    (action . (("<span class="quote">Description</span>"
                . (lambda (elm)
                    (switch-to-buffer anything-c-gentoo-buffer)
                    (erase-buffer)
                    (apply #'call-process "<span class="quote">euse</span>" nil t nil
                           `("<span class="quote">-i</span>"
                             ,elm))
                    (font-lock-add-keywords nil `((,elm . font-lock-variable-name-face)))
                    (font-lock-mode 1)))
               ("<span class="quote">Enable</span>"
                . (lambda (elm)
                    (anything-c-gentoo-eshell-action elm "<span class="quote">*sudo -p Password: euse -E</span>")))
               ("<span class="quote">Disable</span>"
                . (lambda (elm)
                    (anything-c-gentoo-eshell-action elm "<span class="quote">*sudo -p Password: euse -D</span>")))
               ("<span class="quote">Remove</span>"
                . (lambda (elm)
                    (anything-c-gentoo-eshell-action elm "<span class="quote">*sudo -p Password: euse -P</span>")))
               ("<span class="quote">Show which dep use this flag</span>"
                . (lambda (elm)
                    (switch-to-buffer anything-c-gentoo-buffer)
                    (erase-buffer)
                    (apply #'call-process "<span class="quote">equery</span>" nil t nil
                           `("<span class="quote">-C</span>"
                             "<span class="quote">h</span>"
                             ,elm))))))))


<span class="linecomment">;; (anything 'anything-c-source-use-flags)</span>

(defun anything-c-gentoo-init-list ()
  "<span class="quote">Initialize buffer with all packages in Portage.</span>"
  (let* ((portage-buf (get-buffer-create "<span class="quote">*anything-gentoo*</span>"))
         (buf (anything-candidate-buffer 'portage-buf)))
    (with-current-buffer buf
      (dolist (i anything-c-cache-gentoo)
        (insert (concat i "<span class="quote">\n</span>"))))))

(defun anything-c-gentoo-setup-cache ()
  "<span class="quote">Set up `anything-c-cache-gentoo'</span>"
  (setq anything-c-cache-gentoo
        (split-string (with-temp-buffer
                        (call-process "<span class="quote">eix</span>" nil t nil
                                      "<span class="quote">--only-names</span>")
                        (buffer-string)))))

(defun anything-c-gentoo-eshell-action (elm command)
  (when (get-buffer "<span class="quote">*EShell Command Output*</span>")
    (kill-buffer "<span class="quote">*EShell Command Output*</span>"))
  (message "<span class="quote">Wait searching...</span>")
  (let ((buf-fname (buffer-file-name anything-current-buffer)))
    (if (and buf-fname (string-match tramp-file-name-regexp buf-fname))
        (progn
          (save-window-excursion
            (pop-to-buffer "<span class="quote">*scratch*</span>")
            (eshell-command (format "<span class="quote">%s %s</span>" command elm)))
          (pop-to-buffer "<span class="quote">*EShell Command Output*</span>"))
        (eshell-command (format "<span class="quote">%s %s</span>" command elm)))))

(defun anything-c-gentoo-get-use ()
  "<span class="quote">Initialize buffer with all use flags.</span>"
  (let* ((use-buf (get-buffer-create "<span class="quote">*anything-gentoo-use*</span>"))
         (buf (anything-candidate-buffer 'use-buf)))
    (with-current-buffer buf
      (dolist (i anything-c-gentoo-use-flags)
        (insert (concat i "<span class="quote">\n</span>"))))))


(defun anything-c-gentoo-setup-use-flags-cache ()
  "<span class="quote">Setup `anything-c-gentoo-use-flags'</span>"
  (setq anything-c-gentoo-use-flags
        (split-string (with-temp-buffer
                        (call-process "<span class="quote">eix</span>" nil t nil
                                      "<span class="quote">--print-all-useflags</span>")
                        (buffer-string)))))

(defun anything-c-gentoo-get-url (elm)
  "<span class="quote">Return a list of urls from eix output.</span>"
  (loop
     with url-list = (split-string
                      (with-temp-buffer
                        (call-process "<span class="quote">eix</span>" nil t nil
                                      elm "<span class="quote">--format</span>" "<span class="quote">&lt;homepage&gt;\n</span>")
                        (buffer-string)))
     with all
     for i in url-list
     when (and (string-match "<span class="quote">^http://.*</span>" i)
               (not (member i all)))
     collect i into all
     finally return all))

(defun anything-c-gentoo-get-world ()
  "<span class="quote">Return list of all installed package on your system.</span>"
  (split-string (with-temp-buffer
                  (call-process "<span class="quote">qlist</span>" nil t nil
                                "<span class="quote">-I</span>")
                  (buffer-string))))

(defun anything-c-gentoo-get-local-use ()
  (split-string (with-temp-buffer
                  (call-process "<span class="quote">portageq</span>" nil t nil
                                "<span class="quote">envvar</span>"
                                "<span class="quote">USE</span>")
                  (buffer-string))))

(defface anything-gentoo-match-face '((t (:foreground "<span class="quote">red</span>")))
  "<span class="quote">Face for anything-gentoo installed packages.</span>"
  :group 'traverse-faces)

(defun anything-c-highlight-world (eix)
  "<span class="quote">Highlight all installed package.</span>"
  (loop for i in eix
     if (member i anything-c-cache-world)
     collect (propertize i 'face 'anything-gentoo-match-face)
     else
     collect i))

(defun anything-c-highlight-local-use (use-flags)
  (let ((local-uses (anything-c-gentoo-get-local-use)))
    (loop for i in use-flags
       if (member i local-uses)
       collect (propertize i 'face 'anything-gentoo-match-face)
       else
       collect i)))

(defvar anything-c-source-emacs-process
  '((name . "<span class="quote">Emacs Process</span>")
    (candidates . (lambda () (mapcar #'process-name (process-list))))
    (persistent-action . (lambda (elm)
                           (delete-process (get-process elm))
                           (anything-delete-current-selection)))
    (persistent-help . "<span class="quote">Kill Process</span>")
    (action ("<span class="quote">Kill Process</span>" . (lambda (elm)
                                (delete-process (get-process elm)))))))

<span class="linecomment">;; (anything 'anything-c-source-emacs-process)</span>

<span class="linecomment">;; Run Externals commands within Emacs</span>
(defmacro* anything-comp-hash-get-items (hash-table &key test)
  "<span class="quote">Get the list of all keys/values of hash-table.</span>"
  `(let ((li-items ()))
     (maphash #'(lambda (x y)
                  (if ,test
                      (when (funcall ,test y)
                        (push (list x y) li-items))
                      (push (list x y) li-items)))
              ,hash-table)
     li-items))

(defun anything-comp-read-get-candidates (collection &optional test sort-fn)
  "<span class="quote">Convert COLLECTION to list removing elements that don't match TEST.
SORT-FN is a predicate to sort COLLECTION.
If collection is an `obarray', a TEST is needed. See `obarray'.</span>"
  (let ((cands
         (cond ((and (listp collection) test)
                (loop for i in collection when (funcall test i) collect i))
               ((and (eq collection obarray) test)
                (loop for s being the symbols of collection
                   when (funcall test s) collect s))
               ((and (vectorp collection) test)
                (loop for i across collection when (funcall test i) collect i))
               ((vectorp collection)
                (loop for i across collection collect i))
               ((and (hash-table-p collection) test)
                (anything-comp-hash-get-items collection :test test))
               ((hash-table-p collection)
                (anything-comp-hash-get-items collection))
               (t collection))))
    (if sort-fn (sort cands sort-fn) cands)))

(defun anything-cr-default-transformer (candidates source)
  "<span class="quote">Default filter candidate function for `anything-comp-read'.
Do nothing, just return candidate list unmodified.</span>"
  candidates)

(defun* anything-comp-read (prompt collection
                                   &key
                                   test
                                   initial-input
                                   (buffer "<span class="quote">*Anything Completions*</span>")
                                   must-match
                                   (requires-pattern 0)
                                   (history nil)
                                   (persistent-action nil)
                                   (persistent-help "<span class="quote">DoNothing</span>")
                                   (name "<span class="quote">Anything Completions</span>")
                                   sort
                                   (fc-transformer 'anything-cr-default-transformer)
                                   (marked-candidates nil))
  "<span class="quote">Anything `completing-read' emulation.
PROMPT is the prompt name to use.
COLLECTION can be a list, vector, obarray or hash-table.
Keys:

TEST: A predicate called with one arg i.e candidate.
INITIAL-INPUT: Same as initial-input arg in `anything'.
BUFFER: Name of anything-buffer.
MUST-MATCH: Candidate selected must be one of COLLECTION.
REQUIRES-PATTERN: Same as anything attribute, default is 0.
HISTORY: A list containing specific history, default is nil.
When it is non--nil, all elements of HISTORY are displayed in
anything-buffer before COLLECTION.
PERSISTENT-ACTION: A function called with one arg i.e candidate.
PERSISTENT-HELP: A string to document PERSISTENT-ACTION.
NAME: The name related to this local source.
SORT: A predicate to give to `sort' e.g `string-lessp'.
FC-TRANSFORMER: A `filtered-candidate-transformer' function.
MARKED-CANDIDATES: If non--nil return candidate or marked candidates as a list.

Any prefix args passed during `anything-comp-read' invocation will be recorded
in `anything-current-prefix-arg', otherwise if prefix args where given before
`anything-comp-read' invocation, the value of `current-prefix-arg' will be used.
That's mean you can pass prefix arg before or after calling
a command that use `anything-comp-read'.</span>"
  (when (get-buffer anything-action-buffer)
    (kill-buffer anything-action-buffer))
  (flet ((action-fn (candidate)
           (if marked-candidates
               (anything-marked-candidates)
               (identity candidate))))
    (or (anything
         :sources
         `(((name . ,(format "<span class="quote">%s History</span>" name))
            (candidates . (lambda ()
                            (anything-comp-read-get-candidates history)))
            (volatile)
            (persistent-action . ,persistent-action)
            (persistent-help . ,persistent-help)
            (action . ,'action-fn))
           ((name . ,name)
            (candidates
             . (lambda ()
                 (let ((cands (anything-comp-read-get-candidates
                               collection test sort)))
                   (if (or must-match (string= anything-pattern "<span class="quote"></span>"))
                       cands (append (list anything-pattern) cands)))))
            (filtered-candidate-transformer ,fc-transformer)
            (requires-pattern . ,requires-pattern)
            (persistent-action . ,persistent-action)
            (persistent-help . ,persistent-help)
            (volatile)
            (action . ,'action-fn)))
         :input initial-input
         :prompt prompt
         :resume 'noresume
         :buffer buffer)
        (keyboard-quit))))

(defun anything-c-get-pid-from-process-name (process-name)
  "<span class="quote">Get pid from running process PROCESS-NAME.</span>"
  (loop with process-list = (list-system-processes)
     for pid in process-list
     for process = (assoc-default 'comm (process-attributes pid))
     when (and process (string-match process-name process))
     return pid))


(defun anything-run-or-raise (exe &optional file)
  "<span class="quote">Generic command that run asynchronously EXE.
If EXE is already running just jump to his window if `anything-raise-command'
is non--nil.
When FILE argument is provided run EXE with FILE.
In this case EXE must be provided as \"EXE %s\".</span>"
  (lexical-let* ((real-com (car (split-string (replace-regexp-in-string
                                               "<span class="quote">'%s'</span>" "<span class="quote"></span>" exe))))
                 (proc     (if file (concat real-com "<span class="quote"> </span>" file) real-com)))
    (if (get-process proc)
        (if anything-raise-command
            (shell-command  (format anything-raise-command real-com))
            (error "<span class="quote">Error: %s is already running</span>" real-com))
        (when (loop for i in anything-c-external-commands-list thereis real-com)
          (message "<span class="quote">Starting %s...</span>" real-com)
          (if file
              (start-process-shell-command proc nil (format exe file))
              (start-process-shell-command proc nil real-com))
          (set-process-sentinel
           (get-process proc)
           #'(lambda (process event)
               (when (and (string= event "<span class="quote">finished\n</span>")
                          anything-raise-command
                          (not (anything-c-get-pid-from-process-name real-com)))
                 (shell-command  (format anything-raise-command "<span class="quote">emacs</span>")))
               (message "<span class="quote">%s process...Finished.</span>" process))))
        (setq anything-c-external-commands-list
              (cons real-com
                    (delete real-com anything-c-external-commands-list))))))


(defvar anything-external-command-history nil)
<span class="linecomment">;;;###autoload</span>
(defun anything-c-run-external-command (program)
  "<span class="quote">Preconfigured `anything' to run External PROGRAM asyncronously from Emacs.
If program is already running exit with error.
You can set your own list of commands with
`anything-c-external-commands-list'.</span>"
  (interactive (list
                (anything-comp-read
                 "<span class="quote">RunProgram: </span>"
                 (anything-c-external-commands-list-1 'sort)
                 :must-match t
                 :name "<span class="quote">External Commands</span>"
                 :history anything-external-command-history)))
  (anything-run-or-raise program)
  (setq anything-external-command-history
        (cons program (delete program
                              (loop for i in anything-external-command-history
                                 when (executable-find i) collect i)))))

(defsubst* anything-c-position (item seq &key (test 'eq))
  "<span class="quote">A simple and faster replacement of CL `position'.</span>"
  (loop for i in seq for index from 0
     when (funcall test i item) return index))

(defvar anything-c-source-ratpoison-commands
  '((name . "<span class="quote">Ratpoison Commands</span>")
    (init . anything-c-ratpoison-commands-init)
    (candidates-in-buffer)
    (action ("<span class="quote">Execute the command</span>" . anything-c-ratpoison-commands-execute))
    (display-to-real . anything-c-ratpoison-commands-display-to-real)
    (candidate-number-limit)))
<span class="linecomment">;; (anything 'anything-c-source-ratpoison-commands)</span>

(defun anything-c-ratpoison-commands-init ()
  (unless (anything-candidate-buffer)
    (with-current-buffer (anything-candidate-buffer 'global)
      <span class="linecomment">;; with ratpoison prefix key</span>
      (save-excursion
        (call-process "<span class="quote">ratpoison</span>" nil (current-buffer) nil "<span class="quote">-c</span>" "<span class="quote">help</span>"))
      (while (re-search-forward "<span class="quote">^\\([^ ]+\\) \\(.+\\)$</span>" nil t)
        (replace-match "<span class="quote">&lt;ratpoison&gt; \\1: \\2</span>"))
      (goto-char (point-max))
      <span class="linecomment">;; direct binding</span>
      (save-excursion
        (call-process "<span class="quote">ratpoison</span>" nil (current-buffer) nil "<span class="quote">-c</span>" "<span class="quote">help top</span>"))
      (while (re-search-forward "<span class="quote">^\\([^ ]+\\) \\(.+\\)$</span>" nil t)
        (replace-match "<span class="quote">\\1: \\2</span>")))))

(defun anything-c-ratpoison-commands-display-to-real (display)
  (and (string-match "<span class="quote">: </span>" display)
       (substring display (match-end 0))))

(defun anything-c-ratpoison-commands-execute (candidate)
  (call-process "<span class="quote">ratpoison</span>" nil nil nil "<span class="quote">-ic</span>" candidate))

<span class="linecomment">;;;###autoload</span>
(defun anything-ratpoison-commands ()
  "<span class="quote">Preconfigured `anything' to execute ratpoison commands.</span>"
  (interactive)
  (anything-other-buffer 'anything-c-source-ratpoison-commands
                         "<span class="quote">*anything ratpoison commands*</span>"))

<span class="linecomment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Action Helpers ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="linecomment">;;; Files</span>
(defvar anything-c-external-commands-list nil
  "<span class="quote">A list of all external commands the user can execute.  If this
variable is not set by the user, it will be calculated
automatically.</span>")

(defun anything-c-external-commands-list-1 (&optional sort)
  "<span class="quote">Returns a list of all external commands the user can execute.
If `anything-c-external-commands-list' is non-nil it will
return its contents.  Else it calculates all external commands
and sets `anything-c-external-commands-list'.</span>"
  (if anything-c-external-commands-list
      anything-c-external-commands-list
      (setq anything-c-external-commands-list
            (loop
               with paths = (split-string (getenv "<span class="quote">PATH</span>") path-separator)
               with completions = ()
               for dir in paths
               when (and (file-exists-p dir) (file-accessible-directory-p dir))
               for lsdir = (loop for i in (directory-files dir t)
                              for bn = (file-name-nondirectory i)
                              when (and (not (member bn completions))
                                        (not (file-directory-p i))
                                        (file-executable-p i))
                              collect bn)
               append lsdir into completions
               finally return (if sort (sort completions 'string-lessp) completions)))))


(defun anything-c-file-buffers (filename)
  "<span class="quote">Returns a list of buffer names corresponding to FILENAME.</span>"
  (let ((name     (expand-file-name filename))
        (buf-list ()))
    (dolist (buf (buffer-list) buf-list)
      (let ((bfn (buffer-file-name buf)))
        (when (and bfn (string= name bfn))
          (push (buffer-name buf) buf-list))))))


(defun anything-c-delete-file (file)
  "<span class="quote">Delete the given file after querying the user.
Ask to kill buffers associated with that file, too.</span>"
  (let ((buffers (anything-c-file-buffers file)))
    (if (&lt; emacs-major-version 24)
        <span class="linecomment">;; `dired-delete-file' in Emacs versions &lt; 24</span>
        <span class="linecomment">;; doesn't support delete-by-moving-to-trash</span>
        <span class="linecomment">;; so use `delete-directory' and `delete-file'</span>
        <span class="linecomment">;; that handle it.</span>
        (cond ((and (not (file-symlink-p file))
                    (file-directory-p file)
                    (directory-files file t dired-re-no-dot))
               (when (y-or-n-p (format "<span class="quote">Recursive delete of `%s'? </span>" file))
                 (delete-directory file 'recursive)))
              ((and (not (file-symlink-p file))
                    (file-directory-p file))
               (delete-directory file))
              (t (delete-file file)))
        (dired-delete-file
         file 'dired-recursive-deletes delete-by-moving-to-trash))
    (when buffers
      (dolist (buf buffers)
        (when (y-or-n-p (format "<span class="quote">Kill buffer %s, too? </span>" buf))
          (kill-buffer buf))))))

(defun anything-get-mailcap-for-file (filename)
  "<span class="quote">Get the command to use for FILENAME from mailcap files.
The command is like &lt;command %s&gt; and is meant to use with `format'.</span>"
  (mailcap-parse-mailcaps)
  (let* ((ext  (file-name-extension filename))
         (mime (when ext (mailcap-extension-to-mime ext)))
         (result (when mime (mailcap-mime-info mime))))
    <span class="linecomment">;; If elisp file have no associations in .mailcap</span>
    <span class="linecomment">;; `mailcap-maybe-eval' is returned, in this case just return nil.</span>
    (when (stringp result) result)))

(defcustom anything-c-default-external-file-browser "<span class="quote">nautilus</span>"
  "<span class="quote">Default external file browser for your system.
Directories will be opened externally with it.
Set to nil if you do not have external file browser
or do not want to use it.</span>"
  :group 'anything-config
  :type  'string)

(defun anything-get-default-program-for-file (filename)
  "<span class="quote">Try to find a default program to open FILENAME.
Try first in `anything-c-external-programs-associations' and then in mailcap file
if nothing found return nil.</span>"
  (let* ((ext      (file-name-extension filename))
         (def-prog (assoc-default ext anything-c-external-programs-associations)))
    (cond ((and def-prog (not (string= def-prog "<span class="quote"></span>")))
           (concat def-prog "<span class="quote"> %s</span>"))
          ((and anything-c-default-external-file-browser
                (file-directory-p filename))
           (concat anything-c-default-external-file-browser "<span class="quote"> %s</span>"))
          (t (anything-get-mailcap-for-file filename)))))

(defun anything-c-open-file-externally (file)
  "<span class="quote">Open FILE with an external program.
Try to guess which program to use with `anything-get-default-program-for-file'.
If not found or a prefix arg is given query the user which tool to use.</span>"
  (let* ((fname          (expand-file-name file))
         (collection     (anything-c-external-commands-list-1 'sort))
         (def-prog       (anything-get-default-program-for-file fname))
         (real-prog-name (if (or anything-current-prefix-arg (not def-prog))
                             <span class="linecomment">;; Prefix arg or no default program.</span>
                             (prog1
                                 (anything-comp-read
                                  "<span class="quote">Program: </span>" collection
                                  :must-match t
                                  :name "<span class="quote">Open file Externally</span>"
                                  :history anything-external-command-history)
                               <span class="linecomment">;; Always prompt to set this program as default.</span>
                               (setq def-prog nil))
                             <span class="linecomment">;; No prefix arg or default program exists.</span>
                             (replace-regexp-in-string "<span class="quote"> %s\\| '%s'</span>" "<span class="quote"></span>" def-prog)))
         (program        (concat real-prog-name "<span class="quote"> '%s'</span>")))
    (unless (or def-prog <span class="linecomment">; Association exists, no need to record it.</span>
                <span class="linecomment">;; Don't try to record non--filenames associations (e.g urls).</span>
                (not (file-exists-p fname)))
      (when
          (y-or-n-p
           (format
            "<span class="quote">Do you want to make `%s' the default program for this kind of files? </span>"
            real-prog-name))
        (anything-aif (assoc (file-name-extension fname)
                             anything-c-external-programs-associations)
            (setq anything-c-external-programs-associations
                  (delete it anything-c-external-programs-associations)))
        (push (cons (file-name-extension fname)
                    (read-string
                     "<span class="quote">Program (Add args maybe and confirm): </span>" real-prog-name))
              anything-c-external-programs-associations)
        (customize-save-variable 'anything-c-external-programs-associations
                                 anything-c-external-programs-associations)))
    (anything-run-or-raise program file)
    (setq anything-external-command-history
          (cons real-prog-name
                (delete real-prog-name
                        (loop for i in anything-external-command-history
                             when (executable-find i) collect i))))))


<span class="linecomment">;;;###autoload</span>
(defun w32-shell-execute-open-file (file)
  (interactive "<span class="quote">fOpen file:</span>")
  (with-no-warnings
    (w32-shell-execute "<span class="quote">open</span>" (replace-regexp-in-string <span class="linecomment">;for UNC paths</span>
                               "<span class="quote">/</span>" "<span class="quote">\\</span>"
                               (replace-regexp-in-string <span class="linecomment">; strip cygdrive paths</span>
                                "<span class="quote">/cygdrive/\\(.\\)</span>" "<span class="quote">\\1:</span>"
                                file nil nil) nil t))))

(defun anything-c-open-file-with-default-tool (file)
  "<span class="quote">Open FILE with the default tool on this platform.</span>"
  (if (eq system-type 'windows-nt)
      (w32-shell-execute-open-file file)
    (start-process "<span class="quote">anything-c-open-file-with-default-tool</span>"
                   nil
                   (cond ((eq system-type 'gnu/linux)
                          "<span class="quote">xdg-open</span>")
                         ((or (eq system-type 'darwin) <span class="linecomment">;; Mac OS X</span>
                              (eq system-type 'macos)) <span class="linecomment">;; Mac OS 9</span>
                          "<span class="quote">open</span>"))
                   file)))

(defun anything-c-open-dired (file)
  "<span class="quote">Opens a dired buffer in FILE's directory.  If FILE is a
directory, open this directory.</span>"
  (if (file-directory-p file)
      (dired file)
    (dired (file-name-directory file))
    (dired-goto-file file)))

(defun anything-c-display-to-real-line (candidate)
  (if (string-match "<span class="quote">^ *\\([0-9]+\\):\\(.*\\)$</span>" candidate)
      (list (string-to-number (match-string 1 candidate)) (match-string 2 candidate))
    (error "<span class="quote">Line number not found</span>")))

(defun anything-c-action-line-goto (lineno-and-content)
  (apply #'anything-goto-file-line (anything-interpret-value (anything-attr 'target-file))
         (append lineno-and-content
                 (list (if (and (anything-attr-defined 'target-file)
                                (not anything-in-persistent-action))
                           'find-file-other-window
                         'find-file)))))

(defun* anything-c-action-file-line-goto (file-line-content &optional (find-file-function #'find-file))
  (apply #'anything-goto-file-line
         (if (stringp file-line-content)
             <span class="linecomment">;; Case: filtered-candidate-transformer is skipped</span>
             (cdr (anything-c-filtered-candidate-transformer-file-line-1 file-line-content))
           file-line-content)))

(require 'compile)
(defun anything-c-filtered-candidate-transformer-file-line (candidates source)
  (delq nil (mapcar 'anything-c-filtered-candidate-transformer-file-line-1 candidates)))

(defun anything-c-filtered-candidate-transformer-file-line-1 (candidate)
  (when (string-match "<span class="quote">^\\(.+?\\):\\([0-9]+\\):\\(.*\\)$</span>" candidate)
    (let ((filename (match-string 1 candidate))
          (lineno (match-string 2 candidate))
          (content (match-string 3 candidate)))
      (cons (format "<span class="quote">%s:%s\n %s</span>"
                    (propertize filename 'face compilation-info-face)
                    (propertize lineno 'face compilation-line-face)
                    content)
            (list (expand-file-name
                   filename
                   (or (anything-interpret-value (anything-attr 'default-directory))
                       (and (anything-candidate-buffer)
                            (buffer-local-value
                             'default-directory (anything-candidate-buffer)))))
                  (string-to-number lineno) content)))))

(defun* anything-goto-file-line (file lineno content &optional (find-file-function #'find-file))
  (anything-aif (anything-attr 'before-jump-hook)
      (funcall it))
  (when file (funcall find-file-function file))
  (if (anything-attr-defined 'adjust)
      (anything-c-goto-line-with-adjustment lineno content)
    (anything-goto-line lineno))
  (unless (anything-attr-defined 'recenter)
    (set-window-start (get-buffer-window anything-current-buffer) (point)))
  (anything-aif (anything-attr 'after-jump-hook)
      (funcall it))
  (when anything-in-persistent-action
    (anything-match-line-color-current-line)))

(defun anything-find-file-as-root (candidate)
  (find-file (concat "<span class="quote">/</span>" anything-su-or-sudo "<span class="quote">::</span>" (expand-file-name candidate))))

(defun anything-find-many-files (ignore)
  (mapc 'find-file (anything-marked-candidates)))

<span class="linecomment">;; borrowed from etags.el</span>
<span class="linecomment">;; (anything-c-goto-line-with-adjustment (line-number-at-pos) ";; borrowed from etags.el")</span>
(defun anything-c-goto-line-with-adjustment (line line-content)
  (let ((startpos)
        offset found pat)
    <span class="linecomment">;; This constant is 1/2 the initial search window.</span>
    <span class="linecomment">;; There is no sense in making it too small,</span>
    <span class="linecomment">;; since just going around the loop once probably</span>
    <span class="linecomment">;; costs about as much as searching 2000 chars.</span>
    (setq offset 1000
          found nil
          pat (concat (if (eq selective-display t)
                          "<span class="quote">\\(^\\|\^m\\) *</span>" "<span class="quote">^ *</span>") <span class="linecomment">;allow indent</span>
                      (regexp-quote line-content)))
    <span class="linecomment">;; If no char pos was given, try the given line number.</span>
    (setq startpos (progn (anything-goto-line line) (point)))
    (or startpos (setq startpos (point-min)))
    <span class="linecomment">;; First see if the tag is right at the specified location.</span>
    (goto-char startpos)
    (setq found (looking-at pat))
    (while (and (not found)
                (progn
                  (goto-char (- startpos offset))
                  (not (bobp))))
      (setq found
            (re-search-forward pat (+ startpos offset) t)
            offset (* 3 offset)))       <span class="linecomment">; expand search window</span>
    (or found
        (re-search-forward pat nil t)
        (error "<span class="quote">not found</span>")))
  <span class="linecomment">;; Position point at the right place</span>
  <span class="linecomment">;; if the search string matched an extra Ctrl-m at the beginning.</span>
  (and (eq selective-display t)
       (looking-at "<span class="quote">\^m</span>")
       (forward-char 1))
  (beginning-of-line))

(anything-document-attribute 'default-directory "<span class="quote">type . file-line</span>"
  "<span class="quote">`default-directory' to interpret file.</span>")
(anything-document-attribute 'before-jump-hook "<span class="quote">type . file-line / line</span>"
  "<span class="quote">Function to call before jumping to the target location.</span>")
(anything-document-attribute 'after-jump-hook "<span class="quote">type . file-line / line</span>"
  "<span class="quote">Function to call after jumping to the target location.</span>")
(anything-document-attribute 'adjust "<span class="quote">type . file-line</span>"
  "<span class="quote">Search around line matching line contents.</span>")
(anything-document-attribute 'recenter "<span class="quote">type . file-line / line</span>"
  "<span class="quote">`recenter' after jumping.</span>")
(anything-document-attribute 'target-file "<span class="quote">type . line</span>"
  "<span class="quote">Goto line of target-file.</span>")

<span class="linecomment">;;;###autoload</span>
(defun anything-c-call-interactively (cmd-or-name)
  "<span class="quote">Execute CMD-OR-NAME as Emacs command.
It is added to `extended-command-history'.
`anything-current-prefix-arg' is used as the command's prefix argument.</span>"
  (setq extended-command-history
        (cons (anything-c-stringify cmd-or-name)
              (delete (anything-c-stringify cmd-or-name) extended-command-history)))
  (let ((current-prefix-arg anything-current-prefix-arg)
        (cmd (anything-c-symbolify cmd-or-name)))
    (if (stringp (symbol-function cmd))
        (execute-kbd-macro (symbol-function cmd))
      (setq this-command cmd)
      (call-interactively cmd))))

<span class="linecomment">;;;###autoload</span>
(defun anything-c-set-variable (var)
  "<span class="quote">Set value to VAR interactively.</span>"
  (interactive)
  (let ((sym (anything-c-symbolify var)))
    (set sym (eval-minibuffer (format "<span class="quote">Set %s: </span>" var)
                              (prin1-to-string (symbol-value sym))))))
<span class="linecomment">;; (setq hh 12)</span>
<span class="linecomment">;; (anything-c-set-variable 'hh)</span>

<span class="linecomment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Persistent Action Helpers ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
(defvar anything-match-line-overlay-face nil)
(defvar anything-match-line-overlay nil)

(defun anything-match-line-color-current-line (&optional start end buf face rec)
  "<span class="quote">Highlight and underline current position</span>"
  (let ((args (list (or start (line-beginning-position))
                    (or end (1+ (line-end-position)))
                    buf)))
    (if (not anything-match-line-overlay)
        (setq anything-match-line-overlay (apply 'make-overlay args))
      (apply 'move-overlay anything-match-line-overlay args)))
  (overlay-put anything-match-line-overlay
               'face (or face anything-match-line-overlay-face))
  (when rec
    (goto-char start)
    (recenter)))

(defalias 'anything-persistent-highlight-point 'anything-match-line-color-current-line)

(defface anything-overlay-line-face '((t (:background "<span class="quote">IndianRed4</span>" :underline t)))
  "<span class="quote">Face for source header in the anything buffer.</span>" :group 'anything)

(setq anything-match-line-overlay-face 'anything-overlay-line-face)

(defun anything-match-line-cleanup ()
  (when anything-match-line-overlay
    (delete-overlay anything-match-line-overlay)
    (setq anything-match-line-overlay nil)))

(defun anything-match-line-update ()
  (when anything-match-line-overlay
    (delete-overlay anything-match-line-overlay)
    (anything-match-line-color-current-line)))

(add-hook 'anything-cleanup-hook 'anything-match-line-cleanup)
(add-hook 'anything-after-persistent-action-hook 'anything-match-line-update)

<span class="linecomment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Actions Transformers ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="linecomment">;;; Files</span>
(defun anything-c-transform-file-load-el (actions candidate)
  "<span class="quote">Add action to load the file CANDIDATE if it is an emacs lisp
file.  Else return ACTIONS unmodified.</span>"
  (if (member (file-name-extension candidate) '("<span class="quote">el</span>" "<span class="quote">elc</span>"))
      (append actions '(("<span class="quote">Load Emacs Lisp File</span>" . load-file)))
    actions))

(defun anything-c-transform-file-browse-url (actions candidate)
  "<span class="quote">Add an action to browse the file CANDIDATE if it in a html
file or URL.  Else return ACTIONS unmodified.</span>"
  (let ((browse-action '("<span class="quote">Browse with Browser</span>" . browse-url)))
    (cond ((string-match "<span class="quote">^http\\|^ftp</span>" candidate)
           (cons browse-action actions))
          ((string-match "<span class="quote">\\.html?$</span>" candidate)
           (append actions (list browse-action)))
          (t actions))))

<span class="linecomment">;;;; Function</span>
(defun anything-c-transform-function-call-interactively (actions candidate)
  "<span class="quote">Add an action to call the function CANDIDATE interactively if
it is a command.  Else return ACTIONS unmodified.</span>"
  (if (commandp (intern-soft candidate))
      (append actions '(("<span class="quote">Call Interactively</span>"
                         .
                         anything-c-call-interactively)))
    actions))

<span class="linecomment">;;;; S-Expressions</span>
(defun anything-c-transform-sexp-eval-command-sexp (actions candidate)
  "<span class="quote">If CANDIDATE's `car' is a command, then add an action to
evaluate it and put it onto the `command-history'.</span>"
  (if (commandp (car (read candidate)))
      <span class="linecomment">;; Make it first entry</span>
      (cons '("<span class="quote">Eval and put onto command-history</span>" .
              (lambda (sexp)
                (let ((sym (read sexp)))
                  (eval sym)
                  (setq command-history
                        (cons sym command-history)))))
            actions)
    actions))

<span class="linecomment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Candidate Transformers ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="linecomment">;;; Buffers</span>
(defun anything-c-skip-boring-buffers (buffers)
  (anything-c-skip-entries buffers anything-c-boring-buffer-regexp))

(defun anything-c-skip-current-buffer (buffers)
  (if anything-allow-skipping-current-buffer
      (remove (buffer-name anything-current-buffer) buffers)
      buffers))

(defun anything-c-shadow-boring-buffers (buffers)
  "<span class="quote">Buffers matching `anything-c-boring-buffer-regexp' will be
displayed with the `file-name-shadow' face if available.</span>"
  (anything-c-shadow-entries buffers anything-c-boring-buffer-regexp))

(defvar anything-c-buffer-display-string-functions
  '(anything-c-buffer-display-string--compilation
    anything-c-buffer-display-string--shell
    anything-c-buffer-display-string--eshell)
  "<span class="quote">Functions to setup display string for buffer.

Function has one argument, buffer name.
If it returns string, use it.
If it returns nil, display buffer name.
See `anything-c-buffer-display-string--compilation' for example.</span>")

(defun anything-c-transform-buffer-display-string (buffers)
  "<span class="quote">Setup display string for buffer candidates
using `anything-c-buffer-display-string-functions'.</span>"
  (loop for buf in buffers
        if (consp buf)
        collect buf
        else
        for disp = (progn (set-buffer buf)
                          (run-hook-with-args-until-success
                           'anything-c-buffer-display-string-functions buf))
        collect (if disp (cons disp buf) buf)))

(defun anything-c-buffer-display-string--compilation (buf)
  (anything-aif (car compilation-arguments)
      (format "<span class="quote">%s: %s [%s]</span>" buf it default-directory)))
(defun anything-c-buffer-display-string--eshell (buf)
  (when (eq major-mode 'eshell-mode)
    (format "<span class="quote">%s: %s [%s]</span>" buf
            (ignore-errors (ring-ref eshell-history-ring 0))
            default-directory)))
(defun anything-c-buffer-display-string--shell (buf)
  (when (eq major-mode 'shell-mode)
    (format "<span class="quote">%s: %s [%s]</span>" buf
            (ignore-errors (ring-ref comint-input-ring 0))
            default-directory)))

<span class="linecomment">;;; Files</span>
(defun anything-c-shadow-boring-files (files)
  "<span class="quote">Files matching `anything-c-boring-file-regexp' will be
displayed with the `file-name-shadow' face if available.</span>"
  (anything-c-shadow-entries files anything-c-boring-file-regexp))

(defun anything-c-skip-boring-files (files)
  "<span class="quote">Files matching `anything-c-boring-file-regexp' will be skipped.</span>"
  (anything-c-skip-entries files anything-c-boring-file-regexp))
<span class="linecomment">;; (anything-c-skip-boring-files '("README" "/src/.svn/hoge"))</span>

(defun anything-c-skip-current-file (files)
  "<span class="quote">Current file will be skipped.</span>"
  (remove (buffer-file-name anything-current-buffer) files))

(defun anything-c-w32-pathname-transformer (args)
  "<span class="quote">Change undesirable features of windows pathnames to ones more acceptable to
other candidate transformers.</span>"
  (if (eq system-type 'windows-nt)
      (mapcar (lambda (x)
                (replace-regexp-in-string "<span class="quote">/cygdrive/\\(.\\)</span>" "<span class="quote">\\1:</span>" x))
              (mapcar (lambda (y)
                        (replace-regexp-in-string "<span class="quote">\\\\</span>" "<span class="quote">/</span>" y)) args))
    args))

(defun anything-c-shorten-home-path (files)
  "<span class="quote">Replaces /home/user with ~.</span>"
  (let ((home (replace-regexp-in-string "<span class="quote">\\\\</span>" "<span class="quote">/</span>" <span class="linecomment">; stupid Windows...</span>
                                        (getenv "<span class="quote">HOME</span>"))))
    (mapcar (lambda (file)
              (if (and (stringp file) (string-match home file))
                  (cons (replace-match "<span class="quote">~</span>" nil nil file) file)
                file))
            files)))

<span class="linecomment">;;; Functions</span>
(defun anything-c-mark-interactive-functions (functions)
  "<span class="quote">Mark interactive functions (commands) with (i) after the function name.</span>"
  (let (list)
    (loop for function in functions
          do (push (cons (concat function
                                 (when (commandp (intern-soft function)) "<span class="quote"> (i)</span>"))
                         function)
                   list)
          finally (return (nreverse list)))))

<span class="linecomment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Adaptive Sorting of Candidates ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

<span class="linecomment">;; Internal</span>
(defvar anything-c-adaptive-done nil
  "<span class="quote">nil if history information is not yet stored for the current
selection.</span>")

(defvar anything-c-adaptive-history nil
  "<span class="quote">Contains the stored history information.
Format: ((SOURCE-NAME (SELECTED-CANDIDATE (PATTERN . NUMBER-OF-USE) ...) ...) ...)</span>")

(defcustom anything-c-use-adaptative-sorting nil
  "<span class="quote">*Wheter to use or not adaptative sorting.
Even if a source use it, it will have no effect when set to nil.</span>"
  :type 'boolean
  :group 'anything-config)

(defadvice anything-initialize (before anything-c-adaptive-initialize activate)
  "<span class="quote">Advise `anything-initialize' to reset `anything-c-adaptive-done'
when anything is started.</span>"
  (when anything-c-use-adaptative-sorting
    (setq anything-c-adaptive-done nil)))

(defadvice anything-exit-minibuffer (before anything-c-adaptive-exit-minibuffer activate)
  "<span class="quote">Advise `anything-exit-minibuffer' to store history information
when a candidate is selected with RET.</span>"
  (when anything-c-use-adaptative-sorting
    (anything-c-adaptive-store-selection)))

(defadvice anything-select-action (before anything-c-adaptive-select-action activate)
  "<span class="quote">Advise `anything-select-action' to store history information
when the user goes to the action list with TAB.</span>"
  (when anything-c-use-adaptative-sorting
    (anything-c-adaptive-store-selection)))

(defun anything-c-source-use-adaptative-p (&optional source-name)
  "<span class="quote">Return current source only if it use adaptative history, nil otherwise.</span>"
  (when anything-c-use-adaptative-sorting
    (let* ((source (or source-name (anything-get-current-source)))
           (adapt-source (or (assoc-default 'filtered-candidate-transformer
                                            (assoc (assoc-default 'type source)
                                                   anything-type-attributes))
                             (assoc-default 'candidate-transformer
                                            (assoc (assoc-default 'type source)
                                                   anything-type-attributes))
                             (assoc-default 'filtered-candidate-transformer source)
                             (assoc-default 'candidate-transformer source))))
      (if (listp adapt-source)
          (when (member 'anything-c-adaptive-sort adapt-source) source)
          (when (eq adapt-source 'anything-c-adaptive-sort) source)))))

(defun anything-c-adaptive-store-selection ()
  "<span class="quote">Store history information for the selected candidate.</span>"
  (unless anything-c-adaptive-done
    (setq anything-c-adaptive-done t)
    (let ((source (anything-c-source-use-adaptative-p)))
      (when source
        (let* ((source-name (or (assoc-default 'type source)
                                (assoc-default 'name source)))
               (source-info (or (assoc source-name anything-c-adaptive-history)
                                (progn
                                  (push (list source-name) anything-c-adaptive-history)
                                  (car anything-c-adaptive-history))))
               (selection (anything-get-selection))
               (selection-info (progn
                                 (setcdr source-info
                                         (cons
                                          (let ((found (assoc selection (cdr source-info))))
                                            (if (not found)
                                                <span class="linecomment">;; new entry</span>
                                                (list selection)

                                                <span class="linecomment">;; move entry to the beginning of the</span>
                                                <span class="linecomment">;; list, so that it doesn't get</span>
                                                <span class="linecomment">;; trimmed when the history is</span>
                                                <span class="linecomment">;; truncated</span>
                                                (setcdr source-info
                                                        (delete found (cdr source-info)))
                                                found))
                                          (cdr source-info)))
                                 (cadr source-info)))
               (pattern-info (progn
                               (setcdr selection-info
                                       (cons
                                        (let ((found (assoc anything-pattern (cdr selection-info))))
                                          (if (not found)
                                              <span class="linecomment">;; new entry</span>
                                              (cons anything-pattern 0)

                                              <span class="linecomment">;; move entry to the beginning of the</span>
                                              <span class="linecomment">;; list, so if two patterns used the</span>
                                              <span class="linecomment">;; same number of times then the one</span>
                                              <span class="linecomment">;; used last appears first in the list</span>
                                              (setcdr selection-info
                                                      (delete found (cdr selection-info)))
                                              found))
                                        (cdr selection-info)))
                               (cadr selection-info))))

          <span class="linecomment">;; increase usage count</span>
          (setcdr pattern-info (1+ (cdr pattern-info)))

          <span class="linecomment">;; truncate history if needed</span>
          (if (&gt; (length (cdr selection-info)) anything-c-adaptive-history-length)
              (setcdr selection-info
                      (subseq (cdr selection-info) 0 anything-c-adaptive-history-length))))))))

(defun anything-c-adaptative-maybe-load-history ()
  (when (and anything-c-use-adaptative-sorting
           (file-readable-p anything-c-adaptive-history-file))
  (load-file anything-c-adaptive-history-file)))

(add-hook 'emacs-startup-hook 'anything-c-adaptative-maybe-load-history)
(add-hook 'kill-emacs-hook 'anything-c-adaptive-save-history)

(defun anything-c-adaptive-save-history ()
  "<span class="quote">Save history information to file given by `anything-c-adaptive-history-file'.</span>"
  (interactive)
  (when anything-c-use-adaptative-sorting
    (with-temp-buffer
      (insert
       "<span class="quote">;; -*- mode: emacs-lisp -*-\n</span>"
       "<span class="quote">;; History entries used for anything adaptive display.\n</span>")
      (prin1 `(setq anything-c-adaptive-history ',anything-c-adaptive-history)
             (current-buffer))
      (insert ?\n)
      (write-region (point-min) (point-max) anything-c-adaptive-history-file nil
                    (unless (interactive-p) 'quiet)))))

(defun anything-c-adaptive-sort (candidates source)
  "<span class="quote">Sort the CANDIDATES for SOURCE by usage frequency.
This is a filtered candidate transformer you can use for the
attribute `filtered-candidate-transformer' of a source in
`anything-sources' or a type in `anything-type-attributes'.</span>"
  (let* ((source-name (or (assoc-default 'type source)
                          (assoc-default 'name source)))
         (source-info (assoc source-name anything-c-adaptive-history)))
    (if source-info
        (let ((usage
               <span class="linecomment">;; ... assemble a list containing the (CANIDATE . USAGE-COUNT)</span>
               <span class="linecomment">;; pairs</span>
               (mapcar (lambda (candidate-info)
                         (let ((count 0))
                           (dolist (pattern-info (cdr candidate-info))
                             (if (not (equal (car pattern-info)
                                             anything-pattern))
                                 (incf count (cdr pattern-info))

                                 <span class="linecomment">;; if current pattern is equal to the previously</span>
                                 <span class="linecomment">;; used one then this candidate has priority</span>
                                 <span class="linecomment">;; (that's why its count is boosted by 10000) and</span>
                                 <span class="linecomment">;; it only has to compete with other candidates</span>
                                 <span class="linecomment">;; which were also selected with the same pattern</span>
                                 (setq count (+ 10000 (cdr pattern-info)))
                                 (return)))
                           (cons (car candidate-info) count)))
                       (cdr source-info)))
              sorted)
          (if (and usage (consp usage))
              <span class="linecomment">;; sort the list in descending order, so candidates with highest</span>
              <span class="linecomment">;; priorty come first</span>
              (progn
                (setq usage (sort usage (lambda (first second)
                                          (&gt; (cdr first) (cdr second)))))

                <span class="linecomment">;; put those candidates first which have the highest usage count</span>
                (dolist (info usage)
                  (when (member* (car info) candidates
                                 :test 'anything-c-adaptive-compare)
                    (push (car info) sorted)
                    (setq candidates (remove* (car info) candidates
                                              :test 'anything-c-adaptive-compare))))

                <span class="linecomment">;; and append the rest</span>
                (append (reverse sorted) candidates nil))
              (message "<span class="quote">Your `%s' is maybe corrupted or too old, \
you should reinitialize it with `anything-c-reset-adaptative-history'</span>"
                       anything-c-adaptive-history-file)
              (sit-for 1)
              candidates))
        <span class="linecomment">;; if there is no information stored for this source then do nothing</span>
        candidates)))

<span class="linecomment">;;;###autoload</span>
(defun anything-c-reset-adaptative-history ()
  "<span class="quote">Delete all `anything-c-adaptive-history' and his file.
Useful when you have a old or corrupted `anything-c-adaptive-history-file'.</span>"
  (interactive)
  (when (y-or-n-p "<span class="quote">Really delete all your `anything-c-adaptive-history'? </span>")
    (setq anything-c-adaptive-history nil)
    (delete-file anything-c-adaptive-history-file)))

(defun anything-c-adaptive-compare (x y)
  "<span class="quote">Compare candidates X and Y taking into account that the
candidate can be in (DISPLAY . REAL) format.</span>"
  (equal (if (listp x)
             (cdr x)
           x)
         (if (listp y)
             (cdr y)
           y)))

<span class="linecomment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Outliner ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
(defvar anything-outline-goto-near-line-flag t)
(defvar anything-outline-using nil)
(defun anything-after-update-hook--outline ()
  (if (and (eq anything-outline-using t)
           (eq anything-outline-goto-near-line-flag t))
      (anything-outline-goto-near-line)))
(add-hook 'anything-after-update-hook 'anything-after-update-hook--outline)

(defun anything-outline-goto-near-line ()
  (with-anything-window
    <span class="linecomment">;; TODO need consideration whether to update position by every input.</span>
    (when t <span class="linecomment">; (equal anything-pattern "")</span>
      (anything-goto-line 2)
      (let ((lineno (with-current-buffer anything-current-buffer
                      (line-number-at-pos (car anything-current-position)))))
        (block exit
          (while (&lt;= (progn (skip-chars-forward "<span class="quote"> </span>")
                            (or (number-at-point) lineno))
                     lineno)
            (forward-line 1)
            (when (eobp)
              (forward-line -1)
              (return-from exit))))
        (forward-line -1)
        (and (bobp) (forward-line 1))
        (and (anything-pos-header-line-p) (forward-line -2))
        (anything-mark-current-line)))))

<span class="linecomment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Plug-in ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="linecomment">;; Plug-in: info-index</span>
(defun* anything-c-info-init (&optional (file (anything-attr 'info-file)))
  (let (result)
    (unless (anything-candidate-buffer)
      (save-window-excursion
        (info file)
        (let (Info-history
              (tobuf (anything-candidate-buffer 'global))
              (infobuf (current-buffer))
              s e)
          (dolist (node (or (anything-attr 'index-nodes) (Info-index-nodes)))
            (Info-goto-node node)
            (goto-char (point-min))
            (while (search-forward "<span class="quote">\n* </span>" nil t)
              (unless (search-forward "<span class="quote">Menu:\n</span>" (1+ (point-at-eol)) t)
                '(save-current-buffer (buffer-substring-no-properties (point-at-bol) (point-at-eol)) result)
                (setq s (point-at-bol)
                      e (point-at-eol))
                (with-current-buffer tobuf
                  (insert-buffer-substring infobuf s e)
                  (insert "<span class="quote">\n</span>"))))))))))

(defun anything-c-info-goto (node-line)
  (Info-goto-node (car node-line))
  (anything-goto-line (cdr node-line)))

(defun anything-c-info-display-to-real (line)
  (and (string-match
        <span class="linecomment">;; This regexp is stolen from Info-apropos-matches</span>
        "<span class="quote">\\* +\\([^\n]*.+[^\n]*\\):[ \t]+\\([^\n]*\\)\\.\\(?:[ \t\n]*(line +\\([0-9]+\\))\\)?</span>" line)
       (cons (format "<span class="quote">(%s)%s</span>" (anything-attr 'info-file) (match-string 2 line))
             (string-to-number (or (match-string 3 line) "<span class="quote">1</span>")))))

(defun anything-c-make-info-source (source file)
  `(,@source
    (name . ,(concat "<span class="quote">Info Index: </span>" file))
    (info-file . ,file)
    (init . anything-c-info-init)
    (display-to-real . anything-c-info-display-to-real)
    (get-line . buffer-substring)
    (candidates-in-buffer)
    (action ("<span class="quote">Goto node</span>" . anything-c-info-goto))))

(defun anything-compile-source--info-index (source)
  (anything-aif (anything-interpret-value (assoc-default 'info-index source))
      (anything-c-make-info-source source it)
    source))
(add-to-list 'anything-compile-source-functions 'anything-compile-source--info-index)

(anything-document-attribute 'info-index "<span class="quote">info-index plugin</span>"
  "<span class="quote">Create a source of info index very easily.

ex. (defvar anything-c-source-info-wget '((info-index . \"wget\"))</span>")

(anything-document-attribute 'index-nodes "<span class="quote">info-index plugin (optional)</span>"
  "<span class="quote">Index nodes of info file.

If it is omitted, `Info-index-nodes' is used to collect index nodes.
Some info files are missing index specification.

ex. See `anything-c-source-info-screen'.</span>")

<span class="linecomment">;; Plug-in: candidates-file</span>
(defun anything-compile-source--candidates-file (source)
  (if (assoc-default 'candidates-file source)
      `((init anything-p-candidats-file-init
              ,@(let ((orig-init (assoc-default 'init source)))
                  (cond ((null orig-init) nil)
                        ((functionp orig-init) (list orig-init))
                        (t orig-init))))
        (candidates-in-buffer)
        ,@source)
    source))
(add-to-list 'anything-compile-source-functions 'anything-compile-source--candidates-file)

(defun anything-p-candidats-file-init ()
  (destructuring-bind (file &optional updating)
      (anything-mklist (anything-attr 'candidates-file))
    (setq file (anything-interpret-value file))
    (with-current-buffer (anything-candidate-buffer (find-file-noselect file))
      (when updating
        (buffer-disable-undo)
        (font-lock-mode -1)
        (auto-revert-mode 1)))))

(anything-document-attribute 'candidates-file "<span class="quote">candidates-file plugin</span>"
  "<span class="quote">Use a file as the candidates buffer.

1st argument is a filename, string or function name or variable name.
If optional 2nd argument is non-nil, the file opened with `auto-revert-mode'.</span>")

<span class="linecomment">;; Plug-in: headline</span>
(defun anything-compile-source--anything-headline (source)
  (if (assoc-default 'headline source)
      (append '((init . anything-headline-init)
                (get-line . buffer-substring)
                (type . line))
              source
              '((candidates-in-buffer)
                (persistent-help . "<span class="quote">Show this line</span>")))
    source))
(add-to-list 'anything-compile-source-functions 'anything-compile-source--anything-headline)

(defun anything-headline-init ()
  (when (and (anything-current-buffer-is-modified)
             (with-current-buffer anything-current-buffer
               (eval (or (anything-attr 'condition) t))))
    (anything-headline-make-candidate-buffer
     (anything-interpret-value (anything-attr 'headline))
     (anything-interpret-value (anything-attr 'subexp)))))

(anything-document-attribute 'headline "<span class="quote">Headline plug-in</span>"
  "<span class="quote">Regexp string for anything-headline to scan.</span>")
(anything-document-attribute 'condition "<span class="quote">Headline plug-in</span>"
  "<span class="quote">A sexp representing the condition to use anything-headline.</span>")
(anything-document-attribute 'subexp "<span class="quote">Headline plug-in</span>"
  "<span class="quote">Display (match-string-no-properties subexp).</span>")


(defun anything-headline-get-candidates (regexp subexp)
  (with-current-buffer anything-current-buffer
    (save-excursion
      (goto-char (point-min))
      (if (functionp regexp) (setq regexp (funcall regexp)))
      (let (hierarchy curhead)
        (flet ((matched ()
                 (if (numberp subexp)
                     (cons (match-string-no-properties subexp) (match-beginning subexp))
                     (cons (buffer-substring (point-at-bol) (point-at-eol))
                           (point-at-bol))))
               (hierarchies (headlines)
                 (1+ (loop for (_ . hierarchy) in headlines
                        maximize hierarchy)))
               (vector-0-n (v n)
                 (loop for i from 0 to hierarchy
                    collecting (aref curhead i)))
               (arrange (headlines)
                 (unless (null headlines) <span class="linecomment">; FIX headlines empty bug!</span>
                   (loop with curhead = (make-vector (hierarchies headlines) "<span class="quote"></span>")
                      for ((str . pt) . hierarchy) in headlines
                      do (aset curhead hierarchy str)
                      collecting
                        (cons
                         (format "<span class="quote">H%d:%s</span>" (1+ hierarchy)
                                 (mapconcat 'identity (vector-0-n curhead hierarchy) "<span class="quote"> / </span>"))
                         pt)))))
            (if (listp regexp)
              (arrange
               (sort
                (loop for re in regexp
                   for hierarchy from 0
                   do (goto-char (point-min))
                   appending
                     (loop
                        while (re-search-forward re nil t)
                        collect (cons (matched) hierarchy)))
                (lambda (a b) (&gt; (cdar b) (cdar a)))))
              (loop while (re-search-forward regexp nil t)
                 collect (matched))))))))


(defun anything-headline-make-candidate-buffer (regexp subexp)
  (with-current-buffer (anything-candidate-buffer 'local)
    (loop for (content . pos) in (anything-headline-get-candidates regexp subexp)
          do (insert
              (format "<span class="quote">%5d:%s\n</span>"
                      (with-current-buffer anything-current-buffer
                        (line-number-at-pos pos))
                      content)))))

(defun anything-headline-goto-position (pos recenter)
  (goto-char pos)
  (unless recenter
    (set-window-start (get-buffer-window anything-current-buffer) (point))))

(defun anything-revert-buffer (candidate)
  (with-current-buffer candidate
    (when (or (buffer-modified-p)
              (not (verify-visited-file-modtime
                    (get-buffer candidate))))
      (revert-buffer t t))))

(defun anything-revert-marked-buffers (ignore)
  (mapc 'anything-revert-buffer (anything-marked-candidates)))

(defun anything-kill-marked-buffers (ignore)
  (mapc 'kill-buffer (anything-marked-candidates)))

<span class="linecomment">;; Plug-in: persistent-help</span>
(defun anything-compile-source--persistent-help (source)
  (append source '((header-line . anything-persistent-help-string))))
(add-to-list 'anything-compile-source-functions 'anything-compile-source--persistent-help)

(defun anything-persistent-help-string ()
  (substitute-command-keys
   (concat "<span class="quote">\\&lt;anything-map&gt;\\[anything-execute-persistent-action]: </span>"
           (or (anything-interpret-value (anything-attr 'persistent-help))
               (anything-aif (or (assoc-default 'persistent-action
                                                (anything-get-current-source))
                                 (assoc-default 'action
                                                (anything-get-current-source)))
                   (cond ((symbolp it) (symbol-name it))
                         ((listp it) (or (ignore-errors (caar it))  "<span class="quote"></span>"))))
               "<span class="quote"></span>")
           "<span class="quote"> (keeping session)</span>")))

(anything-document-attribute 'persistent-help "<span class="quote">persistent-help plug-in</span>"
  "<span class="quote">A string to explain persistent-action of this source.
It also accepts a function or a variable name.</span>")

<span class="linecomment">;;; (anything '(((name . "persistent-help test")(candidates "a")(persistent-help . "TEST"))))</span>

<span class="linecomment">;; Plug-in: Type customize</span>
(defun anything-c-uniq-list (lst)
  "<span class="quote">Like `remove-duplicates' in CL.
But cut deeper duplicates and test by `equal'. </span>"
  (reverse (remove-duplicates (reverse lst) :test 'equal)))
(defvar anything-additional-type-attributes nil)
(defun anything-c-arrange-type-attribute (type spec)
  "<span class="quote">Override type attributes by `define-anything-type-attribute'.

The SPEC is like source. The symbol `REST' is replaced with original attribute value.

 Example: Set `play-sound-file' as default action
   (anything-c-arrange-type-attribute 'file
      '((action (\"Play sound\" . play-sound-file)
                REST ;; Rest of actions (find-file, find-file-other-window, ...)
   )))
</span>"
  (add-to-list 'anything-additional-type-attributes
               (cons type
                     (loop with typeattr = (assoc-default type anything-type-attributes)
                      for (attr . value) in spec
                      if (listp value)
                      collect (cons attr
                                    (anything-c-uniq-list
                                     (loop for v in value
                                           if (eq v 'REST)
                                           append (assoc-default attr typeattr)
                                           else
                                           collect v)))
                      else
                      collect (cons attr value)))))
(put 'anything-c-arrange-type-attribute 'lisp-indent-function 1)

(defun anything-compile-source--type-customize (source)
  (anything-aif (assoc-default (assoc-default 'type source) anything-additional-type-attributes)
      (append it source)
    source))
(add-to-list 'anything-compile-source-functions 'anything-compile-source--type-customize t)

<span class="linecomment">;; Plug-in: default-action</span>
(defun anything-compile-source--default-action (source)
  (anything-aif (assoc-default 'default-action source)
      (append `((action ,it ,@(remove it (assoc-default 'action source))))
              source)
    source))
(add-to-list 'anything-compile-source-functions 'anything-compile-source--default-action t)
(anything-document-attribute 'default-action "<span class="quote">default-action plug-in</span>"
  "<span class="quote">Default action.</span>")

<span class="linecomment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

(defun anything-c-find-file-or-marked (candidate)
  "<span class="quote">Open file CANDIDATE or open anything marked files in background.</span>"
  (let ((marked (anything-marked-candidates)))
    (if (&gt; (length marked) 1)
        <span class="linecomment">;; Open all marked files in background.</span>
        (mapc 'find-file-noselect marked)
        (if (and (not (file-exists-p candidate))
                 (and ffap-url-regexp
                      (not (string-match ffap-url-regexp candidate)))
                 (string-match "<span class="quote">/$</span>" candidate))
            <span class="linecomment">;; A a non--existing filename ending with /</span>
            <span class="linecomment">;; Create a directory and jump to it.</span>
            (when (y-or-n-p (format "<span class="quote">Create directory `%s'? </span>" candidate))
              (make-directory candidate 'parent)
              (anything-find-files1 candidate))
            <span class="linecomment">;; A non--existing filename NOT ending with / or</span>
            <span class="linecomment">;; an existing filename, create or jump to it.</span>
            (find-file-at-point (car marked))))))

(defun anything-delete-marked-files (ignore)
  (let* ((files (anything-marked-candidates))
         (len (length files)))
    (if (not (y-or-n-p
              (format "<span class="quote">Delete *%s File(s):\n%s</span>"
                      len
                      (mapconcat (lambda (f) (format "<span class="quote">- %s\n</span>" f)) files "<span class="quote"></span>"))))
        (message "<span class="quote">(No deletions performed)</span>")
      (dolist (i files)
        (set-text-properties 0 (length i) nil i)
        (anything-c-delete-file i))
      (message "<span class="quote">%s File(s) deleted</span>" len))))

(defun anything-ediff-marked-buffers (candidate &optional merge)
  "<span class="quote">Ediff 2 marked buffers or 1 marked buffer and current-buffer.
With optional arg `merge' call `ediff-merge-buffers'.</span>"
  (let ((lg-lst (length (anything-marked-candidates)))
        buf1 buf2)
    (case lg-lst
      (0
       (error "<span class="quote">Error:You have to mark at least 1 buffer</span>"))
      (1
       (setq buf1 anything-current-buffer
             buf2 (first (anything-marked-candidates))))
      (2
       (setq buf1 (first (anything-marked-candidates))
             buf2 (second (anything-marked-candidates))))
      (t
       (error "<span class="quote">Error:To much buffers marked!</span>")))
    (if merge
        (ediff-merge-buffers buf1 buf2)
        (ediff-buffers buf1 buf2))))

(defun anything-bookmark-get-bookmark-from-name (bmk)
  "<span class="quote">Return bookmark name even if it is a bookmark with annotation.
e.g prepended with *.
Return nil if bmk is not a valid bookmark.</span>"
  (let ((bookmark (replace-regexp-in-string "<span class="quote">\*</span>" "<span class="quote"></span>" bmk)))
    (if (assoc bookmark bookmark-alist)
        bookmark
        (when (assoc bmk bookmark-alist)
          bmk))))

(defun anything-delete-marked-bookmarks (ignore)
  "<span class="quote">Delete this bookmark or all marked bookmarks.</span>"
  (dolist (i (anything-marked-candidates))
    (bookmark-delete (anything-bookmark-get-bookmark-from-name i)
                     'batch)))

(defun anything-require-or-error (feature function)
  (or (require feature nil t)
      (error "<span class="quote">Need %s to use `%s'.</span>" feature function)))

(defun anything-find-buffer-on-elscreen (candidate)
  "<span class="quote">Open buffer in new screen, if marked buffers open all in elscreens.</span>"
  (anything-require-or-error 'elscreen 'anything-find-buffer-on-elscreen)
  (anything-aif (anything-marked-candidates)
      (dolist (i it)
        (let ((target-screen (elscreen-find-screen-by-buffer
                              (get-buffer i) 'create)))
          (elscreen-goto target-screen)))
    (let ((target-screen (elscreen-find-screen-by-buffer
                          (get-buffer candidate) 'create)))
      (elscreen-goto target-screen))))

(defun anything-elscreen-find-file (file)
  (anything-require-or-error 'elscreen 'anything-elscreen-find-file)
  (elscreen-find-file file))

<span class="linecomment">;; Toggle anything-match-plugin</span>
(defvar anything-mp-initial-highlight-delay nil)
(defun anything-c-toggle-match-plugin ()
  "<span class="quote">Toggle anything-match-plugin.</span>"
  (interactive)
  (let ((anything-match-plugin-enabled
         (member 'anything-compile-source--match-plugin
                 anything-compile-source-functions)))
    (flet ((disable-match-plugin ()
             (setq anything-compile-source-functions
                   (delq 'anything-compile-source--match-plugin
                         anything-compile-source-functions))
             (setq anything-mp-initial-highlight-delay
                   anything-mp-highlight-delay)
             (setq anything-mp-highlight-delay nil))
           (enable-match-plugin ()
             (require 'anything-match-plugin)
             (unless anything-mp-initial-highlight-delay
               (setq anything-mp-initial-highlight-delay
                     anything-mp-highlight-delay))
             (setq anything-compile-source-functions
                   (cons 'anything-compile-source--match-plugin
                         anything-compile-source-functions))
             (unless anything-mp-highlight-delay
               (setq anything-mp-highlight-delay
                     anything-mp-initial-highlight-delay))))
      (if anything-match-plugin-enabled
          (when (y-or-n-p "<span class="quote">Really disable match-plugin? </span>")
            (disable-match-plugin)
            (message "<span class="quote">Anything-match-plugin disabled</span>"))
          (when (y-or-n-p "<span class="quote">Really enable match-plugin? </span>")
            (enable-match-plugin)
            (message "<span class="quote">Anything-match-plugin enabled</span>"))))))


<span class="linecomment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Setup ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

<span class="linecomment">;;;; Type Attributes</span>
(define-anything-type-attribute 'buffer
  `((action
     ,@(if pop-up-frames
           `(("<span class="quote">Switch to buffer other window</span>" . switch-to-buffer-other-window)
             ,(and (locate-library "<span class="quote">popwin</span>") '("<span class="quote">Switch to buffer in popup window</span>" . popwin:popup-buffer))
             ("<span class="quote">Switch to buffer</span>" . switch-to-buffer))
         `(("<span class="quote">Switch to buffer</span>" . switch-to-buffer)
           ,(and (locate-library "<span class="quote">popwin</span>") '("<span class="quote">Switch to buffer in popup window</span>" . popwin:popup-buffer))
           ("<span class="quote">Switch to buffer other window</span>" . switch-to-buffer-other-window)
           ("<span class="quote">Switch to buffer other frame</span>" . switch-to-buffer-other-frame)))
     ,(and (locate-library "<span class="quote">elscreen</span>") '("<span class="quote">Display buffer in Elscreen</span>" . anything-find-buffer-on-elscreen))
     ("<span class="quote">Query replace regexp</span>" . anything-c-buffer-query-replace-regexp)
     ("<span class="quote">View buffer</span>" . view-buffer)
     ("<span class="quote">Display buffer</span>"   . display-buffer)
     ("<span class="quote">Grep buffers (C-u grep all buffers)</span>" . anything-c-grep-buffers)
     ("<span class="quote">Revert buffer(s)</span>" . anything-revert-marked-buffers)
     ("<span class="quote">Insert buffer</span>" . insert-buffer)
     ("<span class="quote">Kill buffer(s)</span>" . anything-kill-marked-buffers)
     ("<span class="quote">Diff with file</span>" . diff-buffer-with-file)
     ("<span class="quote">Ediff Marked buffers</span>" . anything-ediff-marked-buffers)
     ("<span class="quote">Ediff Merge marked buffers</span>" . (lambda (candidate)
                                       (anything-ediff-marked-buffers candidate t))))
    (persistent-help . "<span class="quote">Show this buffer</span>")
    (candidate-transformer anything-c-skip-current-buffer
                           anything-c-skip-boring-buffers
                           anything-c-transform-buffer-display-string))
  "<span class="quote">Buffer or buffer name.</span>")

(define-anything-type-attribute 'file
  `((action
     ,@(if pop-up-frames
           `(("<span class="quote">Find file other window</span>" . find-file-other-window)
             ,(and (locate-library "<span class="quote">popwin</span>") '("<span class="quote">Find file in popup window</span>" . popwin:find-file))
             ("<span class="quote">Find file(s)</span>" . anything-find-many-files)
             ("<span class="quote">Find file as root</span>" . anything-find-file-as-root))
         `(("<span class="quote">Find file</span>" . anything-find-many-files)
           ,(and (locate-library "<span class="quote">popwin</span>") '("<span class="quote">Find file in popup window</span>" . popwin:find-file))
           ("<span class="quote">Find file as root</span>" . anything-find-file-as-root)
           ("<span class="quote">Find file other window</span>" . find-file-other-window)
           ("<span class="quote">Find file other frame</span>" . find-file-other-frame)))
     ("<span class="quote">Open dired in file's directory</span>" . anything-c-open-dired)
     ("<span class="quote">Grep File(s) `C-u recurse'</span>" . anything-find-files-grep)
     ("<span class="quote">Pdfgrep File(s)</span>" . anything-ff-pdfgrep)
     ("<span class="quote">View file</span>" . view-file)
     ("<span class="quote">Insert file</span>" . insert-file)
     ("<span class="quote">Delete file(s)</span>" . anything-delete-marked-files)
     ("<span class="quote">Open file externally (C-u to choose)</span>" . anything-c-open-file-externally)
     ("<span class="quote">Open file with default tool</span>" . anything-c-open-file-with-default-tool)
     ("<span class="quote">Find file in hex dump</span>" . hexl-find-file))
    (persistent-help . "<span class="quote">Show this file</span>")
    (action-transformer anything-c-transform-file-load-el
                        anything-c-transform-file-browse-url)
    (candidate-transformer anything-c-w32-pathname-transformer
                           anything-c-skip-current-file
                           anything-c-skip-boring-files
                           anything-c-shorten-home-path))
  "<span class="quote">File name.</span>")

(let ((actions '(("<span class="quote">Describe command</span>" . describe-function)
                 ("<span class="quote">Add command to kill ring</span>" . anything-c-kill-new)
                 ("<span class="quote">Go to command's definition</span>" . find-function)
                 ("<span class="quote">Debug on entry</span>" . debug-on-entry)
                 ("<span class="quote">Cancel debug on entry</span>" . cancel-debug-on-entry)
                 ("<span class="quote">Trace function</span>" . trace-function)
                 ("<span class="quote">Trace function (background)</span>" . trace-function-background)
                 ("<span class="quote">Untrace function</span>" . untrace-function))))
  (define-anything-type-attribute 'command
    `((action ("<span class="quote">Call interactively</span>" . anything-c-call-interactively)
              ,@actions)
      <span class="linecomment">;; Sort commands according to their usage count.</span>
      <span class="linecomment">;(filtered-candidate-transformer . anything-c-adaptive-sort)</span>
      (coerce . anything-c-symbolify)
      (persistent-action . describe-function))
    "<span class="quote">Command. (string or symbol)</span>")

  (define-anything-type-attribute 'function
    `((action . ,actions)
      (action-transformer anything-c-transform-function-call-interactively)
      (candidate-transformer anything-c-mark-interactive-functions)
      (coerce . anything-c-symbolify))
    "<span class="quote">Function. (string or symbol)</span>"))

(define-anything-type-attribute 'variable
  '((action ("<span class="quote">Describe variable</span>" . describe-variable)
            ("<span class="quote">Add variable to kill ring</span>" . anything-c-kill-new)
            ("<span class="quote">Go to variable's definition</span>" . find-variable)
            ("<span class="quote">Set variable</span>" . anything-c-set-variable))
    (coerce . anything-c-symbolify))
  "<span class="quote">Variable.</span>")

(define-anything-type-attribute 'sexp
  '((action ("<span class="quote">Eval s-expression</span>" . (lambda (c) (eval (read c))))
            ("<span class="quote">Add s-expression to kill ring</span>" . kill-new))
    (action-transformer anything-c-transform-sexp-eval-command-sexp))
  "<span class="quote">String representing S-Expressions.</span>")

(define-anything-type-attribute 'bookmark
  `((coerce . anything-bookmark-get-bookmark-from-name)
    (action
     ("<span class="quote">Jump to bookmark</span>" . (lambda (bookmark)
                             (let ((current-prefix-arg anything-current-prefix-arg))
                               (bookmark-jump bookmark))
                             (anything-update)))
     ("<span class="quote">Jump to BM other window</span>" . (lambda (bookmark)
                                    (bookmark-jump-other-window bookmark)
                                    (anything-update)))
     ("<span class="quote">Bookmark edit annotation</span>" . bookmark-edit-annotation)
     ("<span class="quote">Bookmark show annotation</span>" . bookmark-show-annotation)
     ("<span class="quote">Delete bookmark(s)</span>" . anything-delete-marked-bookmarks)
     ,@(and (locate-library "<span class="quote">bookmark-extensions</span>")
           `(("<span class="quote">Edit Bookmark</span>" . bmkext-edit-bookmark)))
     ("<span class="quote">Rename bookmark</span>" . bookmark-rename)
     ("<span class="quote">Relocate bookmark</span>" . bookmark-relocate)))
     "<span class="quote">Bookmark name.</span>")

(define-anything-type-attribute 'line
  '((display-to-real . anything-c-display-to-real-line)
    (action ("<span class="quote">Go to Line</span>" . anything-c-action-line-goto)))
  "<span class="quote">LINENO:CONTENT string, eg. \"  16:foo\".

Optional `target-file' attribute is a name of target file.

Optional `before-jump-hook' attribute is a function with no
arguments which is called before jumping to position.

Optional `after-jump-hook' attribute is a function with no
arguments which is called after jumping to position.

If `adjust' attribute is specified, searches the line whose
content is CONTENT near the LINENO.

If `recenter' attribute is specified, the line is displayed at
the center of window, otherwise at the top of window.
</span>")

(define-anything-type-attribute 'file-line
  `((filtered-candidate-transformer anything-c-filtered-candidate-transformer-file-line)
    (multiline)
    (action ("<span class="quote">Go to</span>" . anything-c-action-file-line-goto)))
  "<span class="quote">FILENAME:LINENO:CONTENT string, eg. \"~/.emacs:16:;; comment\".

Optional `default-directory' attribute is a default-directory
FILENAME is interpreted.

Optional `before-jump-hook' attribute is a function with no
arguments which is called before jumping to position.

Optional `after-jump-hook' attribute is a function with no
arguments which is called after jumping to position.

If `adjust' attribute is specified, searches the line whose
content is CONTENT near the LINENO.

If `recenter' attribute is specified, the line is displayed at
the center of window, otherwise at the top of window.
</span>")

(define-anything-type-attribute 'timer
  '((real-to-display . anything-c-timer-real-to-display)
    (action ("<span class="quote">Cancel Timer</span>" . cancel-timer)
            ("<span class="quote">Describe Function</span>" . (lambda (tm) (describe-function (timer--function tm))))
            ("<span class="quote">Find Function</span>" . (lambda (tm) (find-function (timer--function tm)))))
    (persistent-action . (lambda (tm) (describe-function (timer--function tm))))
    (persistent-help . "<span class="quote">Describe Function</span>"))
  "<span class="quote">Timer.</span>")

<span class="linecomment">;;;; Default `anything-sources'</span>
<span class="linecomment">;; Setting `anything-sources' is DEPRECATED, but it seems that newbies</span>
<span class="linecomment">;; tend to invoke M-x anything directly. So I offer default setting.</span>
(setq anything-sources
      '(anything-c-source-buffers+
        anything-c-source-recentf
        anything-c-source-files-in-current-dir+))

<span class="linecomment">;; Unit tests are now in ../developer-tools/unit-test-anything-config.el.</span>

(provide 'anything-config)

<span class="linecomment">;;; Local Variables:</span>
<span class="linecomment">;;; time-stamp-format: "%:y-%02m-%02d %02H:%02M:%02S (%Z) %u"</span>
<span class="linecomment">;;; End:</span>

<span class="linecomment">;; How to save (DO NOT REMOVE!!)</span>
<span class="linecomment">;; (progn (magit-push) (emacswiki-post "anything-config.el"))</span>
<span class="linecomment">;;; anything-config.el ends here</span>

<span class="linecomment">;;; LocalWords:  Tassilo Patrovics Vagn Johansen Dahl Clementson infos</span>
<span class="linecomment">;;; LocalWords:  Kamphausen informations McBrayer Volpiatto bbdb bb</span>
<span class="linecomment">;;; LocalWords:  iswitchb imenu Recentf sym samewindow pos bol eol</span>
<span class="linecomment">;;; LocalWords:  aif str lst func attrib recentf lessp prin mapatoms commandp</span>
<span class="linecomment">;;; LocalWords:  cmd stb Picklist picklist mapcan subentry destructuring dirs</span>
<span class="linecomment">;;; LocalWords:  darwin locat MacOS mdfind Firstname Lastname calc prepend jids</span>
<span class="linecomment">;;; LocalWords:  dotimes Thierry online vname</span>
<span class="linecomment">;;; LocalWords:  csharp javascript lua makefile cperl zcat lineno buf</span>
<span class="linecomment">;;; LocalWords:  multiline href fn cand NewTitle cwd filepath thru ret</span>
<span class="linecomment">;;; LocalWords:  bfn fOpen UNC cygdrive nt xdg macos FILE's elc rx svn hg</span>
<span class="linecomment">;;; LocalWords:  CANDIDATE's darcs facep pathname args pathnames subseq priorty</span>
<span class="linecomment">;;; LocalWords:  Vokes rfind berkeley JST ffap lacarte bos</span>
<span class="linecomment">;;; LocalWords:  Lacarte Minibuf epp LaCarte bm attrset migemo attr conf mklist</span>
<span class="linecomment">;;; LocalWords:  startpos noselect dont desc</span></span></pre></div><div class="wrapper close"></div></div><div class="footer"><hr /><span class="gotobar bar"><a class="local" href="http://www.emacswiki.org/emacs/SiteMap">SiteMap</a> <a class="local" href="http://www.emacswiki.org/emacs/Search">Search</a> <a class="local" href="http://www.emacswiki.org/emacs/ElispArea">ElispArea</a> <a class="local" href="http://www.emacswiki.org/emacs/HowTo">HowTo</a> <a class="local" href="http://www.emacswiki.org/emacs/RecentChanges">RecentChanges</a> <a class="local" href="http://www.emacswiki.org/emacs/News">News</a> <a class="local" href="http://www.emacswiki.org/emacs/Problems">Problems</a> <a class="local" href="http://www.emacswiki.org/emacs/Suggestions">Suggestions</a> </span><span class="translation bar"><br />  <a class="translation new" rel="nofollow" href="http://www.emacswiki.org/emacs?action=translate;id=anything-config.el;missing=de_es_fr_it_ja_ko_pt_ru_se_zh">Add Translation</a></span><span class="edit bar"><br /> <a class="edit" accesskey="e" title="Click to edit this page" rel="nofollow" href="http://www.emacswiki.org/emacs?action=edit;id=anything-config.el">Edit this page</a> <a class="history" rel="nofollow" href="http://www.emacswiki.org/emacs?action=history;id=anything-config.el">View other revisions</a> <a class="admin" rel="nofollow" href="http://www.emacswiki.org/emacs?action=admin;id=anything-config.el">Administration</a></span><span class="time"><br /> Last edited 2011-06-09 07:03 UTC by <a class="author" title="from 142.211.85.79.rev.sfr.net" href="http://www.emacswiki.org/emacs/ThierryVolpiatto">ThierryVolpiatto</a> <a class="diff" rel="nofollow" href="http://www.emacswiki.org/emacs?action=browse;diff=2;id=anything-config.el">(diff)</a></span><div style="float:right; margin-left:1ex;">
<!-- Creative Commons License -->
<a href="http://creativecommons.org/licenses/GPL/2.0/"><img alt="CC-GNU GPL" style="border:none" src="/pics/cc-GPL-a.png" /></a>
<!-- /Creative Commons License -->
</div>

<!--
<rdf:RDF xmlns="http://web.resource.org/cc/"
 xmlns:dc="http://purl.org/dc/elements/1.1/"
 xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
<Work rdf:about="">
   <license rdf:resource="http://creativecommons.org/licenses/GPL/2.0/" />
  <dc:type rdf:resource="http://purl.org/dc/dcmitype/Software" />
</Work>

<License rdf:about="http://creativecommons.org/licenses/GPL/2.0/">
   <permits rdf:resource="http://web.resource.org/cc/Reproduction" />
   <permits rdf:resource="http://web.resource.org/cc/Distribution" />
   <requires rdf:resource="http://web.resource.org/cc/Notice" />
   <permits rdf:resource="http://web.resource.org/cc/DerivativeWorks" />
   <requires rdf:resource="http://web.resource.org/cc/ShareAlike" />
   <requires rdf:resource="http://web.resource.org/cc/SourceCode" />
</License>
</rdf:RDF>
-->

<p class="legal">
This work is licensed to you under version 2 of the
<a href="http://www.gnu.org/">GNU</a> <a href="/GPL">General Public License</a>.
Alternatively, you may choose to receive this work under any other
license that grants the right to use, copy, modify, and/or distribute
the work, as long as that license imposes the restriction that
derivative works have to grant the same rights and impose the same
restriction. For example, you may choose to receive this work under
the
<a href="http://www.gnu.org/">GNU</a>
<a href="/FDL">Free Documentation License</a>, the
<a href="http://creativecommons.org/">CreativeCommons</a>
<a href="http://creativecommons.org/licenses/sa/1.0/">ShareAlike</a>
License, the XEmacs manual license, or
<a href="/OLD">similar licenses</a>.
</p>
</div>
</body>
</html>
